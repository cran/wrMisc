<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />

<meta name="author" content="Wolfgang Raffelsberger" />

<meta name="date" content="2025-06-17" />

<title>Getting started with wrMisc</title>

<script>// Pandoc 2.9 adds attributes on both header and div. We remove the former (to
// be compatible with the behavior of Pandoc < 2.8).
document.addEventListener('DOMContentLoaded', function(e) {
  var hs = document.querySelectorAll("div.section[class*='level'] > :first-child");
  var i, h, a;
  for (i = 0; i < hs.length; i++) {
    h = hs[i];
    if (!/^h[1-6]$/i.test(h.tagName)) continue;  // it should be a header h1-h6
    a = h.attributes;
    while (a.length > 0) h.removeAttribute(a[0].name);
  }
});
</script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/rstudio/markdown/inst/resources/prism-xcode.css" data-external="1">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/yihui/knitr/inst/misc/vignette.css" data-external="1">
<script src="https://cdn.jsdelivr.net/combine/npm/@xiee/utils/js/code-lang.min.js,npm/@xiee/utils/js/number-captions.min.js,npm/prismjs@1.29.0/components/prism-core.min.js" data-external="1" defer></script>
<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js" data-external="1" defer></script>

<style type="text/css">
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
span.underline{text-decoration: underline;}
div.column{display: inline-block; vertical-align: top; width: 50%;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
</style>











</head>

<body>




<h1 class="title toc-ignore">Getting started with wrMisc</h1>
<h4 class="author">Wolfgang Raffelsberger</h4>
<h4 class="date">2025-06-17</h4>


<div id="TOC">
<ul>
<li><a href="#introduction" id="toc-introduction">Introduction</a>
<ul>
<li><a href="#dependencies-and-compilation" id="toc-dependencies-and-compilation">Dependencies and
Compilation</a></li>
<li><a href="#installation-and-loading" id="toc-installation-and-loading">Installation And Loading</a></li>
</ul></li>
<li><a href="#speed-optimized-functions-in-the-package-wrmisc" id="toc-speed-optimized-functions-in-the-package-wrmisc">Speed Optimized
Functions In The Package wrMisc</a>
<ul>
<li><a href="#assessing-basic-information-about-variability-for-matrix" id="toc-assessing-basic-information-about-variability-for-matrix">Assessing
Basic Information About Variability (for matrix)</a></li>
<li><a href="#data-organized-in-sub-groups-as-sets-of-columns" id="toc-data-organized-in-sub-groups-as-sets-of-columns">Data Organized
In (Sub-)Groups As Sets Of Columns</a></li>
<li><a href="#fast-na-omit-for-very-large-objects" id="toc-fast-na-omit-for-very-large-objects">Fast NA-omit For Very Large
Objects</a></li>
<li><a href="#minimum-distancedifference-between-values" id="toc-minimum-distancedifference-between-values">Minimum
Distance/Difference Between Values</a></li>
</ul></li>
<li><a href="#WorkingWithLists" id="toc-WorkingWithLists">Working With
Lists (And Lists Of Lists)</a>
<ul>
<li><a href="#partial-unlist" id="toc-partial-unlist">Partial
unlist</a></li>
<li><a href="#appendingcombining-lists" id="toc-appendingcombining-lists">Appending/Combining Lists</a></li>
<li><a href="#rbind-on-lists" id="toc-rbind-on-lists">rbind On
Lists</a></li>
<li><a href="#merge-multiple-matrices-from-list" id="toc-merge-multiple-matrices-from-list">Merge Multiple Matrices From
List</a></li>
<li><a href="#fuse-content-of-list-elements-with-redundant-duplicated-names" id="toc-fuse-content-of-list-elements-with-redundant-duplicated-names">Fuse
Content Of List-Elements With Redundant (Duplicated) Names</a></li>
<li><a href="#filtering-lines-andor-columns-for-all-list-elements-of-same-size" id="toc-filtering-lines-andor-columns-for-all-list-elements-of-same-size">Filtering
Lines And/Or Columns For All List-Elements Of Same Size</a></li>
<li><a href="#replacements-in-list" id="toc-replacements-in-list">Replacements In List</a></li>
<li><a href="#organize-values-into-list-and-sort-by-names" id="toc-organize-values-into-list-and-sort-by-names">Organize Values
Into list and Sort By Names</a></li>
<li><a href="#batch-filter-list-elements" id="toc-batch-filter-list-elements">Batch-filter List-Elements</a></li>
<li><a href="#transform-columns-of-matrix-to-list-of-vectors" id="toc-transform-columns-of-matrix-to-list-of-vectors">Transform
Columns Of Matrix To List Of Vectors</a></li>
</ul></li>
<li><a href="#WorkingWithArrays" id="toc-WorkingWithArrays">Working With
Arrays</a>
<ul>
<li><a href="#cv-coefficient-of-variance-with-arrays" id="toc-cv-coefficient-of-variance-with-arrays">CV (Coefficient Of
Variance) With Arrays</a></li>
<li><a href="#slice-3-dim-array-in-list-of-matrixes-or-arrays" id="toc-slice-3-dim-array-in-list-of-matrixes-or-arrays">Slice 3-dim
Array In List Of Matrixes (Or Arrays)</a></li>
</ul></li>
<li><a href="#WorkingWithRedundantData" id="toc-WorkingWithRedundantData">Working With Redundant Data</a>
<ul>
<li><a href="#identify-what-is-repeated-and-where-repeated-do-occur" id="toc-identify-what-is-repeated-and-where-repeated-do-occur">Identify
What Is Repeated (and Where Repeated Do Occur)</a></li>
<li><a href="#correct-vector-to-unique-while-maintaining-the-original-vector-length" id="toc-correct-vector-to-unique-while-maintaining-the-original-vector-length">Correct
Vector To Unique (While Maintaining The Original Vector Length)</a></li>
<li><a href="#mark-any-duplicated-ie-ambiguous-elements-by-changing-their-names-and-separate-from-unqiue" id="toc-mark-any-duplicated-ie-ambiguous-elements-by-changing-their-names-and-separate-from-unqiue">Mark
Any Duplicated (ie Ambiguous) Elements by Changing Their Names (and
Separate from Unqiue)</a></li>
<li><a href="#compare-multiple-vectors-and-sort-by-number-of-commonrepeated-valueswords" id="toc-compare-multiple-vectors-and-sort-by-number-of-commonrepeated-valueswords">Compare
Multiple Vectors And Sort By Number Of Common/Repeated
Values/Words</a></li>
<li><a href="#combine-multiple-matrixes-where-some-column-names-are-the-same" id="toc-combine-multiple-matrixes-where-some-column-names-are-the-same">Combine
Multiple Matrixes Where Some Column-Names Are The Same</a></li>
<li><a href="#filter-matrix-to-keep-only-first-of-repeated-lines" id="toc-filter-matrix-to-keep-only-first-of-repeated-lines">Filter
Matrix To Keep Only First Of Repeated Lines</a></li>
<li><a href="#filter-to-unique-column-content-of-matrix-add-counter-and-concatenated-information" id="toc-filter-to-unique-column-content-of-matrix-add-counter-and-concatenated-information">Filter
To Unique Column-Content Of Matrix, Add Counter And Concatenated
Information</a></li>
<li><a href="#get-first-of-repeated-by-column" id="toc-get-first-of-repeated-by-column">Get First Of Repeated By
Column</a></li>
<li><a href="#transform-ambigous-matrix-to-non-ambiguous-matrix-in-respect-to-given-column" id="toc-transform-ambigous-matrix-to-non-ambiguous-matrix-in-respect-to-given-column">Transform
(ambigous) Matrix To Non-ambiguous Matrix (In Respect To Given
Column)</a></li>
<li><a href="#combine-replicates-from-list-to-matrix" id="toc-combine-replicates-from-list-to-matrix">Combine Replicates From
List To Matrix</a></li>
<li><a href="#combine-redundant-lines-from-list-with-multiple-matrix-according-to-reference" id="toc-combine-redundant-lines-from-list-with-multiple-matrix-according-to-reference">Combine
Redundant Lines From List with (Multiple) Matrix According to
Reference</a></li>
<li><a href="#non-redundant-lines-of-matrix" id="toc-non-redundant-lines-of-matrix">Non-redundant Lines Of
Matrix</a></li>
<li><a href="#filter-for-unique-elements-2" id="toc-filter-for-unique-elements-2">Filter For Unique Elements
/2</a></li>
<li><a href="#make-non-redundant-matrix" id="toc-make-non-redundant-matrix">Make Non-redundant Matrix</a></li>
<li><a href="#combinereduce-redundant-lines-based-on-specified-column" id="toc-combinereduce-redundant-lines-based-on-specified-column">Combine/Reduce
Redundant Lines Based On Specified Column</a></li>
<li><a href="#convert-matrix-eg-with-redundant-row-names-to-data.frame" id="toc-convert-matrix-eg-with-redundant-row-names-to-data.frame">Convert
Matrix (eg With Redundant) Row-Names To data.frame</a></li>
<li><a href="#find-and-combine-points-located-very-close-in-xy-space" id="toc-find-and-combine-points-located-very-close-in-xy-space">Find And
Combine Points Located Very Close In X/Y Space</a></li>
<li><a href="#bin-and-summarize-values-according-to-their-names" id="toc-bin-and-summarize-values-according-to-their-names">Bin And
Summarize Values According To Their Names</a></li>
<li><a href="#regrouping-simultaneaously-by-two-factors" id="toc-regrouping-simultaneaously-by-two-factors">Regrouping
Simultaneaously by Two Factors</a></li>
<li><a href="#batch-replacing-of-values-or-character-strings" id="toc-batch-replacing-of-values-or-character-strings">Batch Replacing
Of Values Or Character-Strings</a></li>
<li><a href="#multi-to-multi-matching-of-concatenated-terms" id="toc-multi-to-multi-matching-of-concatenated-terms">Multi-to-multi
Matching Of (Concatenated) Terms</a></li>
<li><a href="#ComparingGlobalPatterns" id="toc-ComparingGlobalPatterns">Comparing Global Patterns</a></li>
</ul></li>
<li><a href="#SearchForSimilarNumericValues" id="toc-SearchForSimilarNumericValues">Search For Similar (Numeric)
Values</a>
<ul>
<li><a href="#find-similar-numeric-values-of-two-columns-of-a-matrix" id="toc-find-similar-numeric-values-of-two-columns-of-a-matrix">Find
Similar Numeric Values Of Two Columns Of A Matrix</a></li>
<li><a href="#find-similar-numeric-values-from-two-vectorsmatrixes" id="toc-find-similar-numeric-values-from-two-vectorsmatrixes">Find
Similar Numeric Values From Two Vectors/Matrixes</a></li>
<li><a href="#fuse-previously-identified-pairs-to-clusters" id="toc-fuse-previously-identified-pairs-to-clusters">Fuse Previously
Identified Pairs To ‘Clusters’</a></li>
<li><a href="#eliminate-close-overlapping-points-in-bivariate-x-y-space" id="toc-eliminate-close-overlapping-points-in-bivariate-x-y-space">Eliminate
Close (Overlapping) Points (In Bivariate x &amp; y Space)</a></li>
<li><a href="#mode-of-continuous-data" id="toc-mode-of-continuous-data">Mode Of (Continuous) Data</a></li>
<li><a href="#most-frequently-occuring-value-traditional-mode" id="toc-most-frequently-occuring-value-traditional-mode">Most Frequently
Occuring Value (traditional mode)</a></li>
</ul></li>
<li><a href="#Text-Manipulations" id="toc-Text-Manipulations">Text-Manipulations</a>
<ul>
<li><a href="#protect-special-characters" id="toc-protect-special-characters">Protect Special Characters</a></li>
<li><a href="#trimming-redundant-text" id="toc-trimming-redundant-text">Trimming Redundant Text</a></li>
<li><a href="#removing-redundantshared-words" id="toc-removing-redundantshared-words">Removing Redundant/Shared
Words</a></li>
<li><a href="#extract-common-part-of-text" id="toc-extract-common-part-of-text">Extract Common Part Of
Text</a></li>
<li><a href="#manipulating-enumerator-extensions" id="toc-manipulating-enumerator-extensions">Manipulating
Enumerator-Extensions</a></li>
<li><a href="#findchoose-column-most-likely-containing-sample-names" id="toc-findchoose-column-most-likely-containing-sample-names">Find/Choose
Column Most Likely Containing Sample-Names</a></li>
<li><a href="#find-common-unit" id="toc-find-common-unit">Find Common
Unit</a></li>
<li><a href="#adjust-decimal-prefixes-and-extact-numericunit-part" id="toc-adjust-decimal-prefixes-and-extact-numericunit-part">Adjust
Decimal Prefixes And Extact Numeric+Unit Part</a></li>
<li><a href="#merging-multiple-named-vectors-to-matrix" id="toc-merging-multiple-named-vectors-to-matrix">Merging Multiple Named
Vectors To Matrix</a></li>
<li><a href="#match-all-lines-of-matrix-to-reference-note" id="toc-match-all-lines-of-matrix-to-reference-note">Match All Lines of
Matrix To Reference Note</a></li>
<li><a href="#order-matrix-according-to-reference" id="toc-order-matrix-according-to-reference">Order Matrix According To
Reference</a></li>
<li><a href="#value-matching-with-option-for-concatenated-terms" id="toc-value-matching-with-option-for-concatenated-terms">Value
Matching With Option For Concatenated Terms</a></li>
<li><a href="#check-for-strict-order" id="toc-check-for-strict-order">Check for (Strict) Order</a></li>
</ul></li>
<li><a href="#WorkingWithRegressions" id="toc-WorkingWithRegressions">Working With Regressions</a>
<ul>
<li><a href="#best-starting-point-for-linear-regressions-start-of-linearity" id="toc-best-starting-point-for-linear-regressions-start-of-linearity">Best
Starting Point For Linear Regressions (Start of linearity)</a></li>
<li><a href="#high-throughput-testing-for-linear-regressions" id="toc-high-throughput-testing-for-linear-regressions">High Throughput
Testing For Linear Regressions</a></li>
</ul></li>
<li><a href="#CombinatoricsIssues" id="toc-CombinatoricsIssues">Combinatorics Issues</a>
<ul>
<li><a href="#all-pairwise-ratios" id="toc-all-pairwise-ratios">All
Pairwise Ratios</a></li>
<li><a href="#count-frequency-of-terms-combined-from-different-drawings-combineasn" id="toc-count-frequency-of-terms-combined-from-different-drawings-combineasn">Count
Frequency Of Terms Combined From Different Drawings
(combineAsN)</a></li>
</ul></li>
<li><a href="#importexport" id="toc-importexport">Import/Export</a>
<ul>
<li><a href="#batch-reading-of-csv-files" id="toc-batch-reading-of-csv-files">Batch-Reading Of CSV Files</a></li>
<li><a href="#batch-reading-of-tabulated-files" id="toc-batch-reading-of-tabulated-files">Batch-Reading Of Tabulated
Files</a></li>
<li><a href="#reading-incomplete-tables" id="toc-reading-incomplete-tables">Reading Incomplete Tables</a></li>
<li><a href="#converting-url-for-reading-tabulated-data-from-github" id="toc-converting-url-for-reading-tabulated-data-from-github">Converting
Url For Reading Tabulated Data From GitHub</a></li>
</ul></li>
<li><a href="#Normalization" id="toc-Normalization">Normalization</a>
<ul>
<li><a href="#filter-lines-of-matrix-to-reduce-content-of-nas" id="toc-filter-lines-of-matrix-to-reduce-content-of-nas">Filter Lines Of
Matrix To Reduce Content Of NAs</a></li>
<li><a href="#the-function-normalizethis" id="toc-the-function-normalizethis">The Function
normalizeThis()</a></li>
<li><a href="#normalize-by-rows" id="toc-normalize-by-rows">Normalize By
Rows</a></li>
<li><a href="#matrix-coordinates-of-valuespoints-according-to-filtering" id="toc-matrix-coordinates-of-valuespoints-according-to-filtering">Matrix
Coordinates Of Values/Points According To Filtering</a></li>
<li><a href="#trimmed-mean" id="toc-trimmed-mean">Trimmed Mean</a></li>
</ul></li>
<li><a href="#StatisticalTesting" id="toc-StatisticalTesting">Statistical Testing</a>
<ul>
<li><a href="#normal-random-number-generation-with-close-fit-to-expected-mean-and-sd" id="toc-normal-random-number-generation-with-close-fit-to-expected-mean-and-sd">Normal
Random Number Generation with Close Fit to Expected mean and sd</a></li>
<li><a href="#moderated-pair-wise-t-test-from-limma" id="toc-moderated-pair-wise-t-test-from-limma">Moderated Pair-Wise
t-Test from limma</a></li>
<li><a href="#multiple-moderated-pair-wise-t-tests-from-limma" id="toc-multiple-moderated-pair-wise-t-tests-from-limma">Multiple
Moderated Pair-Wise t-Tests From limma</a></li>
<li><a href="#transform-p-values-to-local-false-discovery-rate-lfdr" id="toc-transform-p-values-to-local-false-discovery-rate-lfdr">Transform
p-values To Local False Discovery Rate (lfdr)</a></li>
<li><a href="#confindence-intervals-under-normal-distribution" id="toc-confindence-intervals-under-normal-distribution">Confindence
Intervals (under Normal Distribution)</a></li>
<li><a href="#extract-groups-of-replicates-from-pair-wise-column-names" id="toc-extract-groups-of-replicates-from-pair-wise-column-names">Extract
Groups Of Replicates From Pair-Wise Column-Names</a></li>
<li><a href="#extract-numeric-part-of-column-names" id="toc-extract-numeric-part-of-column-names">Extract Numeric Part Of
Column-Names</a></li>
<li><a href="#automatic-determination-of-replicate-structure-based-on-meta-data" id="toc-automatic-determination-of-replicate-structure-based-on-meta-data">Automatic
Determination Of Replicate Structure Based On Meta-Data</a></li>
</ul></li>
<li><a href="#WorkingWithClustering" id="toc-WorkingWithClustering">Working With Clustering</a>
<ul>
<li><a href="#prepare-data-for-clustering" id="toc-prepare-data-for-clustering">Prepare Data For
Clustering</a></li>
<li><a href="#characterize-clustering-results" id="toc-characterize-clustering-results">Characterize Clustering
Results</a></li>
<li><a href="#remove-or-reassign-orphans" id="toc-remove-or-reassign-orphans">Remove or Reassign Orphans</a></li>
</ul></li>
<li><a href="#TreeLikeStructures" id="toc-TreeLikeStructures">Tree-Like
Structures</a>
<ul>
<li><a href="#filter-lists-of-connected-nodes-extension-of-networks-as-sandwich" id="toc-filter-lists-of-connected-nodes-extension-of-networks-as-sandwich">Filter
Lists Of Connected Nodes, Extension Of Networks As ‘Sandwich’</a></li>
<li><a href="#convert-collection-of-pairs-of-nodes-to-propensity-matrix" id="toc-convert-collection-of-pairs-of-nodes-to-propensity-matrix">Convert
Collection Of Pairs Of Nodes To Propensity Matrix</a></li>
<li><a href="#characterize-individual-contribution-of-single-edges-in-tree-structures" id="toc-characterize-individual-contribution-of-single-edges-in-tree-structures">Characterize
Individual Contribution Of Single Edges In Tree-Structures</a></li>
<li><a href="#count-same-start--and-end--sites-of-edges-or-fragments" id="toc-count-same-start--and-end--sites-of-edges-or-fragments">Count
Same Start- And End- Sites Of Edges (Or Fragments)</a></li>
</ul></li>
<li><a href="#SupportForGraphicalOutput" id="toc-SupportForGraphicalOutput">Support for Graphical Output</a>
<ul>
<li><a href="#convenient-paste-collapse" id="toc-convenient-paste-collapse">Convenient Paste-Collapse</a></li>
<li><a href="#transform-numeric-values-to-color-gradient" id="toc-transform-numeric-values-to-color-gradient">Transform Numeric
Values to Color-Gradient</a></li>
<li><a href="#assign-new-transparency-to-given-colors" id="toc-assign-new-transparency-to-given-colors">Assign New Transparency
To Given Colors</a></li>
<li><a href="#print-matrix-content-as-plot" id="toc-print-matrix-content-as-plot">Print Matrix-Content As
Plot</a></li>
</ul></li>
<li><a href="#OtherConvenienceFunctions" id="toc-OtherConvenienceFunctions">Other Convenience Functions</a>
<ul>
<li><a href="#writing-compact-dates-more-options" id="toc-writing-compact-dates-more-options">Writing Compact Dates (more
options …)</a></li>
</ul></li>
<li><a href="#session-info" id="toc-session-info">Session-Info</a></li>
</ul>
</div>

<div id="introduction" class="section level2">
<h2>Introduction</h2>
<p>This package contains a collection of various (low-level) tools which
may be of general interest. These functions were accumulated over a
number of years of data-wrangling when treating high-throughput data
from biomedical applications. Besides, these functions are further
used/integrated in more specialized functions dedicated to specific
applications in the packages <a href="https://CRAN.R-project.org/package=wrProteo">wrProteo</a>, <a href="https://CRAN.R-project.org/package=wrGraph">wrGraph</a> or <a href="https://CRAN.R-project.org/package=wrTopDownFrag">wrTopDownFrag</a>.
All these packages are available on <a href="https://cran.r-project.org/">CRAN</a>.</p>
<p>If you are not familiar with <a href="https://www.r-project.org/">R</a> you may find many introductory
documents on the official R-site in <a href="https://cran.r-project.org/other-docs.html">contributed
documents</a> or under <a href="https://cran.r-project.org/manuals.html">Documentation/Manuals</a>.
Of course, numerous other documents/sites with tutorials and courses
exist, too.</p>
<div id="dependencies-and-compilation" class="section level3">
<h3>Dependencies and Compilation</h3>
<p>One of the aims was to write a package easy to install, with low
system requirements and few obligatory dependencies.<br />
All code is written in pure R and does not need any special compilers.
The number of obligatory dependencies was kept to a minumum.</p>
<p>Most of additional packages used in some of the functions were
declared as ‘suggested’ (ie not obligatory), to allow installation of
<em>wrMisc</em> even if some these additional packages can’t be
installed/compiled by the user’s instance. When a feature/function of
one of the ‘suggested’ packages is about to be used, its
presence/installation will be checked and, only if found as missing, the
user will be prompted a message inviting to install specific package(s)
before using these specific functions. This helps to avoid not being
able installing this package at all if some dependencies may fail to get
installed themselves.</p>
</div>
<div id="installation-and-loading" class="section level3">
<h3>Installation And Loading</h3>
<p>To get started, we need to install (if not yet installed) and load
the package “<a href="https://CRAN.R-project.org/package=wrMisc">wrMisc</a>” available
from <a href="https://cran.r-project.org/">CRAN</a>.</p>
<pre class="r"><code>## If not already installed, you&#39;ll have to install the package first.
## This is the basic installation commande in R
install.packages(&quot;wrMisc&quot;)</code></pre>
<p>Since the functions illustrated in this vignette require a number of
the <em>suggested</em> packages, let’s check if they are installed and
add them (via a small function), if not yet installed.</p>
<pre class="r"><code>packages &lt;- c(&quot;knitr&quot;, &quot;rmarkdown&quot;, &quot;BiocManager&quot;, &quot;kableExtra&quot;, &quot;boot&quot;, &quot;data.tree&quot;, &quot;data.table&quot;, 
  &quot;fdrtool&quot;, &quot;RColorBrewer&quot;, &quot;Rcpp&quot;, &quot;wrMisc&quot;, &quot;wrGraph&quot;, &quot;wrProteo&quot;)
checkInstallPkg &lt;- function(pkg) {       # install function
  if(!requireNamespace(pkg, quietly=TRUE)) install.packages(pkg) }

## install if not yet present
sapply(packages, checkInstallPkg)</code></pre>
<p>Finally, this package also uses the Bioconductor package <a href="https://bioconductor.org/packages/release/bioc/html/limma.html">limma</a>
which has to be installed differently (see also help on <a href="https://bioconductor.org">Bioconductor</a>):</p>
<pre class="r"><code>## Installation of limma 
BiocManager::install(&quot;limma&quot;)</code></pre>
<p>This vignette is also accessible from R command-line or on CRAN at <a href="https://CRAN.R-project.org/package=wrMisc">wrMisc</a>:</p>
<pre class="r"><code>## Now you can open this vignette out of R:
vignette(&quot;wrMiscVignette1&quot;, package=&quot;wrMisc&quot;)</code></pre>
<p>Before using the functions of this package, we actually need to load
the package first (best on a fresh R-session):</p>
<pre class="r"><code>library(&quot;wrMisc&quot;)
library(&quot;knitr&quot;)

## This is &#39;wrMisc&#39; version number :
packageVersion(&quot;wrMisc&quot;)</code></pre>
<pre><code>## [1] &#39;1.15.4&#39;</code></pre>
</div>
</div>
<div id="speed-optimized-functions-in-the-package-wrmisc" class="section level2">
<h2>Speed Optimized Functions In The Package wrMisc</h2>
<p>In high-throughput experiments in biology (like transcriptomics,
proteomics etc…) many different features get measured a number if times
(different samples like patients or evolution of a disease). The
resulting data typically contain many (independent) rows (eg &gt;1000
different genes or proteins who’s abundance was measured) and much fewer
columns that may get further organized in groups of replicates. As R is
a versatile language, multiple options exist for assessing the global
characteristics of such data, some are more efficient on a computational
point of view. In order to allow fast treatment of very large data-sets
some tools have been re-designed for optimal performance.</p>
<div id="assessing-basic-information-about-variability-for-matrix" class="section level3">
<h3>Assessing Basic Information About Variability (for matrix)</h3>
<p>Many measurement techniques applied in high throughput manner suffer
from precision. This means, the same measurements taken twice in a row
(ie repeated on the same subject) will very likely not give an identical
result. For this reason it is common practice to make replicate
measurements to i) estimate mean (ie representative) values and ii)
asses the factors contributing to the variablity observed. Briefly,
technical replicates represent the case where multiple read-outs of the
very same sample are generated and the resulting variability is
associated to technical issues during the process of taking measures.
Biological replicates represent independant samples and reflect
therefore the varibility a given parameter may have in a certain
population of individuals. With the tools presented here, both technical
and biological replicates can be dealt with. In several cases the
interpretation of the resulting numbers should consider the experimental
setup, though.</p>
<p>Let’s make a simple matrix as toy data:</p>
<pre class="r"><code>grp1 &lt;- rep(LETTERS[1:3], c(3,4,3))
sampNa1 &lt;- paste0(grp1, c(1:3,1:4,1:3))
set.seed(2016); dat1 &lt;- matrix(round(c(runif(50000) +rep(1:1000,50)),3), 
  ncol=10, dimnames=list(NULL,sampNa1))
dim(dat1)</code></pre>
<pre><code>## [1] 5000   10</code></pre>
<pre class="r"><code>head(dat1)</code></pre>
<pre><code>##         A1    A2    A3    B1    B2    B3    B4    C1    C2    C3
## [1,] 1.180 1.640 1.199 1.118 1.425 1.745 1.253 1.554 1.303 1.856
## [2,] 2.143 2.237 2.730 2.693 2.603 2.293 2.542 2.452 2.148 2.776
## [3,] 3.842 3.155 3.191 3.520 3.686 3.408 3.409 3.871 3.345 3.588
## [4,] 4.134 4.394 4.982 4.320 4.380 4.888 4.965 4.462 4.250 4.647
## [5,] 5.478 5.472 5.488 5.570 5.626 5.765 5.551 5.016 5.659 5.139
## [6,] 6.121 6.294 6.718 6.890 6.999 6.316 6.542 6.119 6.763 6.487</code></pre>
<p>Now lets estimate the standard deviation <em>(sd)</em> for every
row:</p>
<pre class="r"><code>head(rowSds(dat1))</code></pre>
<pre><code>## [1] 0.2583693 0.2426026 0.2477899 0.3089102 0.2307722 0.3124493</code></pre>
<pre class="r"><code>system.time(sd1 &lt;- rowSds(dat1))</code></pre>
<pre><code>##    user  system elapsed 
##    0.00    0.00    0.01</code></pre>
<pre class="r"><code>system.time(sd2 &lt;- apply(dat1, 1, sd))</code></pre>
<pre><code>##    user  system elapsed 
##    0.03    0.00    0.03</code></pre>
<p>On most systems the equivalent calculation using <em>apply()</em>
will run much slower compared to <code>rowSds</code>.</p>
<p>Note, there is a minor issue with rounding :</p>
<pre class="r"><code>table(round(sd1, 13)==round(sd2, 13))</code></pre>
<pre><code>## 
## FALSE  TRUE 
##     1  4999</code></pre>
<p>Similarly we can easily calculate the CV (coefficient of variation,
ie sd / mean, see also <a href="https://en.wikipedia.org/wiki/Coefficient_of_variation">CV</a>)
for every row using <code>rowCVs</code> :</p>
<pre class="r"><code>system.time(cv1 &lt;- rowCVs(dat1))</code></pre>
<pre><code>##    user  system elapsed 
##    0.01    0.00    0.00</code></pre>
<pre class="r"><code>system.time(cv2 &lt;- apply(dat1, 1, sd) / rowMeans(dat1))</code></pre>
<pre><code>##    user  system elapsed 
##    0.04    0.00    0.05</code></pre>
<pre class="r"><code># typically the calculation using rowCVs is much faster
head(cv1)</code></pre>
<pre><code>## [1] 0.18101959 0.09855083 0.07076678 0.06800894 0.04213940 0.04788568</code></pre>
<pre class="r"><code># results from the &#39;conventional&#39; way
head(cv2)</code></pre>
<pre><code>## [1] 0.18101959 0.09855083 0.07076678 0.06800894 0.04213940 0.04788568</code></pre>
<p>Note, these calculations will be very efficient as long as the number
of rows is much higher (&gt;&gt;) than the number of columns.</p>
</div>
<div id="data-organized-in-sub-groups-as-sets-of-columns" class="section level3">
<h3>Data Organized In (Sub-)Groups As Sets Of Columns</h3>
<p>Now, let’s assume our data is contains 3 initial samples measured as
several replicates (already defined in <em>grp1</em>). Similarly, we can
also calculate the sd or CV for each line while splitting into groups of
replicates (functions <code>rowGrpMeans</code>, <code>rowGrpSds</code>
and <code>rowGrpCV</code>):</p>
<pre class="r"><code># we already defined the grouping :
grp1</code></pre>
<pre><code>##  [1] &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;B&quot; &quot;B&quot; &quot;B&quot; &quot;B&quot; &quot;C&quot; &quot;C&quot; &quot;C&quot;</code></pre>
<pre class="r"><code>## the mean for each group and row
system.time(mean1Gr &lt;- rowGrpMeans(dat1, grp1))</code></pre>
<pre><code>##    user  system elapsed 
##       0       0       0</code></pre>
<pre class="r"><code>## Now the sd for each row and group
system.time(sd1Gr &lt;- rowGrpSds(dat1, grp1))</code></pre>
<pre><code>##    user  system elapsed 
##       0       0       0</code></pre>
<pre class="r"><code># will give us a matrix with the sd for each group &amp; line 
head(sd1Gr)</code></pre>
<pre><code>##                A          B         C
## [1,] 0.260269732 0.27074758 0.2768917
## [2,] 0.315291928 0.17144557 0.3140531
## [3,] 0.386666523 0.13115989 0.2632534
## [4,] 0.434443706 0.33521970 0.1986530
## [5,] 0.008082904 0.09672297 0.3413156
## [6,] 0.307168249 0.31475851 0.3230934</code></pre>
<pre class="r"><code># Let&#39;s check the results of the first line :
sd1Gr[1,] == c(sd(dat1[1,1:3]), sd(dat1[1,4:7]), sd(dat1[1,8:10]))</code></pre>
<pre><code>##    A    B    C 
## TRUE TRUE TRUE</code></pre>
<pre class="r"><code># The CV :
system.time(cv1Gr &lt;- rowGrpCV(dat1, grp1))</code></pre>
<pre><code>##    user  system elapsed 
##       0       0       0</code></pre>
<pre class="r"><code>head(cv1Gr)</code></pre>
<pre><code>##                A          B          C
## [1,] 0.194279471 0.19545033 0.17625186
## [2,] 0.133034569 0.06769147 0.12773308
## [3,] 0.113859400 0.03741279 0.07309886
## [4,] 0.096471585 0.07227288 0.04461104
## [5,] 0.001475162 0.01718603 0.06474939
## [6,] 0.048163108 0.04707197 0.05004286</code></pre>
<div id="counting-number-of-nas-per-row-and-group-of-columns" class="section level4">
<h4>Counting Number Of NAs Per Row And Group Of Columns</h4>
<p>Some data, like with quantitative proteomics measures, may contain an
elevated number of <em>NAs</em> (see also the package <a href="https://CRAN.R-project.org/package=wrProteo">wrProteo</a> for
further options for dealing with such data). Furthermore, many other
packages on CRAN and Bioconductor cover this topic, see also the <a href="https://CRAN.R-project.org/view=MissingData">missing data
task-view</a> on CRAN. Similar as above there is an easy way to count
the number of <em>NAs</em> to get an overview how NAs are
distributed.</p>
<p>Let’s assume we have measures from 3 groups/samples with 4 replicates
each :</p>
<pre class="r"><code>mat2 &lt;- c(22.2, 22.5, 22.2, 22.2, 21.5, 22.0, 22.1, 21.7, 21.5, 22, 22.2, 22.7,
   NA, NA, NA, NA, NA, NA, NA, 21.2,   NA, NA, NA, NA,
   NA, 22.6, 23.2, 23.2,  22.4, 22.8, 22.8, NA,  23.3, 23.2, NA, 23.7,
   NA, 23.0, 23.1, 23.0,  23.2, 23.2, NA, 23.3,  NA, NA, 23.3, 23.8)
mat2 &lt;- matrix(mat2, ncol=12, byrow=TRUE)
## The definition of the groups (ie replicates)
gr4 &lt;- gl(3, 4, labels=LETTERS[1:3])</code></pre>
<p>Now we can easily count the number of NAs per row and set of
replicates.</p>
<pre class="r"><code>rowGrpNA(mat2,gr4)</code></pre>
<pre><code>##      A B C
## [1,] 0 0 0
## [2,] 4 3 4
## [3,] 1 1 1
## [4,] 1 1 2</code></pre>
</div>
</div>
<div id="fast-na-omit-for-very-large-objects" class="section level3">
<h3>Fast NA-omit For Very Large Objects</h3>
<p>The function <em>na.omit()</em> from the package <em>stats</em> also
keeps a trace of all omitted instances. This can be penalizing in terms
of memory usage when handling very large vectors with a high content of
NAs (eg &gt;10000 NAs). If you don’t need to document precisely which
elements got eliminated, the function <code>naOmit()</code> may offer
smoother functioning for very large objects.</p>
<pre class="r"><code>aA &lt;- c(11:13,NA,10,NA)
 
str(naOmit(aA))</code></pre>
<pre><code>##  num [1:4] 11 12 13 10</code></pre>
<pre class="r"><code># the &#39;classical&#39; na.omit also stores which elements were NA
str(na.omit(aA))</code></pre>
<pre><code>##  num [1:4] 11 12 13 10
##  - attr(*, &quot;na.action&quot;)= &#39;omit&#39; int [1:2] 4 6</code></pre>
</div>
<div id="minimum-distancedifference-between-values" class="section level3">
<h3>Minimum Distance/Difference Between Values</h3>
<p>If you need to find the closest neighbour(s) of a numeric vector, the
function <code>minDiff()</code> will tell you the distance (“dif”,“ppm”
or “ratio”) and index (“best”) of the closest neighbour. In case of
multiple shortest distances the index if the first one is reported, and
the column “nbest” will display a value of &gt;1.</p>
<pre class="r"><code>set.seed(2017); aa &lt;- 10 *c(0.1 +round(runif(20),2), 0.53, 0.53)
head(aa)</code></pre>
<pre><code>## [1] 10.2  6.4  5.7  3.9  8.7  8.7</code></pre>
<pre class="r"><code>minDiff(aa,ppm=FALSE)</code></pre>
<pre><code>##       index value  dif   rat ncur nbest best
##  [1,]     1  10.2 -0.2 0.981    1     1   19
##  [2,]     2   6.4  0.4 1.070    1     1   15
##  [3,]     3   5.7  0.3 0.950    2     1   15
##  [4,]     4   3.9  0.2 1.050    1     1   10
##  [5,]     5   8.7  0.5 1.060    2     1   18
##  [6,]     6   8.7  0.5 1.060    2     1   18
##  [7,]     7   1.4  0.1 1.080    1     1   13
##  [8,]     8   5.3  0.3 1.060    4     1   17
##  [9,]     9   5.7  0.3 0.950    2     1   15
## [10,]    10   3.7 -0.2 0.949    1     1    4
## [11,]    11   7.7 -0.5 0.939    1     1   18
## [12,]    12   1.0 -0.3 0.769    1     1   13
## [13,]    13   1.3 -0.1 0.929    1     1    7
## [14,]    14   5.3  0.3 1.060    4     1   17
## [15,]    15   6.0  0.3 1.050    1     2    9
## [16,]    16   4.9 -0.1 0.980    1     1   17
## [17,]    17   5.0  0.1 1.020    1     1   16
## [18,]    18   8.2  0.5 1.060    1     1   11
## [19,]    19  10.4  0.2 1.020    1     1    1
## [20,]    20   9.3  0.6 1.070    1     2    6
## [21,]    21   5.3  0.3 1.060    4     1   17
## [22,]    22   5.3  0.3 1.060    4     1   17</code></pre>
<p>When you look at the first line, the value of 10.2 has one single
closest value which is 10.4, which is located in line number 19 (the
column ‘best’ gives the index of the best). Line number 19 points back
to line number 1. You can see, that some elements (like 5.7) occure
multiple times (line no 3 and 9), multiple occurences are counted in the
column <em>ncur</em>. This is why column <em>nbest</em> for line 15
(<em>value</em> =6.0) indicates that it appears twice as closest value
<em>nbest</em>.</p>
</div>
</div>
<div id="WorkingWithLists" class="section level2">
<h2>Working With Lists (And Lists Of Lists)</h2>
<div id="partial-unlist" class="section level3">
<h3>Partial unlist</h3>
<p>When input from different places gets collected and combined into a
list, this may give a collection of different types of data. The
function <code>partUnlist()</code> will to preserve multi-column
elements as they are (and just bring down one level):</p>
<pre class="r"><code>bb &lt;- list(fa=gl(2,2), ve=31:33, L2=matrix(21:28,ncol=2), li=list(li1=11:14,li2=data.frame(41:44)))
partUnlist(bb)</code></pre>
<pre><code>## $fa
## [1] 1 1 2 2
## Levels: 1 2
## 
## $ve
## [1] 31 32 33
## 
## $L2
##      [,1] [,2]
## [1,]   21   25
## [2,]   22   26
## [3,]   23   27
## [4,]   24   28
## 
## $li1
## [1] 11 12 13 14
## 
## $li2
##   X41.44
## 1     41
## 2     42
## 3     43
## 4     44</code></pre>
<pre class="r"><code>partUnlist(lapply(bb,.asDF2))</code></pre>
<pre><code>## partUnlist : Input is not list of lists, nothing to do</code></pre>
<pre><code>## $fa
##   as.character(z)
## 1               1
## 2               1
## 3               2
## 4               2
## 
## $ve
##    z
## 1 31
## 2 32
## 3 33
## 
## $L2
##   V1 V2
## 1 21 25
## 2 22 26
## 3 23 27
## 4 24 28
## 
## $li
##   li1 X41.44
## 1  11     41
## 2  12     42
## 3  13     43
## 4  14     44</code></pre>
<p>This won’t be possible using <em>unlist()</em>.</p>
<pre class="r"><code>head(unlist(bb, recursive=FALSE))</code></pre>
<pre><code>## $fa1
## [1] 1
## 
## $fa2
## [1] 1
## 
## $fa3
## [1] 2
## 
## $fa4
## [1] 2
## 
## $ve1
## [1] 31
## 
## $ve2
## [1] 32</code></pre>
<p>To uniform such data to obtain a list with one column only for each
list-element, the function <code>asSepList()</code> provides help :</p>
<pre class="r"><code>bb &lt;- list(fa=gl(2,2), ve=31:33, L2=matrix(21:28,ncol=2), li=list(li1=11:14,li2=data.frame(41:44)))
asSepList(bb)</code></pre>
<pre><code>## $fa
## [1] 1 1 2 2
## Levels: 1 2
## 
## $L2_1
## [1] 21 22 23 24
## 
## $L2_2
## [1] 25 26 27 28
## 
## $li1
## [1] 11 12 13 14
## 
## $li2
## [1] 41 42 43 44</code></pre>
</div>
<div id="appendingcombining-lists" class="section level3">
<h3>Appending/Combining Lists</h3>
<p>Separate lists may be combined using the <em>append()</em> command,
which also allows treating simple vectors.</p>
<pre class="r"><code>li1 &lt;- list(a=1, b=2, c=3)
li2 &lt;- list(A=11, b=2, C=13)
append(li1, li2)</code></pre>
<pre><code>## $a
## [1] 1
## 
## $b
## [1] 2
## 
## $c
## [1] 3
## 
## $A
## [1] 11
## 
## $b
## [1] 2
## 
## $C
## [1] 13</code></pre>
<p>However, this way there is no checking if some of the list-elements
are present in both lists and thus will appear twice. The function
<code>appendNR()</code> allows to checking if some list-elements will
appear twice, and thus avoid such duplicate entries.</p>
<pre class="r"><code>appendNR(li1, li2)</code></pre>
<pre><code>## appendNR :  adding 2 new names/elements (1 already present)</code></pre>
<pre><code>## $a
## [1] 1
## 
## $b
## [1] 2
## 
## $c
## [1] 3
## 
## $A
## [1] 11
## 
## $C
## [1] 13</code></pre>
</div>
<div id="rbind-on-lists" class="section level3">
<h3>rbind On Lists</h3>
<p>When a matrix (or data.frame) gets split into a list, like in the
example using <em>by()</em>, as a reverse-function such lists can get
joined using <code>lrbind()</code> in an <em>rbind</em>-like
fashion.</p>
<pre class="r"><code>dat2 &lt;- matrix(11:34, ncol=3, dimnames=list(letters[1:8], colnames=LETTERS[1:3]))
lst2 &lt;- by(dat2, rep(1:3,c(3,2,3)), as.matrix)
lst2</code></pre>
<pre><code>## INDICES: 1
##    A  B  C
## a 11 19 27
## b 12 20 28
## c 13 21 29
## ------------------------------------------------------------ 
## INDICES: 2
##    A  B  C
## d 14 22 30
## e 15 23 31
## ------------------------------------------------------------ 
## INDICES: 3
##    A  B  C
## f 16 24 32
## g 17 25 33
## h 18 26 34</code></pre>
<pre class="r"><code># join list-elements (back) into single matrix
lrbind(lst2)</code></pre>
<pre><code>##    A  B  C
## a 11 19 27
## b 12 20 28
## c 13 21 29
## d 14 22 30
## e 15 23 31
## f 16 24 32
## g 17 25 33
## h 18 26 34</code></pre>
</div>
<div id="merge-multiple-matrices-from-list" class="section level3">
<h3>Merge Multiple Matrices From List</h3>
<p>When combining different datasets the function
<code>mergeMatrixList()</code> allows merging multiple matrices (or
data.frames) into a single matrix. Two types of mode of operation are
available : i) Returning only the common/shared elements (as defined by
the rownames), this is default <em>mode=‘intersect’</em> ; alternatively
one may ii) fuse/merge all matrices together without any loss of data
(using <em>mode=‘union’</em>, additional _NA_s may appear when a given
rowname is absent in one of the input matrices).</p>
<p>Furthermore, one may specifically select which columns should be used
for fusing using the argument <em>useColumn</em>.</p>
<pre class="r"><code>mat1 &lt;- matrix(11:18, ncol=2, dimnames=list(letters[3:6],LETTERS[1:2]))
mat2 &lt;- matrix(21:28, ncol=2, dimnames=list(letters[2:5],LETTERS[3:4]))
mat3 &lt;- matrix(31:38, ncol=2, dimnames=list(letters[c(1,3:4,3)],LETTERS[4:5]))
#
mergeMatrixList(list(mat1, mat2), useColumn=&quot;all&quot;)</code></pre>
<pre><code>##    A  B  C  D
## c 11 15 22 26
## d 12 16 23 27
## e 13 17 24 28</code></pre>
<pre class="r"><code># with custom names for the individual matrices
mergeMatrixList(list(m1=mat1, m2=mat2, mat3), mode=&quot;union&quot;, useColumn=2)</code></pre>
<pre><code>##   m1.B m2.D list_3.E
## a   NA   NA       35
## b   NA   25       NA
## c   15   26       38
## d   16   27       37
## e   17   28       NA
## f   18   NA       NA</code></pre>
<p>Similarly, separate entries may be merged using
<code>mergeMatrices()</code> :</p>
<pre class="r"><code>mergeMatrices(mat1, mat2)</code></pre>
<pre><code>##    A   
## c 11 22
## d 12 23
## e 13 24</code></pre>
<pre class="r"><code>mergeMatrices(mat1, mat2, mat3, mode=&quot;union&quot;, useColumn=2)</code></pre>
<pre><code>##   mat1.B mat2.D mat3.E
## a     NA     NA     35
## b     NA     25     NA
## c     15     26     38
## d     16     27     37
## e     17     28     NA
## f     18     NA     NA</code></pre>
<pre class="r"><code>## custom names for matrix-origin
mergeMatrices(m1=mat1, m2=mat2, mat3, mode=&quot;union&quot;, useColumn=2)</code></pre>
<pre><code>##   m1.B m2.D mat3.E
## a   NA   NA     35
## b   NA   25     NA
## c   15   26     38
## d   16   27     37
## e   17   28     NA
## f   18   NA     NA</code></pre>
<pre class="r"><code>## flexible/custom selection of columns
mergeMatrices(m1=mat1, m2=mat2, mat3, mode=&quot;union&quot;, useColumn=list(1,1:2,2))</code></pre>
<pre><code>##   m1.A m2.C m2.D mat3.E
## a   NA   NA   NA     35
## b   NA   21   25     NA
## c   11   22   26     38
## d   12   23   27     37
## e   13   24   28     NA
## f   14   NA   NA     NA</code></pre>
</div>
<div id="fuse-content-of-list-elements-with-redundant-duplicated-names" class="section level3">
<h3>Fuse Content Of List-Elements With Redundant (Duplicated) Names</h3>
<p>When list-elements have the same name, their content (of named
numeric or character vectors) may get fused using
<code>fuseCommonListElem()</code> according to the names of the
list-elements :</p>
<pre class="r"><code>val1 &lt;- 10 +1:26
names(val1) &lt;- letters
(lst1 &lt;- list(c=val1[3:6], a=val1[1:3], b=val1[2:3] ,a=val1[12], c=val1[13]))</code></pre>
<pre><code>## $c
##  c  d  e  f 
## 13 14 15 16 
## 
## $a
##  a  b  c 
## 11 12 13 
## 
## $b
##  b  c 
## 12 13 
## 
## $a
##  l 
## 22 
## 
## $c
##  m 
## 23</code></pre>
<pre class="r"><code>## here the names &#39;a&#39; and &#39;c&#39; appear twice :
names(lst1)</code></pre>
<pre><code>## [1] &quot;c&quot; &quot;a&quot; &quot;b&quot; &quot;a&quot; &quot;c&quot;</code></pre>
<pre class="r"><code>## now, let&#39;s fuse all &#39;a&#39; and &#39;c&#39;
fuseCommonListElem(lst1)</code></pre>
<pre><code>## $c
##  c  d  e  f  m 
## 13 14 15 16 23 
## 
## $a
##  a  b  c  l 
## 11 12 13 22 
## 
## $b
##  b  c 
## 12 13</code></pre>
</div>
<div id="filtering-lines-andor-columns-for-all-list-elements-of-same-size" class="section level3">
<h3>Filtering Lines And/Or Columns For All List-Elements Of Same
Size</h3>
<p>In a number of cases the information in various list-elements is
somehow related. Eg, in S3-objects produced by <a href="https://bioconductor.org/packages/release/bioc/html/limma.html">limma</a>,
or data produced using <a href="https://CRAN.R-project.org/package=wrProteo">wrProteo</a> several
instances of matrix or data.frame refer to data that are related. Some
matrixes may conatain abundance data (or weights, etc) while another
matrix or data.frame may contain the annotation information related to
each line of the abundance data. So if one wants to filter the data, ie
remove some lines, this should be done in the same way with all related
list-elements. This way one may maintain a conventient 1:1 matching of
lines.</p>
<p>The function <code>filterLiColDeList()</code> searches if other
list-elements have suitable dimensions and will then run the same
filtering as in the ‘target’ list-element. In consequence this can be
used with the output of wrProteo to remove simultaneously the same lines
and/or columns.</p>
<pre class="r"><code>lst1 &lt;- list(m1=matrix(11:18, ncol=2), m2=matrix(21:30, ncol=2), indR=31:34,
  m3=matrix(c(21:23,NA,25:27,NA), ncol=2))
filterLiColDeList(lst1, useLines=2:3)</code></pre>
<pre><code>## filterLiColDeList : successfully filtered &#39;m1&#39; and &#39;m3&#39; from 4 to 2 lines</code></pre>
<pre><code>## $m1
##      [,1] [,2]
## [1,]   12   16
## [2,]   13   17
## 
## $m2
##      [,1] [,2]
## [1,]   21   26
## [2,]   22   27
## [3,]   23   28
## [4,]   24   29
## [5,]   25   30
## 
## $indR
## [1] 31 32 33 34
## 
## $m3
##      [,1] [,2]
## [1,]   22   26
## [2,]   23   27</code></pre>
<pre class="r"><code>filterLiColDeList(lst1, useLines=&quot;allNA&quot;, ref=3)</code></pre>
<pre><code>## filterLiColDeList : It appears lst[[ref]] is not matrix (or data.frame) ! Trying to reformat ..</code></pre>
<pre><code>## filterLiColDeList : &#39;useLines&#39; seems empty, nothing to do ...</code></pre>
<pre><code>## $m1
##      [,1] [,2]
## [1,]   11   15
## [2,]   12   16
## [3,]   13   17
## [4,]   14   18
## 
## $m2
##      [,1] [,2]
## [1,]   21   26
## [2,]   22   27
## [3,]   23   28
## [4,]   24   29
## [5,]   25   30
## 
## $indR
##      [,1]
## [1,]   31
## [2,]   32
## [3,]   33
## [4,]   34
## 
## $m3
##      [,1] [,2]
## [1,]   21   25
## [2,]   22   26
## [3,]   23   27
## [4,]   NA   NA</code></pre>
</div>
<div id="replacements-in-list" class="section level3">
<h3>Replacements In List</h3>
<p>The function <code>listBatchReplace()</code> works similar to
<em>sub()</em> and allows to search &amp; replace exact matches to a
character string along all elements of a list.</p>
<pre class="r"><code>(lst1 &lt;- list(aa=1:4, bb=c(&quot;abc&quot;,&quot;efg&quot;,&quot;abhh&quot;,&quot;effge&quot;), cc=c(&quot;abdc&quot;,&quot;efg&quot;,&quot;efgh&quot;)))</code></pre>
<pre><code>## $aa
## [1] 1 2 3 4
## 
## $bb
## [1] &quot;abc&quot;   &quot;efg&quot;   &quot;abhh&quot;  &quot;effge&quot;
## 
## $cc
## [1] &quot;abdc&quot; &quot;efg&quot;  &quot;efgh&quot;</code></pre>
<pre class="r"><code>listBatchReplace(lst1, search=&quot;efg&quot;, repl=&quot;EFG&quot;, silent=FALSE)</code></pre>
<pre><code>## $aa
## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot;
## 
## $bb
## [1] &quot;abc&quot;   &quot;EFG&quot;   &quot;abhh&quot;  &quot;effge&quot;
## 
## $cc
## [1] &quot;abdc&quot; &quot;EFG&quot;  &quot;efgh&quot;</code></pre>
</div>
<div id="organize-values-into-list-and-sort-by-names" class="section level3">
<h3>Organize Values Into list and Sort By Names</h3>
<p>Named numeric or character vectors can be organized into lists using
<code>listGroupsByNames()</code>, based on their names (only the part
before any extensions starting with a point gets considered). Of course,
other separators may be defined using the argument <em>sep</em>.</p>
<pre class="r"><code>ser1 &lt;- 1:7; names(ser1) &lt;- c(&quot;AA&quot;,&quot;BB&quot;,&quot;AA.1&quot;,&quot;CC&quot;,&quot;AA.b&quot;,&quot;BB.e&quot;,&quot;A&quot;)

listGroupsByNames(ser1)</code></pre>
<pre><code>## $AA
##   AA AA.1 AA.b 
##    1    3    5 
## 
## $BB
##   BB BB.e 
##    2    6 
## 
## $CC
## CC 
##  4 
## 
## $A
## A 
## 7</code></pre>
<p>If no names are present, the content of the vector itself will be
used as name :</p>
<pre class="r"><code>listGroupsByNames((1:10)/5)</code></pre>
<pre><code>## listGroupsByNames :  no names found in &#39;x&#39; !!</code></pre>
<pre><code>## $`0`
##   0   0   0   0 
## 0.2 0.4 0.6 0.8 
## 
## $`1`
##   1   1   1   1   1 
## 1.0 1.2 1.4 1.6 1.8 
## 
## $`2`
## 2 
## 2</code></pre>
</div>
<div id="batch-filter-list-elements" class="section level3">
<h3>Batch-filter List-Elements</h3>
<p>In the view of object-oriented programming several methods produce
results integrated into lists or S3-objects (eg <a href="https://bioconductor.org/packages/release/bioc/html/limma.html">limma</a>).
The function <code>filterList()</code> aims facilitating the filtering
of all elements of lists or S3-objects. List-elements with inappropriate
number of lines will be ignored.</p>
<pre class="r"><code>set.seed(2020); dat1 &lt;- round(runif(80),2)
list1 &lt;- list(m1=matrix(dat1[1:40], ncol=8), m2=matrix(dat1[41:80], ncol=8), other=letters[1:8])
rownames(list1$m1) &lt;- rownames(list1$m2) &lt;- paste0(&quot;line&quot;,1:5)
# Note: the list-element list1$other has a length different to that of filt. Thus, it won&#39;t get filtered.
filterList(list1, list1$m1[,1] &gt;0.4)       # filter according to 1st column of $m1 ...</code></pre>
<pre><code>## $m1
##       [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8]
## line1 0.65 0.07 0.76 0.54 0.20 0.17 0.96 0.37
## line3 0.62 0.39 0.83 0.65 0.82 0.75 0.96 0.93
## line4 0.48 0.00 0.42 0.55 0.94 0.45 0.95 0.52
## 
## $m2
##       [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8]
## line1 0.99 0.57 0.58 0.00 0.21 0.61 0.61 0.30
## line3 0.86 0.70 0.90 0.22 0.23 0.58 0.39 0.06
## line4 0.88 0.80 0.52 0.54 0.42 0.65 0.47 0.67
## 
## $other
## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot;</code></pre>
<pre class="r"><code>filterList(list1, list1$m1 &gt;0.4) </code></pre>
<pre><code>## $m1
##       [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8]
## line1 0.65 0.07 0.76 0.54 0.20 0.17 0.96 0.37
## line3 0.62 0.39 0.83 0.65 0.82 0.75 0.96 0.93
## line4 0.48 0.00 0.42 0.55 0.94 0.45 0.95 0.52
## line5 0.14 0.62 0.41 0.27 0.88 0.56 0.00 0.22
## 
## $m2
##       [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8]
## line1 0.99 0.57 0.58 0.00 0.21 0.61 0.61 0.30
## line3 0.86 0.70 0.90 0.22 0.23 0.58 0.39 0.06
## line4 0.88 0.80 0.52 0.54 0.42 0.65 0.47 0.67
## line5 0.62 0.17 0.83 0.49 0.86 0.17 0.53 0.72
## 
## $other
## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot;</code></pre>
</div>
<div id="transform-columns-of-matrix-to-list-of-vectors" class="section level3">
<h3>Transform Columns Of Matrix To List Of Vectors</h3>
<p>At some occasions it may be useful separate columns of a matrix into
separate vectors inside a list. This can be done using
<code>matr2list()</code>:</p>
<pre class="r"><code>(mat1 &lt;- matrix(1:12, ncol=3, dimnames=list(letters[1:4],LETTERS[1:3])))</code></pre>
<pre><code>##   A B  C
## a 1 5  9
## b 2 6 10
## c 3 7 11
## d 4 8 12</code></pre>
<pre class="r"><code>str(matr2list(mat1))</code></pre>
<pre><code>## List of 3
##  $ A: Named num [1:4] 1 2 3 4
##   ..- attr(*, &quot;names&quot;)= chr [1:4] &quot;A.a&quot; &quot;A.b&quot; &quot;A.c&quot; &quot;A.d&quot;
##  $ B: Named num [1:4] 5 6 7 8
##   ..- attr(*, &quot;names&quot;)= chr [1:4] &quot;B.a&quot; &quot;B.b&quot; &quot;B.c&quot; &quot;B.d&quot;
##  $ C: Named num [1:4] 9 10 11 12
##   ..- attr(*, &quot;names&quot;)= chr [1:4] &quot;C.a&quot; &quot;C.b&quot; &quot;C.c&quot; &quot;C.d&quot;</code></pre>
</div>
</div>
<div id="WorkingWithArrays" class="section level2">
<h2>Working With Arrays</h2>
<p>Let’s get stared with a little toy-array:</p>
<pre class="r"><code>(arr1 &lt;- array(c(6:4,4:24), dim=c(4,3,2), dimnames=list(c(LETTERS[1:4]),
  paste(&quot;col&quot;,1:3,sep=&quot;&quot;),c(&quot;ch1&quot;,&quot;ch2&quot;))))</code></pre>
<pre><code>## , , ch1
## 
##   col1 col2 col3
## A    6    5    9
## B    5    6   10
## C    4    7   11
## D    4    8   12
## 
## , , ch2
## 
##   col1 col2 col3
## A   13   17   21
## B   14   18   22
## C   15   19   23
## D   16   20   24</code></pre>
<div id="cv-coefficient-of-variance-with-arrays" class="section level3">
<h3>CV (Coefficient Of Variance) With Arrays</h3>
<p>Now we can obtain the CV (coefficient of variance) by splitting along
3rd dimesion (ie this is equivalent to an <em>apply</em> along the 3rd
dimension) using <code>arrayCV()</code>:</p>
<pre class="r"><code>arrayCV(arr1)</code></pre>
<pre><code>##         ch1       ch2
## A 0.3122499 0.2352941
## B 0.3779645 0.2222222
## C 0.4788934 0.2105263
## D 0.5000000 0.2000000</code></pre>
<pre class="r"><code># this is equivalent to
cbind(rowCVs(arr1[,,1]), rowCVs(arr1[,,2]))</code></pre>
<pre><code>##        [,1]      [,2]
## A 0.3122499 0.2352941
## B 0.3779645 0.2222222
## C 0.4788934 0.2105263
## D 0.5000000 0.2000000</code></pre>
<p>Similarly we can split along any other dimension, eg the 2nd
dimension :</p>
<pre class="r"><code>arrayCV(arr1, byDim=2)</code></pre>
<pre><code>##        col1      col2      col3
## A 0.5210260 0.7713892 0.5656854
## B 0.6698906 0.7071068 0.5303301
## C 0.8187552 0.6527140 0.4991342
## D 0.8485281 0.6060915 0.4714045</code></pre>
</div>
<div id="slice-3-dim-array-in-list-of-matrixes-or-arrays" class="section level3">
<h3>Slice 3-dim Array In List Of Matrixes (Or Arrays)</h3>
<p>This procedure is similar to (re-)organizing an initial array into
clusters, here we split along a user-defined factor/vector. If a
clustering-algorithm produces the cluster assignments, this function can
be used to organize the input data accordingly using
<code>cutArrayInCluLike()</code>.</p>
<pre class="r"><code>cutArrayInCluLike(arr1, cluOrg=c(2,1,2,1))</code></pre>
<pre><code>## $`2`
## , , ch1
## 
##   col1 col2 col3
## A    6    5    9
## C    4    7   11
## 
## , , ch2
## 
##   col1 col2 col3
## A   13   17   21
## C   15   19   23
## 
## 
## $`1`
## , , ch1
## 
##   col1 col2 col3
## B    5    6   10
## D    4    8   12
## 
## , , ch2
## 
##   col1 col2 col3
## B   14   18   22
## D   16   20   24</code></pre>
<p>Let’s cut by filtering along the 3rd dimension for all lines where
column ‘col2’ is &gt;7, and then display only the content of columns
‘col1’ and ‘col2’ (using <code>filt3dimArr()</code>):</p>
<pre class="r"><code>filt3dimArr(arr1, displCrit=c(&quot;col1&quot;,&quot;col2&quot;), filtCrit=&quot;col2&quot;, filtVal=7, filtTy=&quot;&gt;&quot;)</code></pre>
<pre><code>## [[1]]
## col1 col2 
##    4    8 
## 
## [[2]]
##   col1 col2
## A   13   17
## B   14   18
## C   15   19
## D   16   20</code></pre>
</div>
</div>
<div id="WorkingWithRedundantData" class="section level2">
<h2>Working With Redundant Data</h2>
<p><span class="math inline">\(_Semantics_\)</span> : Please note, that
there are two ways of interpreting the term ‘<strong>unique</strong>’
:</p>
<ul>
<li><p>In regular understanding one describes this way an event which
occurs only once, and thus does not occur/happen anywhere else.</p></li>
<li><p>The command <code>unique()</code> will eliminate redundant
entries to obtain a shorter ‘unique’ output vector, ie in the resultant
vector all values/content (values) occur only once. However, from the
result of <em>unique()</em> you cannot tell any more which ones were not
unique initially !</p></li>
</ul>
<p>In some applications (eg proteomics) initial identifiers (IDs) may
occur multiple times in the data and we frequently need to identify
events/values that occur only once, as the first meaning of
‘<em>unique</em>’. This package provides (additional) functions to
easily distinguish values occurring just once (ie <em>unique</em>) from
those occurring multiple times. Furthermore, there are functions to
rename/remove/combine replicated elements, eg
<code>correctToUnique()</code> or <code>nonAmbiguousNum()</code>, so
that no elements or lines of data get lost.</p>
<div id="identify-what-is-repeated-and-where-repeated-do-occur" class="section level3">
<h3>Identify What Is Repeated (and Where Repeated Do Occur)</h3>
<pre class="r"><code>## some text toy data
tr &lt;- c(&quot;li0&quot;,&quot;n&quot;,NA,NA, rep(c(&quot;li2&quot;,&quot;li3&quot;),2), rep(&quot;n&quot;,4))</code></pre>
<p>The function <em>table()</em> (from the package <em>base</em>) is
very useful get some insights when working with smaller objects, but may
be slow to handle very large objects. As mentioned, <em>unique()</em>
will make everything unique, and afterwards you won’t know any more who
was unique in the first place ! The function <code>duplicated()</code>
(also from package base) helps us getting the information who is
repeated.</p>
<pre class="r"><code>table(tr)</code></pre>
<pre><code>## tr
## li0 li2 li3   n 
##   1   2   2   5</code></pre>
<pre class="r"><code>unique(tr) </code></pre>
<pre><code>## [1] &quot;li0&quot; &quot;n&quot;   NA    &quot;li2&quot; &quot;li3&quot;</code></pre>
<pre class="r"><code>duplicated(tr, fromLast=FALSE)</code></pre>
<pre><code>##  [1] FALSE FALSE FALSE  TRUE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE</code></pre>
<pre class="r"><code>aa &lt;- c(11:16,NA,14:12,NA,14)
names(aa) &lt;- letters[1:length(aa)]
aa</code></pre>
<pre><code>##  a  b  c  d  e  f  g  h  i  j  k  l 
## 11 12 13 14 15 16 NA 14 13 12 NA 14</code></pre>
<p><code>findRepeated()</code> (from this package) will return the
position/index (and content/value) of repeated elements. However, the
output in form of a list is not very convenient to the human reader.</p>
<pre class="r"><code>findRepeated(aa) </code></pre>
<pre><code>## $`12`
## [1]  2 10
## 
## $`13`
## [1] 3 9
## 
## $`14`
## [1]  4  8 12</code></pre>
<p><code>firstOfRepeated()</code> tells the index of the first instance
of repeated elements, which elements you need to make the vector
‘unique’, and which elements get stripped off when making unique. Please
note, that <em>NA</em> (no matter if they occure once or more times) are
automatically in the part suggested to be removed.</p>
<pre class="r"><code>firstOfRepeated(aa)</code></pre>
<pre><code>## $indRepeated
## 12 13 14 
##  2  3  4 
## 
## $indUniq
## a b c d e f 
## 1 2 3 4 5 6 
## 
## $indRedund
##  g  h  i  j  k  l 
##  7  8  9 10 11 12</code></pre>
<pre class="r"><code>aa[firstOfRepeated(aa)$indUniq]          # only unique with their names</code></pre>
<pre><code>##  a  b  c  d  e  f 
## 11 12 13 14 15 16</code></pre>
<pre class="r"><code>unique(aa)                               # unique() does not return any names !</code></pre>
<pre><code>## [1] 11 12 13 14 15 16 NA</code></pre>
</div>
<div id="correct-vector-to-unique-while-maintaining-the-original-vector-length" class="section level3">
<h3>Correct Vector To Unique (While Maintaining The Original Vector
Length)</h3>
<p>If necessary, a counter can be added to non-unique entries, thus no
individual values get eliminated and the length and order of the
resultant object maintains the same using
<code>correctToUnique()</code>.</p>
<p>This is of importance when assigning rownames to a data.frame :
Assigning redundant values/text as rownames of a data.frame will result
in an error !</p>
<pre class="r"><code>correctToUnique(aa)</code></pre>
<pre><code>##      a      b      c      d      e      f      g      h      i      j      k 
##   &quot;11&quot; &quot;12_1&quot; &quot;13_1&quot; &quot;14_1&quot;   &quot;15&quot;   &quot;16&quot; &quot;NA_1&quot; &quot;14_2&quot; &quot;13_2&quot; &quot;12_2&quot; &quot;NA_2&quot; 
##      l 
## &quot;14_3&quot;</code></pre>
<pre class="r"><code>correctToUnique(aa, sep=&quot;.&quot;, NAenum=FALSE)       # keep NAs (ie without transforming to character)</code></pre>
<pre><code>##      a      b      c      d      e      f      g      h      i      j      k 
##   &quot;11&quot; &quot;12.1&quot; &quot;13.1&quot; &quot;14.1&quot;   &quot;15&quot;   &quot;16&quot;     NA &quot;14.2&quot; &quot;13.2&quot; &quot;12.2&quot;     NA 
##      l 
## &quot;14.3&quot;</code></pre>
<p>You see from the last example above, that this function has an
argument for controlling enumerating elements.</p>
</div>
<div id="mark-any-duplicated-ie-ambiguous-elements-by-changing-their-names-and-separate-from-unqiue" class="section level3">
<h3>Mark Any Duplicated (ie Ambiguous) Elements by Changing Their Names
(and Separate from Unqiue)</h3>
<p>First, the truly unique values are reported and then the first
occurance of repeated elements is given, <em>NA</em> instances get
ignored. This can be done using <code>nonAmbiguousNum()</code> which
maintains the length of the initial character vector.</p>
<pre class="r"><code>unique(aa)                                    # names are lost</code></pre>
<pre><code>## [1] 11 12 13 14 15 16 NA</code></pre>
<pre class="r"><code>nonAmbiguousNum(aa)</code></pre>
<pre><code>##     a     e     f amb_b amb_c 
##    11    15    16    12    13</code></pre>
<pre class="r"><code>nonAmbiguousNum(aa, uniq=FALSE, asLi=TRUE)    # separate in list unique and repeated </code></pre>
<pre><code>## $unique
##  a  e  f 
## 11 15 16 
## 
## $ambig
## amb_b amb_c 
##    12    13</code></pre>
</div>
<div id="compare-multiple-vectors-and-sort-by-number-of-commonrepeated-valueswords" class="section level3">
<h3>Compare Multiple Vectors And Sort By Number Of Common/Repeated
Values/Words</h3>
<p>The main aim of the function <code>sortByNRepeated()</code> is
allowing to compare multiple vectors for common values/words and
providing an output sorted by number of repeats.</p>
<p>Suppose 3 persons are asked which cities they wanted to visit. Then
we would like to make a counting of the most frequently cited cities.
Here we consider individual choices as equally ranked. By default
intra-repeats are eliminated.</p>
<pre class="r"><code>cities &lt;- c(&quot;Bangkok&quot;,&quot;London&quot;,&quot;Paris&quot;, &quot;Singapore&quot;,&quot;New York City&quot;, &quot;Istambul&quot;,&quot;Delhi&quot;,&quot;Rome&quot;,&quot;Dubai&quot;)
sortByNRepeated(x=cities[c(1:4)], y=cities[c(2:3,5:8)])</code></pre>
<pre><code>## $`1`
## [1] &quot;Bangkok&quot;       &quot;Delhi&quot;         &quot;Istambul&quot;      &quot;New York City&quot;
## [5] &quot;Rome&quot;          &quot;Singapore&quot;    
## 
## $`2`
## [1] &quot;London&quot; &quot;Paris&quot;</code></pre>
<pre class="r"><code>## or (unlimited) multiple inputs via list
choices1 &lt;- list(Mary=cities[c(1:4)], Olivia=cities[c(2:3,5:8)], Paul=cities[c(5:3,9,5)])    # Note : Paul cited NYC twice !
table(unlist(choices1))</code></pre>
<pre><code>## 
##       Bangkok         Delhi         Dubai      Istambul        London 
##             1             1             1             1             2 
## New York City         Paris          Rome     Singapore 
##             3             3             1             2</code></pre>
<pre class="r"><code>sortByNRepeated(choices1)</code></pre>
<pre><code>## $`1`
## [1] &quot;Bangkok&quot;  &quot;Delhi&quot;    &quot;Dubai&quot;    &quot;Istambul&quot; &quot;Rome&quot;    
## 
## $`2`
## [1] &quot;London&quot;        &quot;New York City&quot; &quot;Singapore&quot;    
## 
## $`3`
## [1] &quot;Paris&quot;</code></pre>
<pre class="r"><code>sortByNRepeated(choices1, filterIntraRep=FALSE)  # without correcting multiple citation of NYC by Paul</code></pre>
<pre><code>## $`1`
## [1] &quot;Bangkok&quot;  &quot;Delhi&quot;    &quot;Dubai&quot;    &quot;Istambul&quot; &quot;Rome&quot;    
## 
## $`2`
## [1] &quot;London&quot;    &quot;Singapore&quot;
## 
## $`3`
## [1] &quot;New York City&quot; &quot;Paris&quot;</code></pre>
</div>
<div id="combine-multiple-matrixes-where-some-column-names-are-the-same" class="section level3">
<h3>Combine Multiple Matrixes Where Some Column-Names Are The Same</h3>
<p>Here, it is supposed that you want to join 2 or more matrixes
describing different properties of the same collection of individuals
(as rows). Common column-names are interpreted that their respective
information should be combined (either as average or as sum). This can
be done using <code>cbindNR()</code> :</p>
<pre class="r"><code>## First we&#39;ll make some toy data :
(ma1 &lt;- matrix(1:6, ncol=3, dimnames=list(1:2,LETTERS[3:1])))</code></pre>
<pre><code>##   C B A
## 1 1 3 5
## 2 2 4 6</code></pre>
<pre class="r"><code>(ma2 &lt;- matrix(11:16, ncol=3, dimnames=list(1:2,LETTERS[3:5])))</code></pre>
<pre><code>##    C  D  E
## 1 11 13 15
## 2 12 14 16</code></pre>
<pre class="r"><code>## now we can join 2 or more matrixes  
cbindNR(ma1, ma2, summarizeAs=&quot;mean&quot;)       # average of both columns &#39;C&#39;</code></pre>
<pre><code>## cbindNR :  treating 5 different (types of) columns : C B A D E</code></pre>
<pre><code>## cbindNR :   sorting columns of output</code></pre>
<pre><code>##   A B C  D  E
## 1 5 3 6 13 15
## 2 6 4 7 14 16</code></pre>
</div>
<div id="filter-matrix-to-keep-only-first-of-repeated-lines" class="section level3">
<h3>Filter Matrix To Keep Only First Of Repeated Lines</h3>
<p>This ressembles to the functioning of <em>unique()</em>, but applies
to a user-specified column of the matrix.</p>
<pre class="r"><code>(mat1 &lt;- matrix(c(1:6, rep(1:3,1:3)), ncol=2, dimnames=list(letters[1:6],LETTERS[1:2])))</code></pre>
<pre><code>##   A B
## a 1 1
## b 2 2
## c 3 2
## d 4 3
## e 5 3
## f 6 3</code></pre>
<p>The function <code>firstLineOfDat()</code> allows to access/extract
the first line of repeated instances.</p>
<pre class="r"><code>firstLineOfDat(mat1, refCol=2)</code></pre>
<pre><code>##   A B
## a 1 1
## b 2 2
## d 4 3</code></pre>
<p>This function was rather designed for dealing with character input,
it allows concatenating all columns and to remove redundant.</p>
<pre class="r"><code>mat2 &lt;- matrix(c(&quot;e&quot;,&quot;n&quot;,&quot;a&quot;,&quot;n&quot;,&quot;z&quot;,&quot;z&quot;,&quot;n&quot;,&quot;z&quot;,&quot;z&quot;,&quot;b&quot;, 
  &quot;&quot;,&quot;n&quot;,&quot;c&quot;,&quot;n&quot;,&quot;&quot;,&quot;&quot;,&quot;n&quot;,&quot;&quot;,&quot;&quot;,&quot;z&quot;), ncol=2)
firstOfRepLines(mat2, out=&quot;conc&quot;)</code></pre>
<pre><code>## [1] &quot;e&quot;  &quot;nn&quot; &quot;ac&quot; &quot;z&quot;  &quot;bz&quot;</code></pre>
<pre class="r"><code># or as index :
firstOfRepLines(mat2)</code></pre>
<pre><code>## [1]  1  2  3  5 10</code></pre>
</div>
<div id="filter-to-unique-column-content-of-matrix-add-counter-and-concatenated-information" class="section level3">
<h3>Filter To Unique Column-Content Of Matrix, Add Counter And
Concatenated Information</h3>
<pre class="r"><code>(df1 &lt;- data.frame(cbind(xA=letters[1:5], xB=c(&quot;h&quot;,&quot;h&quot;,&quot;f&quot;,&quot;e&quot;,&quot;f&quot;), xC=LETTERS[1:5])))</code></pre>
<pre><code>##   xA xB xC
## 1  a  h  A
## 2  b  h  B
## 3  c  f  C
## 4  d  e  D
## 5  e  f  E</code></pre>
<p>The function <code>nonredDataFrame()</code> offers to include a
counter of redundant instances encountered (for 1st column specified)
:</p>
<pre class="r"><code>nonredDataFrame(df1, useCol=c(&quot;xB&quot;,&quot;xC&quot;)) </code></pre>
<pre><code>##   xA xB xC nSamePep concID
## 1  a  h  A        2   C//E
## 3  c  f  C        2   A//B
## 4  d  e  D        1      D</code></pre>
<pre class="r"><code># without counter or concatenating
df1[which(!duplicated(df1[,2])),]</code></pre>
<pre><code>##   xA xB xC
## 1  a  h  A
## 3  c  f  C
## 4  d  e  D</code></pre>
<pre class="r"><code># or
df1[firstOfRepLines(df1,useCol=2),]</code></pre>
<pre><code>##   xA xB xC
## 1  a  h  A
## 3  c  f  C
## 4  d  e  D</code></pre>
</div>
<div id="get-first-of-repeated-by-column" class="section level3">
<h3>Get First Of Repeated By Column</h3>
<pre class="r"><code>mat2 &lt;- cbind(no=as.character(1:20), seq=sample(LETTERS[1:15], 20, repl=TRUE),
  ty=sample(c(&quot;full&quot;,&quot;Nter&quot;,&quot;inter&quot;),20,repl=TRUE), ambig=rep(NA,20), seqNa=1:20)
(mat2uniq &lt;- get1stOfRepeatedByCol(mat2, sortBy=&quot;seq&quot;, sortSupl=&quot;ty&quot;))</code></pre>
<pre><code>##       no   seq ty      ambig  seqNa
##  [1,] &quot;6&quot;  &quot;M&quot; &quot;Nter&quot;  NA     &quot;6&quot;  
##  [2,] &quot;11&quot; &quot;C&quot; &quot;inter&quot; NA     &quot;11&quot; 
##  [3,] &quot;12&quot; &quot;N&quot; &quot;Nter&quot;  NA     &quot;12&quot; 
##  [4,] &quot;17&quot; &quot;J&quot; &quot;full&quot;  NA     &quot;17&quot; 
##  [5,] &quot;18&quot; &quot;A&quot; &quot;full&quot;  NA     &quot;18&quot; 
##  [6,] &quot;19&quot; &quot;O&quot; &quot;Nter&quot;  NA     &quot;19&quot; 
##  [7,] &quot;7&quot;  &quot;B&quot; &quot;Nter&quot;  &quot;TRUE&quot; &quot;_7&quot; 
##  [8,] &quot;10&quot; &quot;D&quot; &quot;full&quot;  &quot;TRUE&quot; &quot;_10&quot;
##  [9,] &quot;8&quot;  &quot;E&quot; &quot;full&quot;  &quot;TRUE&quot; &quot;_8&quot; 
## [10,] &quot;9&quot;  &quot;F&quot; &quot;full&quot;  &quot;TRUE&quot; &quot;_9&quot; 
## [11,] &quot;13&quot; &quot;G&quot; &quot;Nter&quot;  &quot;TRUE&quot; &quot;_13&quot;
## [12,] &quot;3&quot;  &quot;H&quot; &quot;Nter&quot;  &quot;TRUE&quot; &quot;_3&quot;</code></pre>
<pre class="r"><code># the values from column &#39;seq&#39; are indeed unique
table(mat2uniq[,&quot;seq&quot;])</code></pre>
<pre><code>## 
## A B C D E F G H J M N O 
## 1 1 1 1 1 1 1 1 1 1 1 1</code></pre>
<pre class="r"><code># This will return all first repeated (may be &gt;1) but without furter sorting 
#  along column &#39;ty&#39; neither marking in comumn &#39;ambig&#39;).
mat2[which(duplicated(mat2[,2],fromLast=FALSE)),]</code></pre>
<pre><code>##      no   seq ty     ambig seqNa
## [1,] &quot;5&quot;  &quot;H&quot; &quot;Nter&quot; NA    &quot;5&quot;  
## [2,] &quot;8&quot;  &quot;E&quot; &quot;full&quot; NA    &quot;8&quot;  
## [3,] &quot;9&quot;  &quot;F&quot; &quot;full&quot; NA    &quot;9&quot;  
## [4,] &quot;13&quot; &quot;G&quot; &quot;Nter&quot; NA    &quot;13&quot; 
## [5,] &quot;14&quot; &quot;D&quot; &quot;full&quot; NA    &quot;14&quot; 
## [6,] &quot;15&quot; &quot;D&quot; &quot;full&quot; NA    &quot;15&quot; 
## [7,] &quot;16&quot; &quot;B&quot; &quot;Nter&quot; NA    &quot;16&quot; 
## [8,] &quot;20&quot; &quot;F&quot; &quot;full&quot; NA    &quot;20&quot;</code></pre>
</div>
<div id="transform-ambigous-matrix-to-non-ambiguous-matrix-in-respect-to-given-column" class="section level3">
<h3>Transform (ambigous) Matrix To Non-ambiguous Matrix (In Respect To
Given Column)</h3>
<pre class="r"><code>nonAmbiguousMat(mat1,by=2)</code></pre>
<pre><code>##       A B
## 1     1 1
## amb_3 3 2
## amb_6 6 3</code></pre>
<p>Here another example, ambiguous will be marked by an ’_’ :</p>
<pre class="r"><code>set.seed(2017); mat3 &lt;- matrix(c(1:100,round(rnorm(200),2)), ncol=3,
  dimnames=list(1:100,LETTERS[1:3]));
head(mat3U &lt;- nonAmbiguousMat(mat3, by=&quot;B&quot;, na=&quot;_&quot;, uniqO=FALSE), n=15)</code></pre>
<pre><code>##      A     B     C
## 81  81 -2.59 -0.14
## 93  93 -2.02 -0.03
## 7    7 -1.96  0.52
## 4    4 -1.76  0.84
## _74 74 -1.65  0.30
## 55  55 -1.59  1.25
## 52  52 -1.58 -0.24
## 15  15 -1.43 -0.60
## 98  98 -1.34  0.41
## 63  63 -1.33  0.26
## 19  19 -1.13  0.70
## 41  41 -1.06 -0.56
## _56 56 -1.03 -1.07
## 94  94 -0.98 -0.02
## 95  95 -0.97  0.08</code></pre>
<pre class="r"><code>head(get1stOfRepeatedByCol(mat3, sortB=&quot;B&quot;, sortS=&quot;B&quot;))</code></pre>
<pre><code>##   A     B     C
## 1 1  1.43  0.02
## 2 2 -0.08  1.38
## 3 3  0.74 -0.07
## 4 4 -1.76  0.84
## 5 5 -0.07 -0.97
## 6 6  0.45 -1.97</code></pre>
</div>
<div id="combine-replicates-from-list-to-matrix" class="section level3">
<h3>Combine Replicates From List To Matrix</h3>
<pre class="r"><code>lst2 &lt;- list(aa_1x=matrix(1:12, nrow=4, byrow=TRUE), ab_2x=matrix(24:13, nrow=4, byrow=TRUE))
combineReplFromListToMatr(lst2)</code></pre>
<pre><code>## $a
##        1
##  [1,]  1
##  [2,]  4
##  [3,]  7
##  [4,] 10
##  [5,]  2
##  [6,]  5
##  [7,]  8
##  [8,] 11
##  [9,]  3
## [10,]  6
## [11,]  9
## [12,] 12
## 
## $b
##        2
##  [1,] 24
##  [2,] 21
##  [3,] 18
##  [4,] 15
##  [5,] 23
##  [6,] 20
##  [7,] 17
##  [8,] 14
##  [9,] 22
## [10,] 19
## [11,] 16
## [12,] 13</code></pre>
</div>
<div id="combine-redundant-lines-from-list-with-multiple-matrix-according-to-reference" class="section level3">
<h3>Combine Redundant Lines From List with (Multiple) Matrix According
to Reference</h3>
<p>The function <code>combineRedundLinesInList()</code> provides help
for combining/summarizing lines of numeric data which may be summaried
according to reference vector or matrix (part of the same input-list).
Initial data and reference will be aligned based on rownames and the
content of reference (or the column specified by ).</p>
<pre class="r"><code>x1 &lt;- list(quant=matrix(11:34, ncol=3, dimnames=list(letters[8:1], LETTERS[11:13])), 
  annot=matrix(paste0(LETTERS[c(1:4,6,3:5)],LETTERS[c(1:4,6,3:5)]), ncol=1, 
  dimnames=list(paste(letters[1:8]),&quot;xx&quot;)) )
combineRedundLinesInList(lst=x1, refNa=&quot;annot&quot;, datNa=&quot;quant&quot;, refColNa=&quot;xx&quot;)</code></pre>
<pre><code>## $quant
##       K    L    M
## AA 11.0 19.0 27.0
## BB 12.0 20.0 28.0
## CC 14.5 22.5 30.5
## DD 15.5 23.5 31.5
## EE 18.0 26.0 34.0
## FF 15.0 23.0 31.0
## 
## $annot
##      xx   xx2  
## [1,] &quot;AA&quot; &quot;a&quot;  
## [2,] &quot;BB&quot; &quot;b&quot;  
## [3,] &quot;CC&quot; &quot;c,f&quot;
## [4,] &quot;DD&quot; &quot;d,g&quot;
## [5,] &quot;EE&quot; &quot;h&quot;  
## [6,] &quot;FF&quot; &quot;e&quot;</code></pre>
</div>
<div id="non-redundant-lines-of-matrix" class="section level3">
<h3>Non-redundant Lines Of Matrix</h3>
<pre class="r"><code>mat4 &lt;- matrix(rep(c(1,1:3,3,1),2), ncol=2, dimnames=list(letters[1:6],LETTERS[1:2]))
nonRedundLines(mat4)</code></pre>
<pre><code>##   A B
## a 1 1
## c 2 2
## d 3 3
## f 1 1</code></pre>
</div>
<div id="filter-for-unique-elements-2" class="section level3">
<h3>Filter For Unique Elements /2</h3>
<pre class="r"><code># input: c and dd are repeated  :
filtSizeUniq(list(A=&quot;a&quot;, B=c(&quot;b&quot;,&quot;bb&quot;,&quot;c&quot;), D=c(&quot;dd&quot;,&quot;d&quot;,&quot;ddd&quot;,&quot;c&quot;)), filtUn=TRUE, minSi=NULL)</code></pre>
<pre><code>## filtSizeUniq : 2 out of 8 peptides redundant</code></pre>
<pre><code>## $A
##   A 
## &quot;a&quot; 
## 
## $B
##  B.1  B.2 
##  &quot;b&quot; &quot;bb&quot; 
## 
## $D
##   D.1   D.2   D.3 
##  &quot;dd&quot;   &quot;d&quot; &quot;ddd&quot;</code></pre>
<pre class="r"><code># here a,b,c and dd are repeated  :
filtSizeUniq(list(A=&quot;a&quot;, B=c(&quot;b&quot;,&quot;bb&quot;,&quot;c&quot;), D=c(&quot;dd&quot;,&quot;d&quot;,&quot;ddd&quot;,&quot;c&quot;)), ref=c(letters[c(1:26,1:3)],
  &quot;dd&quot;,&quot;dd&quot;,&quot;bb&quot;,&quot;ddd&quot;), filtUn=TRUE, minSi=NULL)   </code></pre>
<pre><code>## filtSizeUniq : 8 out of 8 peptides redundant</code></pre>
<pre><code>## $A
## character(0)
## 
## $B
## character(0)
## 
## $D
## character(0)</code></pre>
</div>
<div id="make-non-redundant-matrix" class="section level3">
<h3>Make Non-redundant Matrix</h3>
<pre class="r"><code>t3 &lt;- data.frame(ref=rep(11:15,3), tx=letters[1:15],
  matrix(round(runif(30,-3,2),1), nc=2), stringsAsFactors=FALSE)
  
# First we split the data.frame in list  
by(t3,t3[,1], function(x) x)</code></pre>
<pre><code>## t3[, 1]: 11
##    ref tx  X1   X2
## 1   11  a 0.4 -1.1
## 6   11  f 0.6  1.0
## 11  11  k 0.1  1.2
## ------------------------------------------------------------ 
## t3[, 1]: 12
##    ref tx   X1   X2
## 2   12  b  2.0 -0.4
## 7   12  g -0.3  1.8
## 12  12  l -1.4  0.3
## ------------------------------------------------------------ 
## t3[, 1]: 13
##    ref tx  X1   X2
## 3   13  c 0.8 -1.6
## 8   13  h 0.8 -2.4
## 13  13  m 0.9  1.8
## ------------------------------------------------------------ 
## t3[, 1]: 14
##    ref tx   X1   X2
## 4   14  d  1.7  0.7
## 9   14  i -1.6 -2.6
## 14  14  n  1.4 -1.1
## ------------------------------------------------------------ 
## t3[, 1]: 15
##    ref tx   X1   X2
## 5   15  e -0.9  0.4
## 10  15  j -1.7  0.0
## 15  15  o -1.2 -1.8</code></pre>
<pre class="r"><code>t(sapply(by(t3,t3[,1],function(x) x), summarizeCols, me=&quot;maxAbsOfRef&quot;))</code></pre>
<pre><code>##    ref tx  X1   X2  
## 11 11  &quot;k&quot; 0.1  1.2 
## 12 12  &quot;g&quot; -0.3 1.8 
## 13 13  &quot;h&quot; 0.8  -2.4
## 14 14  &quot;i&quot; -1.6 -2.6
## 15 15  &quot;o&quot; -1.2 -1.8</code></pre>
<pre class="r"><code>(xt3 &lt;- makeNRedMatr(t3, summ=&quot;mean&quot;, iniID=&quot;ref&quot;))</code></pre>
<pre><code>## makeNRedMatr : Common summarization method &#39;mean&#39;, run as batch</code></pre>
<pre><code>## makeNRedMatr : Summarize redundant based on col &#39;ref&#39;  using method(s) : &#39;mean&#39;, &#39;mean&#39;, &#39;mean&#39; and &#39;mean&#39; yielding 4 cols</code></pre>
<pre><code>##    ID ref tx         X1         X2 nRedLi
## 11 11  11  f  0.3666667  0.3666667      3
## 12 12  12  g  0.1000000  0.5666667      3
## 13 13  13  h  0.8333333 -0.7333333      3
## 14 14  14  i  0.5000000 -1.0000000      3
## 15 15  15  j -1.2666667 -0.4666667      3</code></pre>
<pre class="r"><code>(xt3 &lt;- makeNRedMatr(t3, summ=unlist(list(X1=&quot;maxAbsOfRef&quot;)), iniID=&quot;ref&quot;))</code></pre>
<pre><code>## makeNRedMatr : Summarize redundant based on col &#39;ref&#39;  using method(s) : &#39;maxAbsOfRef&#39; and col &#39;X1&#39; yielding 4 cols</code></pre>
<pre><code>##    ref tx   X1   X2 nRedLi
## 11  11  f  0.6  1.0      3
## 12  12  b  2.0 -0.4      3
## 13  13  m  0.9  1.8      3
## 14  14  d  1.7  0.7      3
## 15  15  j -1.7  0.0      3</code></pre>
<div id="example-summarize-table-for-longest-of-transcripts" class="section level4">
<h4>Example : Summarize table for longest of transcripts</h4>
<p>In the previous example for each subgroup a summarization was
calculated. In other cases you may just want to select a line according
to values from a single column. Suppose you want to select the line
corresponding to the longest transcript.</p>
<pre class="r"><code>set.seed(2024)
df2 &lt;- data.frame(transcrID=paste(&quot;TrID&quot;, 101:124, sep=&quot;&quot;), geneID=paste(&quot;geID&quot;,rep(201:206,each=4)), 
  geneLe=round(runif(24, min=50, max=1500)), a=101:124, b=224:201)
df2 &lt;- df2[-1*c(1,4:7,12:15),]  

(dfLongest &lt;- makeNRedMatr(df2, summ=unlist(list(X1=&quot;maxOfRef&quot;)), iniID=&quot;geneID&quot;))</code></pre>
<pre><code>## makeNRedMatr : Which column to use with &#39;maxOfRef&#39; not specified, using last numeric &#39;b&#39;</code></pre>
<pre><code>## makeNRedMatr : Summarize redundant based on col &#39;geneID&#39;  using method(s) : &#39;maxOfRef&#39; and col &#39;b&#39; yielding 5 cols</code></pre>
<pre><code>##          transcrID   geneID geneLe   a   b nRedLi
## geID 201   TrID102 geID 201    515 102 223      2
## geID 202   TrID108 geID 202    490 108 217      1
## geID 203   TrID109 geID 203   1321 109 216      3
## geID 204   TrID116 geID 204   1271 116 209      1
## geID 205   TrID117 geID 205    210 117 208      4
## geID 206   TrID121 geID 206    119 121 204      4</code></pre>
<pre class="r"><code> summarizeCols(df2[1:2,c(1:5,3)], me=&quot;min&quot;)  </code></pre>
<pre><code>##     transcrID geneID     geneLe a     b     geneLe.1
## out &quot;TrID102&quot; &quot;geID 201&quot; &quot; 515&quot; &quot;102&quot; &quot;222&quot; &quot; 515&quot;</code></pre>
<pre class="r"><code> summarizeCols(df2[1:2,c(1:5,3)], me=&quot;mean&quot;) </code></pre>
<pre><code>##   transcrID   geneID geneLe     a     b geneLe.1
## 2   TrID102 geID 201    776 102.5 222.5      776</code></pre>
<pre class="r"><code> summarizeCols(df2[1:2,c(1:5,3)], me=&quot;maxOfRef&quot;) </code></pre>
<pre><code>##   transcrID   geneID geneLe   a   b geneLe.1
## 3   TrID103 geID 201   1037 103 222     1037</code></pre>
<pre class="r"><code> summarizeCols(df2[1:6,c(1:5,3)], me=&quot;maxOfRef&quot;)</code></pre>
<pre><code>##    transcrID   geneID geneLe   a   b geneLe.1
## 11   TrID111 geID 203   1358 111 214     1358</code></pre>
<pre class="r"><code>(xt3 &lt;- makeNRedMatr(t3, summ=unlist(list(X1=&quot;maxOfRef&quot;)), iniID=c(&quot;ref&quot;)))  </code></pre>
<pre><code>## makeNRedMatr : Summarize redundant based on col &#39;ref&#39;  using method(s) : &#39;maxOfRef&#39; and col &#39;X1&#39; yielding 4 cols</code></pre>
<pre><code>##    ref tx   X1   X2 nRedLi
## 11  11  f  0.6  1.0      3
## 12  12  b  2.0 -0.4      3
## 13  13  m  0.9  1.8      3
## 14  14  d  1.7  0.7      3
## 15  15  e -0.9  0.4      3</code></pre>
</div>
</div>
<div id="combinereduce-redundant-lines-based-on-specified-column" class="section level3">
<h3>Combine/Reduce Redundant Lines Based On Specified Column</h3>
<pre class="r"><code>matr &lt;- matrix(c(letters[1:6],&quot;h&quot;,&quot;h&quot;,&quot;f&quot;,&quot;e&quot;,LETTERS[1:5]), ncol=3,
  dimnames=list(letters[11:15],c(&quot;xA&quot;,&quot;xB&quot;,&quot;xC&quot;)))
combineRedBasedOnCol(matr, colN=&quot;xB&quot;)</code></pre>
<pre><code>##   xA    xB  xC   
## 2 &quot;a,d&quot; &quot;f&quot; &quot;A,D&quot;
## 3 &quot;b,c&quot; &quot;h&quot; &quot;B,C&quot;
## 1 &quot;e&quot;   &quot;e&quot; &quot;E&quot;</code></pre>
<pre class="r"><code>combineRedBasedOnCol(rbind(matr[1,],matr), colN=&quot;xB&quot;)</code></pre>
<pre><code>##   xA    xB  xC   
## 2 &quot;a,d&quot; &quot;f&quot; &quot;A,D&quot;
## 3 &quot;b,c&quot; &quot;h&quot; &quot;B,C&quot;
## 1 &quot;e&quot;   &quot;e&quot; &quot;E&quot;</code></pre>
</div>
<div id="convert-matrix-eg-with-redundant-row-names-to-data.frame" class="section level3">
<h3>Convert Matrix (eg With Redundant) Row-Names To data.frame</h3>
<pre class="r"><code>x &lt;- 1
dat1 &lt;- matrix(1:10, ncol=2)
rownames(dat1) &lt;- letters[c(1:3,2,5)]
## as.data.frame(dat1)  ...  would result in an error
convMatr2df(dat1)</code></pre>
<pre><code>##     ID X1 X2
## a    a  1  6
## b_1  b  2  7
## c    c  3  8
## b_2  b  4  9
## e    e  5 10</code></pre>
<pre class="r"><code>convMatr2df(data.frame(a=as.character((1:3)/2), b=LETTERS[1:3], c=1:3))</code></pre>
<pre><code>##     a b c
## 1 0.5 A 1
## 2 1.0 B 2
## 3 1.5 C 3</code></pre>
<pre class="r"><code>tmp &lt;- data.frame(a=as.character((1:3)/2), b=LETTERS[1:3], c=1:3, stringsAsFactors=FALSE)
convMatr2df(tmp)</code></pre>
<pre><code>##     a b c
## 1 0.5 A 1
## 2 1.0 B 2
## 3 1.5 C 3</code></pre>
<pre class="r"><code>tmp &lt;- data.frame(a=as.character((1:3)/2), b=1:3, stringsAsFactors=FALSE)
convMatr2df(tmp) </code></pre>
<pre><code>##     a b
## 1 0.5 1
## 2 1.0 2
## 3 1.5 3</code></pre>
</div>
<div id="find-and-combine-points-located-very-close-in-xy-space" class="section level3">
<h3>Find And Combine Points Located Very Close In X/Y Space</h3>
<pre class="r"><code>set.seed(2013)
datT2 &lt;- matrix(round(rnorm(200)+3,1), ncol=2, dimnames=list(paste(&quot;li&quot;,1:100,sep=&quot;&quot;),
  letters[23:24]))
# (mimick) some short and longer names for each line
inf2 &lt;- cbind(sh=paste(rep(letters[1:4],each=26), rep(letters,4),1:(26*4),sep=&quot;&quot;),
  lo=paste(rep(LETTERS[1:4],each=26), rep(LETTERS,4), 1:(26*4), &quot;,&quot;, 
  rep(letters[sample.int(26)],4), rep(letters[sample.int(26)],4), sep=&quot;&quot;))[1:100,] 
## We&#39;ll use this to test :  
head(datT2, n=10)</code></pre>
<pre><code>##        w   x
## li1  2.9 3.7
## li2  3.8 3.3
## li3  2.3 3.3
## li4  4.4 3.1
## li5  4.5 1.8
## li6  0.4 2.4
## li7  3.7 3.3
## li8  3.3 4.0
## li9  5.0 4.1
## li10 1.6 1.1</code></pre>
<pre class="r"><code>## let&#39;s assign to each pair of x &amp; y values a &#39;cluster&#39; (column _clu_, the column _combInf_ tells us which lines/indexes are in this cluster)
head(combineOverlapInfo(datT2, disThr=0.03), n=10)</code></pre>
<pre><code>##        w   x       combInf clu isComb
## li1  2.9 3.7 1+16+22+47+91   1   TRUE
## li2  3.8 3.3     2+7+48+54   2   TRUE
## li3  2.3 3.3       3+66+92   3   TRUE
## li4  4.4 3.1             4  52  FALSE
## li5  4.5 1.8             5  53  FALSE
## li6  0.4 2.4             6  54  FALSE
## li7  3.7 3.3     2+7+48+54   2   TRUE
## li8  3.3 4.0         8+100   4   TRUE
## li9  5.0 4.1             9  55  FALSE
## li10 1.6 1.1            10  56  FALSE</code></pre>
<pre class="r"><code>## it is also possible to rather display names (eg gene or protein-names) instead of index values
head(combineOverlapInfo(datT2, suplI=inf2[,2], disThr=0.03), n=10)</code></pre>
<pre><code>##        w   x                 combInf clu isComb
## li1  2.9 3.7 AA1+AP16+AV22+BU47+DM91   1   TRUE
## li2  3.8 3.3       AB2+AG7+BV48+CB54   2   TRUE
## li3  2.3 3.3           AC3+CN66+DN92   3   TRUE
## li4  4.4 3.1                  AD4,ww  52  FALSE
## li5  4.5 1.8                  AE5,aj  53  FALSE
## li6  0.4 2.4                  AF6,nl  54  FALSE
## li7  3.7 3.3       AB2+AG7+BV48+CB54   2   TRUE
## li8  3.3 4.0               AH8+DV100   4   TRUE
## li9  5.0 4.1                  AI9,ic  55  FALSE
## li10 1.6 1.1                 AJ10,ee  56  FALSE</code></pre>
</div>
<div id="bin-and-summarize-values-according-to-their-names" class="section level3">
<h3>Bin And Summarize Values According To Their Names</h3>
<pre class="r"><code>dat &lt;- 11:19
names(dat) &lt;- letters[c(6:3,2:4,8,3)]
## Here the names are not unique.
## Thus, the values can be binned by their (non-unique) names and a representative values calculated.

## Let&#39;s make a &#39;datUniq&#39; with the mean of each group of values :
datUniq &lt;- round(tapply(dat, names(dat), mean),1)
## now we propagate the mean values to the full vector 
getValuesByUnique(dat, datUniq)</code></pre>
<pre><code>##    f    e    d    c    b    c    d    h    c 
## 11.0 12.0 15.0 16.3 15.0 16.3 15.0 18.0 16.3</code></pre>
<pre class="r"><code>cbind(ini=dat,firstOfRep=getValuesByUnique(dat, datUniq),
  indexUniq=getValuesByUnique(dat, datUniq, asIn=TRUE))</code></pre>
<pre><code>##   ini firstOfRep indexUniq
## f  11       11.0         5
## e  12       12.0         4
## d  13       15.0         3
## c  14       16.3         2
## b  15       15.0         1
## c  16       16.3         2
## d  17       15.0         3
## h  18       18.0         6
## c  19       16.3         2</code></pre>
</div>
<div id="regrouping-simultaneaously-by-two-factors" class="section level3">
<h3>Regrouping Simultaneaously by Two Factors</h3>
<p>For example, if you wish to create group-labels considering the eye-
and hair-color of a small group students (supposed a sort of controlled
vocabulary was used), the function <code>combineByEitherFactor()</code>
will help. So basically, this is an empiric segmentation-approach for
two categorical variables. Please note, that with large data-sets and
very disperse data this approach will not provide great results. In the
example below we’ll attempt to ‘cluster’ according to columns
<em>nn</em> and <em>qq</em>, the resultant cluster number can be found
in column <em>grp</em>.</p>
<pre class="r"><code>nn &lt;- rep(c(&quot;a&quot;,&quot;e&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;g&quot;,&quot;f&quot;),c(3,1,2,2,1,2,1))
qq &lt;- rep(c(&quot;m&quot;,&quot;n&quot;,&quot;p&quot;,&quot;o&quot;,&quot;q&quot;),c(2,1,1,4,4))
nq &lt;- cbind(nn,qq)[c(4,2,9,11,6,10,7,3,5,1,12,8),]
## Here we consider 2 columns &#39;nn&#39; and &#39;qq&#39; whe trying to regroup common values
##  (eg value &#39;a&#39; from column &#39;nn&#39; and value &#39;o&#39; from &#39;qq&#39;) 
combineByEitherFactor(nq, 1, 2, nBy=FALSE)</code></pre>
<pre><code>##    nn  qq  grp
## m2 &quot;a&quot; &quot;m&quot; &quot;1&quot;
## q2 &quot;f&quot; &quot;q&quot; &quot;3&quot;
## q1 &quot;d&quot; &quot;q&quot; &quot;3&quot;
## o2 &quot;b&quot; &quot;o&quot; &quot;2&quot;
## p  &quot;e&quot; &quot;p&quot; &quot;4&quot;
## o4 &quot;c&quot; &quot;o&quot; &quot;2&quot;
## q4 &quot;g&quot; &quot;q&quot; &quot;3&quot;
## n  &quot;a&quot; &quot;n&quot; &quot;1&quot;
## m1 &quot;a&quot; &quot;m&quot; &quot;1&quot;
## q3 &quot;g&quot; &quot;q&quot; &quot;3&quot;
## o1 &quot;b&quot; &quot;o&quot; &quot;2&quot;
## o3 &quot;c&quot; &quot;o&quot; &quot;2&quot;</code></pre>
<p>The argument <em>nBy</em> simply allows adding an additional column
with the group/cluster-number.</p>
<pre class="r"><code>## the same, but including n by group/cluster
combineByEitherFactor(nq, 1, 2, nBy=TRUE)</code></pre>
<pre><code>##    nn  qq  grp nGrp
## m2 &quot;a&quot; &quot;m&quot; &quot;1&quot; &quot;3&quot; 
## q2 &quot;f&quot; &quot;q&quot; &quot;3&quot; &quot;4&quot; 
## q1 &quot;d&quot; &quot;q&quot; &quot;3&quot; &quot;4&quot; 
## o2 &quot;b&quot; &quot;o&quot; &quot;2&quot; &quot;4&quot; 
## p  &quot;e&quot; &quot;p&quot; &quot;4&quot; &quot;1&quot; 
## o4 &quot;c&quot; &quot;o&quot; &quot;2&quot; &quot;4&quot; 
## q4 &quot;g&quot; &quot;q&quot; &quot;3&quot; &quot;4&quot; 
## n  &quot;a&quot; &quot;n&quot; &quot;1&quot; &quot;3&quot; 
## m1 &quot;a&quot; &quot;m&quot; &quot;1&quot; &quot;3&quot; 
## q3 &quot;g&quot; &quot;q&quot; &quot;3&quot; &quot;4&quot; 
## o1 &quot;b&quot; &quot;o&quot; &quot;2&quot; &quot;4&quot; 
## o3 &quot;c&quot; &quot;o&quot; &quot;2&quot; &quot;4&quot;</code></pre>
<pre class="r"><code>## Not running further iterations works faster, but you may not reach &#39;convergence&#39; immediately
combineByEitherFactor(nq,1, 2, nBy=FALSE)</code></pre>
<pre><code>##    nn  qq  grp
## m2 &quot;a&quot; &quot;m&quot; &quot;1&quot;
## q2 &quot;f&quot; &quot;q&quot; &quot;3&quot;
## q1 &quot;d&quot; &quot;q&quot; &quot;3&quot;
## o2 &quot;b&quot; &quot;o&quot; &quot;2&quot;
## p  &quot;e&quot; &quot;p&quot; &quot;4&quot;
## o4 &quot;c&quot; &quot;o&quot; &quot;2&quot;
## q4 &quot;g&quot; &quot;q&quot; &quot;3&quot;
## n  &quot;a&quot; &quot;n&quot; &quot;1&quot;
## m1 &quot;a&quot; &quot;m&quot; &quot;1&quot;
## q3 &quot;g&quot; &quot;q&quot; &quot;3&quot;
## o1 &quot;b&quot; &quot;o&quot; &quot;2&quot;
## o3 &quot;c&quot; &quot;o&quot; &quot;2&quot;</code></pre>
<pre class="r"><code>##  another example
mm &lt;- rep(c(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;), c(3,4,2,3,1))
pp &lt;- rep(c(&quot;m&quot;,&quot;n&quot;,&quot;o&quot;,&quot;p&quot;,&quot;q&quot;), c(2,2,2,2,5))
combineByEitherFactor(cbind(mm,pp), 1, 2, con=FALSE, nBy=TRUE)</code></pre>
<pre><code>## combineByEitherFactor :  did not reach convergence at 2nd pass</code></pre>
<pre><code>##    mm  pp  grp nGrp
## m1 &quot;a&quot; &quot;m&quot; &quot;1&quot; &quot;4&quot; 
## m2 &quot;a&quot; &quot;m&quot; &quot;1&quot; &quot;4&quot; 
## n1 &quot;a&quot; &quot;n&quot; &quot;1&quot; &quot;4&quot; 
## n2 &quot;b&quot; &quot;n&quot; &quot;1&quot; &quot;4&quot; 
## o1 &quot;b&quot; &quot;o&quot; &quot;2&quot; &quot;4&quot; 
## o2 &quot;b&quot; &quot;o&quot; &quot;2&quot; &quot;4&quot; 
## p1 &quot;b&quot; &quot;p&quot; &quot;2&quot; &quot;4&quot; 
## p2 &quot;c&quot; &quot;p&quot; &quot;2&quot; &quot;4&quot; 
## q1 &quot;c&quot; &quot;q&quot; &quot;3&quot; &quot;5&quot; 
## q2 &quot;d&quot; &quot;q&quot; &quot;3&quot; &quot;5&quot; 
## q3 &quot;d&quot; &quot;q&quot; &quot;3&quot; &quot;5&quot; 
## q4 &quot;d&quot; &quot;q&quot; &quot;3&quot; &quot;5&quot; 
## q5 &quot;e&quot; &quot;q&quot; &quot;3&quot; &quot;5&quot;</code></pre>
</div>
<div id="batch-replacing-of-values-or-character-strings" class="section level3">
<h3>Batch Replacing Of Values Or Character-Strings</h3>
<p>The function <code>multiCharReplace()</code> facilitates multiple
replacements in a vector, matrix or data.frame.</p>
<pre class="r"><code># replace character content
x1 &lt;- c(&quot;ab&quot;,&quot;bc&quot;,&quot;cd&quot;,&quot;efg&quot;,&quot;ghj&quot;)
multiCharReplace(x1, cbind(old=c(&quot;bc&quot;,&quot;efg&quot;), new=c(&quot;BBCC&quot;,&quot;EF&quot;)))</code></pre>
<pre><code>## [1] &quot;ab&quot;   &quot;BBCC&quot; &quot;cd&quot;   &quot;EF&quot;   &quot;ghj&quot;</code></pre>
<pre class="r"><code># works also on matrix and/or to replace numeric content : 
x3 &lt;- matrix(11:16, ncol=2)
multiCharReplace(x3, cbind(12:13,112:113))</code></pre>
<pre><code>##      [,1] [,2]
## [1,]   11   14
## [2,]  112   15
## [3,]  113   16</code></pre>
<p>Sometimes data get imported using different encoding for what should
be interpreted as <em>FALSE</em> and <em>TRUE</em> :</p>
<pre class="r"><code># replace and return logical vactor
x2 &lt;- c(&quot;High&quot;,&quot;n/a&quot;,&quot;High&quot;,&quot;High&quot;,&quot;Low&quot;)
multiCharReplace(x2,cbind(old=c(&quot;n/a&quot;,&quot;Low&quot;,&quot;High&quot;), new=c(NA,FALSE,TRUE)), convTo=&quot;logical&quot;)</code></pre>
<pre><code>## [1]  TRUE    NA  TRUE  TRUE FALSE</code></pre>
</div>
<div id="multi-to-multi-matching-of-concatenated-terms" class="section level3">
<h3>Multi-to-multi Matching Of (Concatenated) Terms</h3>
<p>The function allows to split (if necessary, using
<em>strsplit()</em>) two vectors and compare each isolated tag (eg
identifyer) from the 1st vector/object against each isolated tag from
the second vector/object. This runs like a loop of one to many
comparisons. The basic output is a list with indexes of which element of
the 1st vector/object has matches in the 2nd vector/object. Since this
is not convenient to the human reader, tabular output can be created,
too.</p>
<pre class="r"><code>aa &lt;- c(&quot;m&quot;,&quot;k&quot;,&quot;j; aa&quot;,&quot;m; aa; bb; o&quot;,&quot;n; dd&quot;,&quot;aa&quot;,&quot;cc&quot;)
bb &lt;- c(&quot;aa&quot;,&quot;dd&quot;,&quot;aa; bb; q&quot;,&quot;p; cc&quot;) 
## result as list of indexes
(bOnA &lt;- multiMatch(aa, bb, method=&quot;asIndex&quot;))   # match bb on aa</code></pre>
<pre><code>## $`1`
## named integer(0)
## 
## $`2`
## named integer(0)
## 
## $`3`
## aa aa 
##  1  3 
## 
## $`4`
## aa aa bb 
##  1  3  3 
## 
## $`5`
## dd 
##  2 
## 
## $`6`
## aa aa 
##  1  3 
## 
## $`7`
## cc 
##  4</code></pre>
<pre class="r"><code>## more convenient to the human reader
(bOnA &lt;- multiMatch(aa, bb))                     # match bb on aa</code></pre>
<pre><code>##              x x.Ind TagBest y.IndBest y.IndAll   y.Match        y.Adj
## 1            m     1    &lt;NA&gt;        NA     &lt;NA&gt;      &lt;NA&gt;         &lt;NA&gt;
## 2            k     2    &lt;NA&gt;        NA     &lt;NA&gt;      &lt;NA&gt;         &lt;NA&gt;
## 3        j; aa     3      aa         1     1; 3        aa        j; aa
## 4 m; aa; bb; o     4      aa         3  1; 3; 3 aa; bb; q m; aa; bb; o
## 5        n; dd     5      dd         2        2        dd        n; dd
## 6           aa     6      aa         1     1; 3        aa           aa
## 7           cc     7      cc         4        4     p; cc           cc</code></pre>
<pre class="r"><code>(bOnA &lt;- multiMatch(aa, bb, method=&quot;matchedL&quot;))  # match bb on aa</code></pre>
<pre><code>## $`1`
## named integer(0)
## 
## $`2`
## named integer(0)
## 
## $`3`
## aa aa 
##  1  3 
## 
## $`4`
## aa aa bb 
##  1  3  3 
## 
## $`5`
## dd 
##  2 
## 
## $`6`
## aa aa 
##  1  3 
## 
## $`7`
## cc 
##  4</code></pre>
</div>
<div id="ComparingGlobalPatterns" class="section level3">
<h3>Comparing Global Patterns</h3>
<p>In most programming languages it is fairly easy to compare
<em>exact</em> content of character vectors or factors with unordered
levels. However, sometimes - due to semantic issues - some people may
call a color ‘purple’ while others call it ‘violet’. Thus, without using
controled vocabulary the <em>exact</em> terms may vary.</p>
<p>Here, let’s address the case, where no dictionaries of controled
vocabulary are available for substituting equivalent terms. Thus, we’ll
compare 4 vectors of equal length and check if the words/letters used
could be substituted to result in the first vector. Vectors <em>aa</em>
and <em>ab</em> have the same global pattern, ie after repeating a word
twice it moves to another word. Vectors <em>ac</em> and <em>ad</em> have
different general patterns, either with alternating words or falling
back to a word previsously used.</p>
<p>Based and extended on a post on stackoverflow <a href="https://stackoverflow.com/questions/71353218/extracting-flexible-general-patterns/">https://stackoverflow.com/questions/71353218/extracting-flexible-general-patterns/</a>
:</p>
<pre class="r"><code>aa &lt;- letters[rep(c(3:1,4), each=2)]
ab &lt;- letters[rep(c(5,8:6), each=2)]        # &#39;same general&#39; pattern to aa
ac &lt;- letters[c(1:2,1:3,3:4,4)]             # NOT &#39;same general&#39; pattern to any other
ad &lt;- letters[c(6:8,8:6,7:6)]               # NOT &#39;same general&#39; pattern to any other</code></pre>
<p>The basic pattern can be extracted combining match() and
unique():</p>
<pre class="r"><code>## get global patterns
cbind(aa= match(aa, unique(aa)),
  ab= match(ab, unique(ab)),
  ac= match(ac, unique(ac)),
  ad= match(ad, unique(ad)) )</code></pre>
<pre><code>##      aa ab ac ad
## [1,]  1  1  1  1
## [2,]  1  1  2  2
## [3,]  2  2  1  3
## [4,]  2  2  2  3
## [5,]  3  3  3  2
## [6,]  3  3  3  1
## [7,]  4  4  4  2
## [8,]  4  4  4  1</code></pre>
<p>Let’s make a data.frame with the annotation toy-data from above. Each
line is supposed to represent a sample, and the columns show different
aspects of annotation.</p>
<pre class="r"><code>bb &lt;- data.frame(ind=1:length(aa), a=aa, b=ab, c=ac, d=ad)</code></pre>
<p>Via the function <code>replicateStructure()</code> is it possible to
compare annotation as different columns for equivalent global
patterns.</p>
<p>By default, this function excludes all columns not designating any
replicates, like the numbers in the first column ($ind). Also it will
try to find the column with the median number of levels, when comparing
to all other columns.</p>
<p>The output is a list with <em>$col</em> inidicating which column(s)
may be used, <em>$lev</em> for the correpsonding global pattern,
<em>$meth</em> for the method finally used and <em>$allCols</em> for
documenting the global pattern in each column (whether it was selected
or not).</p>
<pre class="r"><code>replicateStructure(bb)</code></pre>
<pre><code>## $col
## a 
## 2 
## 
## $lev
## c c b b a a d d 
## 1 1 2 2 3 3 4 4 
## 
## $meth
## [1] &quot;single median col&quot;</code></pre>
<p>Besides, it is also possible to combine all columns if one considers
they contribute complementary substructures of the overal
annotation.</p>
<pre class="r"><code>replicateStructure(bb, method=&quot;combAll&quot;)</code></pre>
<pre><code>## $col
## a c d 
## 2 4 5 
## 
## $lev
## c_a_f c_b_g b_a_h b_b_h a_c_g a_c_f d_d_g d_d_f 
##     1     2     3     4     5     6     7     8 
## 
## $meth
## [1] &quot;comb all col&quot;</code></pre>
<p>However, when combining multiple columns it may happen -like in the
example above- that finally no more lines remain being considered as
replicates.</p>
<p>This can also be found when one column describes the groups and
another gives the order of the replicates therein. However, for calling
a (standard) statistical test it may be necessary exclude these
replicate-numbers to designate the groups of replicates.</p>
<p>To overcome the problem of loosing the understanding of
replicate-structure when combining all factors, it is possible to look
for non-orthogonal structures, ie to try excluding columns which (after
combining) would suggest no replicates after combining all columns. See
the example below :</p>
<pre class="r"><code>replicateStructure(bb, method=&quot;combNonOrth&quot;)</code></pre>
<pre><code>## $col
## a d 
## 2 5 
## 
## $lev
## c_f c_g b_h b_h a_g a_f d_g d_f 
##   1   2   3   3   4   5   6   7 
## 
## $meth
## [1] &quot;combNonOrth col&quot;</code></pre>
<p>Please see also the function <em>chooseGroupNames()</em> which may
help choosing among different types of patterns (ie low or high number
of groups of replicates) (see section <a href="#WorkingWithRedundantData">Working With Redundant Data</a>
(#WorkingWithRedundantData)).</p>
</div>
</div>
<div id="SearchForSimilarNumericValues" class="section level2">
<h2>Search For Similar (Numeric) Values</h2>
<p>This section addresses values that are not truly <em>identical</em>
but may differ only in the very last digit(s) and thus may be in a
pragmatic view get considered and treated as ‘about the same’. The
simplest approach would be to round values and then look for identical
values. The functions presented here (like
<code>checkSimValueInSer()</code>) offer this type of search in a
convenient way.</p>
<p>Of course the user must define a threshold for how similar may
retained as positive (in the the logical vector returned). With the
function <em>checkSimValueInSer()</em> this threshod must be given as <a href="https://simple.wikipedia.org/wiki/Parts_per_million">ppm</a>
(parts per million).</p>
<pre class="r"><code>va1 &lt;- c(4:7,7,7,7,7,8:10) + (1:11)/28600
checkSimValueInSer(va1, ppm=5)</code></pre>
<pre><code>##  [1] FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE</code></pre>
<pre class="r"><code>data.frame(va=sort(va1), simil=checkSimValueInSer(va1))</code></pre>
<pre><code>##           va simil
## 1   4.000035 FALSE
## 2   5.000070 FALSE
## 3   6.000105 FALSE
## 4   7.000140  TRUE
## 5   7.000175  TRUE
## 6   7.000210  TRUE
## 7   7.000245  TRUE
## 8   7.000280  TRUE
## 9   8.000315 FALSE
## 10  9.000350 FALSE
## 11 10.000385 FALSE</code></pre>
<div id="find-similar-numeric-values-of-two-columns-of-a-matrix" class="section level3">
<h3>Find Similar Numeric Values Of Two Columns Of A Matrix</h3>
<p>The search for similar values may be preformed as absolute distance
or as ‘ppm’ (as it is eg usual in proteomics when comparing measured and
theoretically expected mass).</p>
<pre class="r"><code>aA &lt;- c(11:17); bB &lt;- c(12.001,13.999); cC &lt;- c(16.2,8,9,12.5,15.9,13.5,15.7,14.1,5)
(cloMa &lt;- findCloseMatch(x=aA, y=cC, com=&quot;diff&quot;, lim=0.5, sor=FALSE))       </code></pre>
<pre><code>## $x2
##  y4 
## 0.5 
## 
## $x3
##   y4   y6 
## -0.5  0.5 
## 
## $x4
##   y6   y8 
## -0.5  0.1 
## 
## $x6
##   y1   y5   y7 
##  0.2 -0.1 -0.3</code></pre>
<p>The result of <em>findCloseMatch()</em> is a list organized by each
‘x’, telling all instances of ‘y’ found within the distance tolerance
given by <em>lim</em>. Using <code>closeMatchMatrix()</code> the result
obtained above, can be presented in a more convenient format for the
human eye.</p>
<pre class="r"><code># all matches (of 2d arg) to/within limit for each of 1st arg (&#39;x&#39;); &#39;y&#39; ..to 2nd arg = cC
# first let&#39;s display only one single closest/best hit
(maAa &lt;- closeMatchMatrix(cloMa, aA, cC, lim=TRUE))  #</code></pre>
<pre><code>##      id.aA aA id.cC   cC disToPred ppmToPred nByGrp isMin nBest
## [1,]     2 12     4 12.5      -0.5  -40000.0      1     1     1
## [2,]     3 13     4 12.5       0.5   40000.0      2     1     2
## [3,]     3 13     6 13.5      -0.5  -37037.0      2     1     2
## [4,]     4 14     8 14.1      -0.1   -7092.2      2     1     1
## [5,]     6 16     5 15.9       0.1    6289.3      3     1     1</code></pre>
<p>Using the argument <em>limitToBest=FALSE</em> we can display all
distances within the limits imposed, some values/points may occur
multiple times. For example, value number 4 of ‘cC’ (=12.5) or value
number 3 of ‘aA’ (=13) now occur multiple times…</p>
<pre class="r"><code>(maAa &lt;- closeMatchMatrix(cloMa, aA, cC, lim=FALSE,origN=TRUE))  #</code></pre>
<pre><code>##      id.aA aA id.cC   cC disToPred ppmToPred nByGrp isMin nBest
## [1,]     2 12     4 12.5      -0.5  -40000.0      1     1     1
## [2,]     3 13     4 12.5       0.5   40000.0      2     1     2
## [3,]     3 13     6 13.5      -0.5  -37037.0      2     1     2
## [4,]     4 14     6 13.5       0.5   37037.0      2     0     0
## [5,]     4 14     8 14.1      -0.1   -7092.2      2     1     1
## [6,]     6 16     7 15.7       0.3   19108.0      3     0     0
## [7,]     6 16     5 15.9       0.1    6289.3      3     1     1
## [8,]     6 16     1 16.2      -0.2  -12346.0      3     0     0</code></pre>
<pre class="r"><code>(maAa &lt;- closeMatchMatrix(cloMa, cbind(valA=81:87, aA), cbind(valC=91:99, cC), colM=2,
  colP=2, lim=FALSE))</code></pre>
<pre><code>## closeMatchMatrix : Reset argument &#39;origNa&#39; to FALSE since names of &#39;predMatr&#39; and/or &#39;measMatr&#39; result of formula and would be too long</code></pre>
<pre><code>##      id.pred valA aA id.meas valC   cC disToPred ppmToPred nByGrp isMin nBest
## [1,]       2   82 12       4   94 12.5      -0.5  -40000.0      1     1     1
## [2,]       3   83 13       4   94 12.5       0.5   40000.0      2     1     2
## [3,]       3   83 13       6   96 13.5      -0.5  -37037.0      2     1     2
## [4,]       4   84 14       6   96 13.5       0.5   37037.0      2     0     0
## [5,]       4   84 14       8   98 14.1      -0.1   -7092.2      2     1     1
## [6,]       6   86 16       7   97 15.7       0.3   19108.0      3     0     0
## [7,]       6   86 16       5   95 15.9       0.1    6289.3      3     1     1
## [8,]       6   86 16       1   91 16.2      -0.2  -12346.0      3     0     0</code></pre>
<pre class="r"><code>(maAa &lt;- closeMatchMatrix(cloMa, cbind(aA,valA=81:87), cC, lim=FALSE, deb=TRUE))  #</code></pre>
<pre><code>## closeMatchMatrix : .. xxidentToMatr2a</code></pre>
<pre><code>## closeMatchMatrix : .. xxidentToMatr2c</code></pre>
<pre><code>## closeMatchMatrix : Reset argument &#39;origNa&#39; to FALSE since names of &#39;predMatr&#39; and/or &#39;measMatr&#39; result of formula and would be too long</code></pre>
<pre><code>## closeMatchMatrix : .. xxidentToMatr2d</code></pre>
<pre><code>## closeMatchMatrix : .. xxidentToMatr2e</code></pre>
<pre><code>## closeMatchMatrix : .. xxidentToMatr2f</code></pre>
<pre><code>##      id.pred aA valA id.meas measMatr disToPred ppmToPred nByGrp isMin nBest
## [1,]       2 12   82       4     12.5      -0.5  -40000.0      1     1     1
## [2,]       3 13   83       4     12.5       0.5   40000.0      2     1     2
## [3,]       3 13   83       6     13.5      -0.5  -37037.0      2     1     2
## [4,]       4 14   84       6     13.5       0.5   37037.0      2     0     0
## [5,]       4 14   84       8     14.1      -0.1   -7092.2      2     1     1
## [6,]       6 16   86       7     15.7       0.3   19108.0      3     0     0
## [7,]       6 16   86       5     15.9       0.1    6289.3      3     1     1
## [8,]       6 16   86       1     16.2      -0.2  -12346.0      3     0     0</code></pre>
<pre class="r"><code>a2 &lt;- aA; names(a2) &lt;- letters[1:length(a2)];  c2 &lt;- cC; names(c2) &lt;- letters[10 +1:length(c2)]
(cloM2 &lt;- findCloseMatch(x=a2, y=c2, com=&quot;diff&quot;, lim=0.5, sor=FALSE)) </code></pre>
<pre><code>## $b
##   n 
## 0.5 
## 
## $c
##    n    p 
## -0.5  0.5 
## 
## $d
##    p    r 
## -0.5  0.1 
## 
## $f
##    k    o    q 
##  0.2 -0.1 -0.3</code></pre>
<pre class="r"><code>(maA2 &lt;- closeMatchMatrix(cloM2, predM=cbind(valA=81:87, a2),
  measM=cbind(valC=91:99, c2), colM=2, colP=2, lim=FALSE, asData=TRUE))</code></pre>
<pre><code>## closeMatchMatrix : Reset argument &#39;origNa&#39; to FALSE since names of &#39;predMatr&#39; and/or &#39;measMatr&#39; result of formula and would be too long</code></pre>
<pre><code>##     id.pred valA a2 id.meas valC   c2 disToPred ppmToPred nByGrp isMin nBest
## b         b   82 12       n   94 12.5      -0.5  -40000.0      1     1     1
## c_1       c   83 13       n   94 12.5       0.5   40000.0      2     1     2
## c_2       c   83 13       p   96 13.5      -0.5  -37037.0      2     1     2
## d_1       d   84 14       p   96 13.5       0.5   37037.0      2     0     0
## d_2       d   84 14       r   98 14.1      -0.1   -7092.2      2     1     1
## f_1       f   86 16       q   97 15.7       0.3   19108.0      3     0     0
## f_2       f   86 16       o   95 15.9       0.1    6289.3      3     1     1
## f_3       f   86 16       k   91 16.2      -0.2  -12346.0      3     0     0</code></pre>
<pre class="r"><code>(maA2 &lt;- closeMatchMatrix(cloM2, cbind(id=names(a2), valA=81:87,a2), cbind(id=names(c2),
  valC=91:99,c2), colM=3, colP=3, lim=FALSE, deb=FALSE)) </code></pre>
<pre><code>## closeMatchMatrix : Reset argument &#39;origNa&#39; to FALSE since names of &#39;predMatr&#39; and/or &#39;measMatr&#39; result of formula and would be too long</code></pre>
<pre><code>##   id.pred valA a2   id.meas valC c2     disToPred             ppmToPred nByGrp
## b &quot;b&quot;     &quot;82&quot; &quot;12&quot; &quot;n&quot;     &quot;94&quot; &quot;12.5&quot; &quot;-0.5&quot;                &quot;-40000&quot;  &quot;1&quot;   
## c &quot;c&quot;     &quot;83&quot; &quot;13&quot; &quot;n&quot;     &quot;94&quot; &quot;12.5&quot; &quot;0.5&quot;                 &quot;40000&quot;   &quot;2&quot;   
## c &quot;c&quot;     &quot;83&quot; &quot;13&quot; &quot;p&quot;     &quot;96&quot; &quot;13.5&quot; &quot;-0.5&quot;                &quot;-37037&quot;  &quot;2&quot;   
## d &quot;d&quot;     &quot;84&quot; &quot;14&quot; &quot;p&quot;     &quot;96&quot; &quot;13.5&quot; &quot;0.5&quot;                 &quot;37037&quot;   &quot;2&quot;   
## d &quot;d&quot;     &quot;84&quot; &quot;14&quot; &quot;r&quot;     &quot;98&quot; &quot;14.1&quot; &quot;-0.0999999999999996&quot; &quot;-7092.2&quot; &quot;2&quot;   
## f &quot;f&quot;     &quot;86&quot; &quot;16&quot; &quot;q&quot;     &quot;97&quot; &quot;15.7&quot; &quot;0.300000000000001&quot;   &quot;19108&quot;   &quot;3&quot;   
## f &quot;f&quot;     &quot;86&quot; &quot;16&quot; &quot;o&quot;     &quot;95&quot; &quot;15.9&quot; &quot;0.0999999999999996&quot;  &quot;6289.3&quot;  &quot;3&quot;   
## f &quot;f&quot;     &quot;86&quot; &quot;16&quot; &quot;k&quot;     &quot;91&quot; &quot;16.2&quot; &quot;-0.199999999999999&quot;  &quot;-12346&quot;  &quot;3&quot;   
##   isMin nBest
## b &quot;1&quot;   &quot;1&quot;  
## c &quot;1&quot;   &quot;2&quot;  
## c &quot;1&quot;   &quot;2&quot;  
## d &quot;0&quot;   &quot;0&quot;  
## d &quot;1&quot;   &quot;1&quot;  
## f &quot;0&quot;   &quot;0&quot;  
## f &quot;1&quot;   &quot;1&quot;  
## f &quot;0&quot;   &quot;0&quot;</code></pre>
</div>
<div id="find-similar-numeric-values-from-two-vectorsmatrixes" class="section level3">
<h3>Find Similar Numeric Values From Two Vectors/Matrixes</h3>
<p>For comparing two sets of data one may use
<code>findSimilarFrom2sets()</code>.</p>
<pre class="r"><code>aA &lt;- c(11:17); bB &lt;- c(12.001,13.999); cC &lt;- c(16.2,8,9,12.5,12.6,15.9,14.1)
aZ &lt;-  matrix(c(aA,aA+20), ncol=2, dimnames=list(letters[1:length(aA)],c(&quot;aaA&quot;,&quot;aZ&quot;)))
cZ &lt;-  matrix(c(cC,cC+20), ncol=2, dimnames=list(letters[1:length(cC)],c(&quot;ccC&quot;,&quot;cZ&quot;)))
findCloseMatch(cC, aA, com=&quot;diff&quot;, lim=0.5, sor=FALSE)</code></pre>
<pre><code>## $x1
##   y6 
## -0.2 
## 
## $x4
##   y2   y3 
## -0.5  0.5 
## 
## $x5
##  y3 
## 0.4 
## 
## $x6
##  y6 
## 0.1 
## 
## $x7
##   y4 
## -0.1</code></pre>
<pre class="r"><code>findSimilFrom2sets(aA, cC)</code></pre>
<pre><code>##      aA predMatr cC measMatr disToPred ppmToPred nByGrp isMin nBest
## [1,]  2       12  4     12.5      -0.5  -40000.0      1     1     1
## [2,]  3       13  4     12.5       0.5   40000.0      2     0     0
## [3,]  3       13  5     12.6       0.4   31746.0      2     1     1
## [4,]  4       14  7     14.1      -0.1   -7092.2      1     1     1
## [5,]  6       16  6     15.9       0.1    6289.3      2     1     1
## [6,]  6       16  1     16.2      -0.2  -12346.0      2     0     0</code></pre>
<pre class="r"><code>findSimilFrom2sets(cC, aA)</code></pre>
<pre><code>##      cC predMatr aA measMatr disToPred ppmToPred nByGrp isMin nBest
## [1,]  1     16.2  6       16       0.2   12500.0      1     1     1
## [2,]  4     12.5  2       12       0.5   41667.0      2     1     2
## [3,]  4     12.5  3       13      -0.5  -38462.0      2     1     2
## [4,]  5     12.6  3       13      -0.4  -30769.0      1     1     1
## [5,]  6     15.9  6       16      -0.1   -6250.0      1     1     1
## [6,]  7     14.1  4       14       0.1    7142.9      1     1     1</code></pre>
<pre class="r"><code>findSimilFrom2sets(aA, cC, best=FALSE)</code></pre>
<pre><code>##      aA predMatr cC measMatr disToPred ppmToPred nByGrp isMin nBest
## [1,]  2       12  4     12.5      -0.5  -40000.0      1     1     1
## [2,]  3       13  4     12.5       0.5   40000.0      2     0     0
## [3,]  3       13  5     12.6       0.4   31746.0      2     1     1
## [4,]  4       14  7     14.1      -0.1   -7092.2      1     1     1
## [5,]  6       16  6     15.9       0.1    6289.3      2     1     1
## [6,]  6       16  1     16.2      -0.2  -12346.0      2     0     0</code></pre>
<pre class="r"><code>findSimilFrom2sets(aA, cC, comp=&quot;ppm&quot;, lim=5e4)</code></pre>
<pre><code>##      aA predMatr cC measMatr disToPred ppmToPred nByGrp isMin nBest
## [1,]  2       12  4     12.5      -0.5  -40000.0      1     1     1
## [2,]  3       13  4     12.5       0.5   40000.0      2     0     0
## [3,]  3       13  5     12.6       0.4   31746.0      2     1     1
## [4,]  4       14  7     14.1      -0.1   -7092.2      1     1     1
## [5,]  6       16  6     15.9       0.1    6289.3      2     1     1
## [6,]  6       16  1     16.2      -0.2  -12346.0      2     0     0
## [7,]  7       17  1     16.2       0.8   49383.0      1     1     1</code></pre>
<pre class="r"><code>findSimilFrom2sets(aA, cC, comp=&quot;ppm&quot;, lim=9e4, bestO=FALSE)</code></pre>
<pre><code>##       aA predMatr cC measMatr disToPred ppmToPred nByGrp isMin nBest
##  [1,]  2       12  4     12.5      -0.5  -40000.0      2     1     1
##  [2,]  2       12  5     12.6      -0.6  -47619.0      3     0     0
##  [3,]  3       13  4     12.5       0.5   40000.0      2     0     0
##  [4,]  3       13  5     12.6       0.4   31746.0      3     1     1
##  [5,]  3       13  7     14.1      -1.1  -78014.0      3     0     0
##  [6,]  4       14  7     14.1      -0.1   -7092.2      1     1     1
##  [7,]  5       15  7     14.1       0.9   63830.0      3     1     2
##  [8,]  5       15  6     15.9      -0.9  -56604.0      3     1     2
##  [9,]  5       15  1     16.2      -1.2  -74074.0      2     0     0
## [10,]  6       16  6     15.9       0.1    6289.3      3     0     0
## [11,]  6       16  1     16.2      -0.2  -12346.0      2     0     0
## [12,]  7       17  6     15.9       1.1   69182.0      2     1     0
## [13,]  7       17  1     16.2       0.8   49383.0      2     1     2</code></pre>
<pre class="r"><code># below: find fewer &#39;best matches&#39; since search window larger (ie more good hits compete !)
findSimilFrom2sets(aA, cC, comp=&quot;ppm&quot;, lim=9e4, bestO=TRUE)</code></pre>
<pre><code>##      aA predMatr cC measMatr disToPred ppmToPred nByGrp isMin nBest
## [1,]  2       12  4     12.5      -0.5  -40000.0      2     1     1
## [2,]  3       13  5     12.6       0.4   31746.0      3     1     1
## [3,]  4       14  7     14.1      -0.1   -7092.2      1     1     1
## [4,]  5       15  7     14.1       0.9   63830.0      3     1     2
## [5,]  5       15  6     15.9      -0.9  -56604.0      3     1     2
## [6,]  7       17  6     15.9       1.1   69182.0      2     1     0
## [7,]  7       17  1     16.2       0.8   49383.0      2     1     2</code></pre>
</div>
<div id="fuse-previously-identified-pairs-to-clusters" class="section level3">
<h3>Fuse Previously Identified Pairs To ‘Clusters’</h3>
<p>When you have already identified the closest neighbour of a set of
values, you may want to re-organize/fuse such pairs to a given number of
total clusters (using <code>fusePairs()</code>).</p>
<pre class="r"><code>(daPa &lt;- matrix(c(1:5,8,2:6,9), ncol=2))</code></pre>
<pre><code>##      [,1] [,2]
## [1,]    1    2
## [2,]    2    3
## [3,]    3    4
## [4,]    4    5
## [5,]    5    6
## [6,]    8    9</code></pre>
<pre class="r"><code>fusePairs(daPa, maxFuse=4)</code></pre>
<pre><code>## 1 2 3 4 4 5 6 8 9 
## 1 1 1 1 2 2 2 3 3</code></pre>
</div>
<div id="eliminate-close-overlapping-points-in-bivariate-x-y-space" class="section level3">
<h3>Eliminate Close (Overlapping) Points (In Bivariate x &amp; y
Space)</h3>
<p>When visualizing larger data-sets in an x&amp;y space one may find
many points overlapping when their values are almost the same.<br />
The function <code>elimCloseCoord()</code> aims to do reduce a bivariate
data-set to ‘non-overlapping’ points, somehow similar to human
perception.</p>
<pre class="r"><code>da1 &lt;- matrix(c(rep(0:4,5),0.01,1.1,2.04,3.07,4.5), ncol=2); da1[,1] &lt;- da1[,1]*99; head(da1)</code></pre>
<pre><code>##      [,1] [,2]
## [1,]    0    0
## [2,]   99    1
## [3,]  198    2
## [4,]  297    3
## [5,]  396    4
## [6,]    0    0</code></pre>
<pre class="r"><code>elimCloseCoord(da1)</code></pre>
<pre><code>## elimCloseCoord :  reducing &#39;x&#39; from 15 to 7 lines</code></pre>
<pre><code>##    [,1] [,2]
## 1     0  0.0
## 2    99  1.0
## 3   198  2.0
## 4   297  3.0
## 5   396  4.0
## 12   99  1.1
## 15  396  4.5</code></pre>
</div>
<div id="mode-of-continuous-data" class="section level3">
<h3>Mode Of (Continuous) Data</h3>
<p>Looking for the <em>mode</em> is rather easy with counting data, the
result of <em>table()</em> will get you there quickly. However, with
continuous data the mode may be more tricky to defne and identify.
Intuitively most people consider the mode asthe peak of a density
estimation (which remains to be defined and estimated). With continuous
data most frequent (precise) value may be quite different/distant to the
most dense region of data. The function <code>stableMode()</code>
presented here has different modes of operation, at this point there is
no clear rule which mode may perform most satisfactory in different
situations.</p>
<pre class="r"><code>set.seed(2012); dat &lt;- round(c(rnorm(120,0,1.2), rnorm(80,0.8,0.6), rnorm(25,-0.6,0.05), runif(200)),3)
dat &lt;- dat[which(dat &gt; -2 &amp; dat &lt;2)]
stableMode(dat)</code></pre>
<pre><code>## stableMode : Method=&#39;density&#39;,  length of x =406, &#39;bandw&#39; has been set to 28</code></pre>
<pre><code>##   221 
## 0.477</code></pre>
<p>Now we can try to show on a plot :</p>
<pre class="r"><code>layout(1:2)
plot(1:length(dat), sort(dat), type=&quot;l&quot;, main=&quot;Sorted Values&quot;, xlab=&quot;rank&quot;, las=1)
abline(h=stableMode(dat, silent=TRUE), lty=2,col=2)
legend(&quot;topleft&quot;,c(&quot;stableMode&quot;), text.col=2, col=2, lty=2, lwd=1, seg.len=1.2, cex=0.8, xjust=0, yjust=0.5) 


plot(density(dat, kernel=&quot;gaussian&quot;, adjust=0.7), xlab=&quot;Value of dat&quot;, main=&quot;Density Estimate Plot&quot;)
useCol &lt;- c(&quot;red&quot;,&quot;green&quot;,&quot;blue&quot;,&quot;grey55&quot;)
legend(&quot;topleft&quot;,c(&quot;dens&quot;,&quot;binning&quot;,&quot;BBmisc&quot;,&quot;allModes&quot;), text.col=useCol, col=useCol,
  lty=2, lwd=1, seg.len=1.2, cex=0.8, xjust=0, yjust=0.5) 
abline(v=stableMode(dat, method=&quot;dens&quot;, silent=TRUE), lty=2, col=&quot;red&quot;, lwd=2)
abline(v=stableMode(dat, method=&quot;binning&quot;, silent=TRUE), lty=2, col=&quot;green&quot;)
abline(v=stableMode(dat, method=&quot;BBmisc&quot;, silent=TRUE), lty=2, col=&quot;blue&quot;)  </code></pre>
<pre><code>## Loading required namespace: BBmisc</code></pre>
<pre class="r"><code>abline(v=stableMode(dat, method=&quot;allModes&quot;), lty=2, col=&quot;grey55&quot;)  </code></pre>
<p><img src="data:image/png;base64,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" width="864" style="display: block; margin: auto;" /></p>
<p>Please note, that plotting data modelled via a Kernell function (as
above) also relies on strong hypothesis which may not be well justified
in a number of cases ! For this reason, the <em>sorted values</em> were
plotted, too.</p>
<p>As you can see from this example above, looking for the most frequent
exact value may not be a perfect choice for continous data. In this
example the method <em>‘allModes’</em> (ie the multiple instances of
most frequent exact values) gave partially usable results (dashed grey
lines), due to the rounding to 3 digits. As you can see in the example
above, the method <em>‘allModes’</em> may give multiple ties ! More
rounding will make to data more discrete and ultimately ressemble
cunting data. However, with rounding some of the finer
resolution/details will get lost.</p>
</div>
<div id="most-frequently-occuring-value-traditional-mode" class="section level3">
<h3>Most Frequently Occuring Value (traditional mode)</h3>
<p>The function <code>stableMode()</code> can also be used to locate
<em>the</em> most frequently occuring exact value of numeric or
character vectors. As we just saw at the end of the previous example,
the argument <em>method=“allModes”</em> allows finding all ties (if
present).</p>
<pre class="r"><code>set.seed(2021)
x &lt;- sample(letters, 50000, replace=TRUE)
stableMode(dat, method=&quot;mode&quot;)</code></pre>
<pre><code>## [1] 0.173</code></pre>
<pre class="r"><code>stableMode(dat, method=&quot;allModes&quot;)</code></pre>
<pre><code>## [1] 0.173 0.629 0.676</code></pre>
</div>
</div>
<div id="Text-Manipulations" class="section level2">
<h2>Text-Manipulations</h2>
<p>There are several packages offering interesting functions for
manipulating text. Here are a few functions to complement these.</p>
<div id="protect-special-characters" class="section level3">
<h3>Protect Special Characters</h3>
<p>The function <code>protectSpecChar()</code> allows protecting the
majority of special characters which may influence the outcome of
<em>grep()</em> and related functions so thay they can be used easier in
searches using <em>grep()</em> or alike.</p>
<pre class="r"><code>aa &lt;- c(&quot;abc&quot;,&quot;abcde&quot;,&quot;ab.c&quot;,&quot;ab.c.e&quot;,&quot;ab*c&quot;,&quot;ab\\d&quot;)
grepl(&quot;b.&quot;, aa)             # all TRUE</code></pre>
<pre><code>## [1] TRUE TRUE TRUE TRUE TRUE TRUE</code></pre>
<pre class="r"><code>grepl(protectSpecChar(&quot;b.&quot;), aa)</code></pre>
<pre><code>## [1] FALSE FALSE  TRUE  TRUE FALSE FALSE</code></pre>
</div>
<div id="trimming-redundant-text" class="section level3">
<h3>Trimming Redundant Text</h3>
<p>Automatic annotation has the tendency to concatenate many parameters
into a single names. The function <code>trimRedundText()</code> was
designed to allow trimming redundant text from left and/or right side of
a character-vector (when the same portion of text appears in
<em>each</em> element). However, as in some cases (like the first
element of the example below) nothing would remain, it is possible to
define a <em>minimum</em> width for the remaining/resulting text.</p>
<pre class="r"><code>txt1 &lt;- c(&quot;abcd&quot;,&quot;abcde&quot;,&quot;abcdefg&quot;,&quot;abcdE&quot;,NA,&quot;abcdEF&quot;)
trimRedundText(txt1)</code></pre>
<pre><code>## [1] &quot;d&quot;    &quot;de&quot;   &quot;defg&quot; &quot;dE&quot;   NA     &quot;dEF&quot;</code></pre>
</div>
<div id="removing-redundantshared-words" class="section level3">
<h3>Removing Redundant/Shared Words</h3>
<p>A more gentle way to make text non-redundant consists in removing
redundant text isporposed by the function <code>rmSharedWords()</code>.
Multiple separators may be used (and combined) to specify ‘words’, a
minimum length of what mat be considered a word can be defined, too
(default at min 2 characters). For example, this can be used to make
column-names shorter and more precise.</p>
<pre class="r"><code>txt2 &lt;- c(&quot;abc d&quot;,&quot;abc de&quot;,&quot;abc defg&quot;,&quot;abc dE&quot;,NA,&quot;abc dEF&quot;)
rmSharedWords(txt2)</code></pre>
<pre><code>## [1] &quot;d&quot;    &quot;de&quot;   &quot;defg&quot; &quot;dE&quot;   NA     &quot;dEF&quot;</code></pre>
<p>In contrast to trimRedundText() numeric parts may remain ‘intact’,
see example below.</p>
<pre class="r"><code>txt3 &lt;- c(&quot;ab 100 m&quot;,&quot;ab 120 m&quot;,&quot;ab 1000 m&quot;)
trimRedundText(txt3)</code></pre>
<pre><code>## [1] &quot;0&quot;  &quot;2&quot;  &quot;00&quot;</code></pre>
<pre class="r"><code>rmSharedWords(txt3)</code></pre>
<pre><code>## [1] &quot;100_m&quot;  &quot;120_m&quot;  &quot;1000_m&quot;</code></pre>
</div>
<div id="extract-common-part-of-text" class="section level3">
<h3>Extract Common Part Of Text</h3>
<p>The original idea was to do something resembling the inverse process
of trimming redundant text (example above), but this time to discard the
variable text.</p>
<p>In the end this is not as trivial when ‘common’ or ‘redundant’ text
is not at the beginning or end of a chain of characters. In particular
with very large text this is an active field of research (eg for
sequence alignment). The function presented here is a very light-weight
solution designed for smaller and simple settings, like inspecting
column-names. Furthermore, the function <code>keepCommonText()</code>
only reports the first (longest) hit. So, when there are multiple
conserved ‘words’ of equal length, only the first of them will be
identified.</p>
<p>When setting the argument ‘hiResol=FALSE’ this function has an option
to decrease the resulution of searching, which in turn increases the
speed, howevere, at cost of missing the optimal solution. In this case
the resultant chain of characters should be inspected if it can be
further extended/optimized.</p>
<p>With terminal common text :</p>
<pre class="r"><code>txt1 &lt;- c(&quot;abcd&quot;,&quot;abcde&quot;,&quot;abcdefg&quot;,&quot;abcdE&quot;,NA,&quot;abcdEF&quot;)
trimRedundText(txt1, side=&quot;left&quot;)         # remove redundant </code></pre>
<pre><code>## [1] &quot;d&quot;    &quot;de&quot;   &quot;defg&quot; &quot;dE&quot;   NA     &quot;dEF&quot;</code></pre>
<pre class="r"><code>keepCommonText(txt1, side=&quot;terminal&quot;)     # keep redundant</code></pre>
<pre><code>## [1] &quot;abc&quot;</code></pre>
<pre class="r"><code>keepCommonText(txt1, side=&quot;center&quot;)       # computationally easier   </code></pre>
<pre><code>## [1] &quot;ab&quot;</code></pre>
<p>With internal coomon text:</p>
<pre class="r"><code>txt2 &lt;- c(&quot;abcd_abc_kjh&quot;, &quot;bcd_abc123&quot;, &quot;cd_abc_po&quot;)
keepCommonText(txt2, side=&quot;center&quot;)       </code></pre>
<pre><code>## [1] &quot;cd_abc&quot;</code></pre>
</div>
<div id="manipulating-enumerator-extensions" class="section level3">
<h3>Manipulating Enumerator-Extensions</h3>
<p>Human operators may have many ways to write enumerators like
‘xx_sample_1’, ‘xx_Sample_2’, ‘xx_s3’, ‘xx_4’, etc. Many times you may
find such text as names or column-names for measures underneith.</p>
<p>The functions presented below will work only if <em>consistent
numerators</em>, ie (text +) digit-character(s) are at the end of all
character-strings to be treated.</p>
<p>Please note, that with large vectors testing/checking a larger panel
of enumerator-abreviations may result in slower performance. In cases of
such larger data-sets it may be more effective to first study the data
and then run simple subsitions using <em>sub()</em> targeted for this
very case.</p>
<div id="removemodify-enumerators" class="section level4">
<h4>Remove/Modify Enumerators</h4>
<p>The aim of this function consists in identifying a <em>common</em>
pattern for terminal enumeratos (ie at end of words/character strings)
and to subsequently modify or remove them. As separator-symbols and
separator-words are given indedently all combinations thereof may be
tested. Furthermore the user has the choice to (automatically) all
truncated versions of separator-words (eg <em>Sam</em> instead of
<em>Sample</em>).</p>
<p>As basic setting <code>rmEnumeratorName()</code> allows to identify
and then modify a <em>common</em> terminal enumerator from all elements
of a character string :</p>
<pre class="r"><code>xx &lt;- c(&quot;hg_Re1&quot;,&quot;hjRe2_Re2&quot;,&quot;hk-Re3_Re33&quot;)
rmEnumeratorName(xx)</code></pre>
<pre><code>## [1] &quot;hg1&quot;      &quot;hjRe22&quot;   &quot;hk-Re333&quot;</code></pre>
<pre class="r"><code>rmEnumeratorName(xx, newSep=&quot;--&quot;)</code></pre>
<pre><code>## [1] &quot;hg--1&quot;      &quot;hjRe2--2&quot;   &quot;hk-Re3--33&quot;</code></pre>
<pre class="r"><code>rmEnumeratorName(xx, incl=&quot;anyCase&quot;)</code></pre>
<pre><code>## rmEnumeratorName : No conistent enumerator+digit combination found; nothing to do ..</code></pre>
<pre><code>## [1] &quot;hg_Re1&quot;      &quot;hjRe2_Re2&quot;   &quot;hk-Re3_Re33&quot;</code></pre>
<p>Furthermore, this function allows scanning a matrix of text-data and
to perform similar operations to the <em>first</em> column found
containing a <em>common</em> terminal enumerator.</p>
<pre class="r"><code>xy &lt;- cbind(a=11:13, b=c(&quot;11#11&quot;,&quot;2_No2&quot;,&quot;333_samp333&quot;), c=xx)
rmEnumeratorName(xy)</code></pre>
<pre><code>##      a    b             c         
## [1,] &quot;11&quot; &quot;11#11&quot;       &quot;hg1&quot;     
## [2,] &quot;12&quot; &quot;2_No2&quot;       &quot;hjRe22&quot;  
## [3,] &quot;13&quot; &quot;333_samp333&quot; &quot;hk-Re333&quot;</code></pre>
<pre class="r"><code>rmEnumeratorName(xy,incl=c(&quot;anyCase&quot;,&quot;trim2&quot;,&quot;rmEnumL&quot;))</code></pre>
<pre><code>## $dat
##      a    b             c       
## [1,] &quot;11&quot; &quot;11#11&quot;       &quot;hg&quot;    
## [2,] &quot;12&quot; &quot;2_No2&quot;       &quot;hjRe2&quot; 
## [3,] &quot;13&quot; &quot;333_samp333&quot; &quot;hk-Re3&quot;
## 
## $column
## [1] 3
## 
## $pattern
## [1] &quot;_Re&quot;</code></pre>
<p>If you which to remove/subsitute mutiple types of enumerators the
function must be run independently, see last example below.</p>
<pre class="r"><code>xz &lt;- cbind(a=11:13, b=c(&quot;23#11&quot;,&quot;4#2&quot;,&quot;567#333&quot;), c=xx)
apply(xz, 2, rmEnumeratorName, sepEnum=c(&quot;&quot;,&quot;_&quot;), newSep=&quot;_&quot;, silent=TRUE)</code></pre>
<pre><code>##      a    b         c          
## [1,] &quot;11&quot; &quot;23_11&quot;   &quot;hg_1&quot;     
## [2,] &quot;12&quot; &quot;4_2&quot;     &quot;hjRe2_2&quot;  
## [3,] &quot;13&quot; &quot;567_333&quot; &quot;hk-Re3_33&quot;</code></pre>
</div>
<div id="unify-enumerators" class="section level4">
<h4>Unify Enumerators</h4>
<p>The (slightly older) function <code>unifyEnumerator()</code> offers
less options, in particular the potential separator-words must be given
explicitly, only lower/upper-case may be kept flexible.</p>
<pre class="r"><code>unifyEnumerator(c(&quot;ab-1&quot;,&quot;ab-2&quot;,&quot;c-3&quot;))</code></pre>
<pre><code>## [1] &quot;ab-&quot; &quot;ab-&quot; &quot;c-&quot;</code></pre>
<pre class="r"><code>unifyEnumerator(c(&quot;ab-R1&quot;,&quot;ab-R2&quot;,&quot;c-R3&quot;))</code></pre>
<pre><code>## [1] &quot;ab-R&quot; &quot;ab-R&quot; &quot;c-R&quot;</code></pre>
<pre class="r"><code>unifyEnumerator(c(&quot;ab-1&quot;,&quot;c3-2&quot;,&quot;dR3&quot;), stringentMatch=FALSE)</code></pre>
<pre><code>## [1] &quot;ab-&quot; &quot;c3-&quot; &quot;dR&quot;</code></pre>
</div>
</div>
<div id="findchoose-column-most-likely-containing-sample-names" class="section level3">
<h3>Find/Choose Column Most Likely Containing Sample-Names</h3>
<p>When information about a collection of samples is given in a table,
the function <code>unifyEnumerator()</code> was designed to find the
column most likely containg sample-names and it derives then the
structure of groups of replicates by removing terminal enumerators from
sample-names. Initial tables (as frequently found in transcriptomics and
proteomics) may not have consistent schemes of naming columns (due to
human annotators not using controlled vocabulary) and may contain
additional columns with redundant information (elements/conditions that
were kept constant for all samples.</p>
<p>Internally this function uses <em>rmSharedWords()</em> to further
simplify resultant names.</p>
<pre class="r"><code>(mat &lt;- cbind(a=letters[1:6], b=paste(rep(c(&quot;b&quot;,&quot;B&quot;), each=3), 1:3), c=rep(1,6), 
  d=gl(3,2), e=rep(c(&quot;e&quot;,&quot;E&quot;),3), f=paste(rep(c(&quot;F&quot;,&quot;f&quot;,&quot;ff&quot;), each=2), 1:2)))</code></pre>
<pre><code>##      a   b     c   d   e   f     
## [1,] &quot;a&quot; &quot;b 1&quot; &quot;1&quot; &quot;1&quot; &quot;e&quot; &quot;F 1&quot; 
## [2,] &quot;b&quot; &quot;b 2&quot; &quot;1&quot; &quot;1&quot; &quot;E&quot; &quot;F 2&quot; 
## [3,] &quot;c&quot; &quot;b 3&quot; &quot;1&quot; &quot;2&quot; &quot;e&quot; &quot;f 1&quot; 
## [4,] &quot;d&quot; &quot;B 1&quot; &quot;1&quot; &quot;2&quot; &quot;E&quot; &quot;f 2&quot; 
## [5,] &quot;e&quot; &quot;B 2&quot; &quot;1&quot; &quot;3&quot; &quot;e&quot; &quot;ff 1&quot;
## [6,] &quot;f&quot; &quot;B 3&quot; &quot;1&quot; &quot;3&quot; &quot;E&quot; &quot;ff 2&quot;</code></pre>
<pre class="r"><code>chooseGroupNames(mat, method=&quot;median&quot;)         # col 2 (b/B)</code></pre>
<pre><code>## b 1 b 2 b 3 B 1 B 2 B 3 
## &quot;b&quot; &quot;b&quot; &quot;b&quot; &quot;B&quot; &quot;B&quot; &quot;B&quot;</code></pre>
<pre class="r"><code>chooseGroupNames(mat, method=&quot;median&quot;, fullReport=TRUE) </code></pre>
<pre><code>## $group
## b 1 b 2 b 3 B 1 B 2 B 3 
## &quot;b&quot; &quot;b&quot; &quot;b&quot; &quot;B&quot; &quot;B&quot; &quot;B&quot; 
## 
## $sampleNames
## [1] &quot;b 1&quot; &quot;b 2&quot; &quot;b 3&quot; &quot;B 1&quot; &quot;B 2&quot; &quot;B 3&quot;
## 
## $col
## b 
## 2</code></pre>
<pre class="r"><code>chooseGroupNames(mat, method=&quot;min&quot;)            # col 2 (b/B)</code></pre>
<pre><code>## b 1 b 2 b 3 B 1 B 2 B 3 
## &quot;b&quot; &quot;b&quot; &quot;b&quot; &quot;B&quot; &quot;B&quot; &quot;B&quot;</code></pre>
<pre class="r"><code>chooseGroupNames(mat, method=&quot;max&quot;)            # col 6 (F/f/ff)</code></pre>
<pre><code>##  F 1  F 2  f 1  f 2 ff 1 ff 2 
##  &quot;F&quot;  &quot;F&quot;  &quot;f&quot;  &quot;f&quot; &quot;ff&quot; &quot;ff&quot;</code></pre>
<pre class="r"><code>chooseGroupNames(mat, method=&quot;max&quot;, asUnique=FALSE) # col 1 (a..)</code></pre>
<pre><code>##   a   b   c   d   e   f 
## &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot;</code></pre>
<p>Please see also the function <em>replicateStructure()</em> which
allows inspecting patterns of replicating elements (see section <a href="#ComparingGlobalPatterns">Comparing Global Patterns</a>
(#ComparingGlobalPatterns)).</p>
</div>
<div id="find-common-unit" class="section level3">
<h3>Find Common Unit</h3>
<p>The function <code>checkUnitPrefix</code> aims to find a
unit-abbreviation or -name occurring in all elements of a
character-vector. The unit name may be preceeded by different decimal
prefixes (eg ‘k’,‘M’, see argument <em>pref</em>) which may vary within
the vector. By default some common SI-units will be searched, see
argument <em>unit</em>.</p>
<pre class="r"><code>x1 &lt;- c(&quot;10fg WW&quot;,&quot;xx 10fg 3pW&quot;,&quot; 1pg 2.0W&quot;)
checkUnitPrefix(x1)</code></pre>
<pre><code>## [1] &quot;g&quot;</code></pre>
<pre class="r"><code>## different separators between digit and prefix:
x2 &lt;- c(&quot;10fg WW&quot;,&quot;xx 8_fg 3pW&quot;,&quot; 1 pg-2.0W&quot;)
checkUnitPrefix(x2, stringentSearch=TRUE)</code></pre>
<pre><code>## NULL</code></pre>
<pre class="r"><code>checkUnitPrefix(x2, stringentSearch=FALSE)</code></pre>
<pre><code>## [1] &quot;g&quot;</code></pre>
</div>
<div id="adjust-decimal-prefixes-and-extact-numericunit-part" class="section level3">
<h3>Adjust Decimal Prefixes And Extact Numeric+Unit Part</h3>
<p>The function <code>adjustUnitPrefix()</code> provides help extracting
the numeric part of character vectors and allows adjusting to a single
million-unit type. This can be used to convert a vector of mixed
prefixes like ‘z’,‘a’,‘f’,‘p’,‘n’,‘u’ and ‘m’ (note: the ‘u’ is used for
‘micro’). The output is a character vector with all prefix+unit
expressions adjusted to use the same prefix everywhere
(numeric+separator+prefix+unit). Redundant additional text may get
(optionally) trimmed (see argument <em>returnType=“trim”</em>), the
numeric part names + unit is give in the names.</p>
<p>Please note that decimal/comma digits will not be recognized
properly, the function may/will consider the decimal sign as just
another separator (as ‘.’ is part af the default selection of
separators).</p>
<pre class="r"><code>adjustUnitPrefix(c(&quot;10.psec&quot;, &quot;2 fsec&quot;), unit=&quot;sec&quot;)</code></pre>
<pre><code>##        10000            2 
## &quot;10000 fsec&quot;     &quot;2 fsec&quot;</code></pre>
<p>Using the argument <em>returnType</em> you can choose how much of the
remaining text should be shown.</p>
<pre class="r"><code>x2 &lt;- c(&quot;abCc 500_nmol ABC&quot;, &quot;abEe5_umol&quot;, &quot;&quot;, &quot;abFF_100_nmol_G&quot;, &quot;abGg 2_mol&quot;, &quot;abH.1 mmol&quot;)
rbind( adjustUnitPrefix(x2, unit=&quot;mol&quot;, returnType=&quot;allText&quot;) , 
  adjustUnitPrefix(x2, unit=&quot;mol&quot;, returnType=&quot;trim&quot;),
  adjustUnitPrefix(x2, unit=&quot;mol&quot;, returnType=&quot;&quot;))</code></pre>
<pre><code>## adjustUnitPrefix : Ignoring 1 entries not containing &#39;mol&#39; 
## adjustUnitPrefix : Ignoring 1 entries not containing &#39;mol&#39; 
## adjustUnitPrefix : Ignoring 1 entries not containing &#39;mol&#39;</code></pre>
<pre><code>##      500                   5000              &lt;NA&gt; 100                
## [1,] &quot;abCc _500_nmol_ ABC&quot; &quot;abEe_5000_nmol_&quot; NA   &quot;abFF__100_nmol__G&quot;
## [2,] &quot;Cc _500_nmol_&quot;       &quot;Ee_5000_nmol_&quot;   NA   &quot;FF__100_nmol_&quot;    
## [3,] &quot;500_nmol&quot;            &quot;5000_nmol&quot;       NA   &quot;100_nmol&quot;         
##      2e+09               1e+06             
## [1,] &quot;abGg _2e+09_nmol_&quot; &quot;abH._1e+06_nmol_&quot;
## [2,] &quot;Gg _2e+09_nmol_&quot;   &quot;H._1e+06_nmol_&quot;  
## [3,] &quot;2e+09_nmol&quot;        &quot;1e+06_nmol&quot;</code></pre>
<p>If the <em>unit</em> -name is not knonw in advance, you can try to
figure out. In the example it is shown that the unit-name can be
determined using the function <em>checkUnitPrefix()</em>.</p>
<pre class="r"><code>x3 &lt;- c(&quot;2.psec abc&quot;,&quot;300 fsec etc&quot;, &quot;34 5fsec&quot;)
adjustUnitPrefix(x3, unit=checkUnitPrefix(x3))</code></pre>
<pre><code>##           2000            300              5 
## &quot;2000fsec abc&quot;  &quot;300fsec etc&quot;     &quot;34 5fsec&quot;</code></pre>
</div>
<div id="merging-multiple-named-vectors-to-matrix" class="section level3">
<h3>Merging Multiple Named Vectors To Matrix</h3>
<p>The function <code>mergeVectors()</code> allows merging for multiple
named vectors (each element needs to be named). Basically, all elements
carrying the same name across different input-vectors will be aligned in
the same column of the output (input-vectors appear as lines). Different
to <em>merge()</em> which allows merging only 2 data.frames, here
multiple vectors may be merge at once.</p>
<pre class="r"><code>x1 &lt;- c(a=1, b=11, c=21)
x2 &lt;- c(b=12, c=22, a=2)
x3 &lt;- c(a=3, d=43)
mergeVectors(vect1=x1, vect2=x2, vect3=x3)</code></pre>
<pre><code>##       a  b  c  d
## vect1 1 11 21 NA
## vect2 2 12 22 NA
## vect3 3 NA NA 43</code></pre>
<pre class="r"><code>mergeVectors(vect1=x1, vect2=x2, vect3=x3, inclInfo=TRUE)   # return list with additional info</code></pre>
<pre><code>## mergeVectors :  Vectors must be longer than 0 and must have names on each element for merging; omit 1 (out of 4) vector(s)</code></pre>
<pre><code>##       a  b  c  d
## vect1 1 11 21 NA
## vect2 2 12 22 NA
## vect3 3 NA NA 43</code></pre>
<p>In the example below we’ll add another vector <em>without</em> named
elements. As you can see a message tells the this vector was been
ignored/omitted.</p>
<pre class="r"><code>x4 &lt;- 41:44            # no names - not conform for merging and will be ignored
mergeVectors(x1, x2, x3, x4)</code></pre>
<pre><code>## mergeVectors :  Vectors must be longer than 0 and must have names on each element for merging; omit 1 (out of 4) vector(s)</code></pre>
<pre><code>##     a  b  c  d
## x.1 1 11 21 NA
## x.2 2 12 22 NA
## x.3 3 NA NA 43</code></pre>
</div>
<div id="match-all-lines-of-matrix-to-reference-note" class="section level3">
<h3>Match All Lines of Matrix To Reference Note</h3>
<p>This function allows adjusting the order of lines of a matrix to a
reference character-vector , even when initial direct matching of
character-strings using is not possible/successful. In this case,
various variants of using will be used to see if unambiguous matching is
possible of characteristic parts of the text. All columns of will be
tested an the column giving the best results will be used.</p>
<pre class="r"><code>## Note : columns b and e allow non-ambigous match, not all elements of e are present in a
mat0 &lt;- cbind(a=c(&quot;mvvk&quot;,&quot;axxd&quot;,&quot;bxxd&quot;,&quot;vv&quot;),b=c(&quot;iwwy&quot;,&quot;iyyu&quot;,&quot;kvvh&quot;,&quot;gxx&quot;), c=rep(9,4),
  d=c(&quot;hgf&quot;,&quot;hgf&quot;,&quot;vxc&quot;,&quot;nvnn&quot;), e=c(&quot;_vv_&quot;,&quot;_ww_&quot;,&quot;_xx_&quot;,&quot;_yy_&quot;))
matchMatrixLinesToRef(mat0[,1:4], ref=mat0[,5])</code></pre>
<pre><code>##      ref   
## [1,] &quot;_vv_&quot;
## [2,] &quot;_ww_&quot;
## [3,] &quot;_xx_&quot;
## [4,] &quot;_yy_&quot;</code></pre>
<pre class="r"><code>matchMatrixLinesToRef(mat0[,1:4], ref=mat0[1:3,5], inclInfo=TRUE)</code></pre>
<pre><code>## $mat
##      ref   
## [1,] &quot;_vv_&quot;
## [2,] &quot;_ww_&quot;
## [3,] &quot;_xx_&quot;
## 
## $byColumn
## [1] 2
## 
## $newOrder
## vv ww xx 
##  3  1  4 
## 
## $method
## [1] &quot;grep of ref after trimming redundant text&quot;</code></pre>
<pre class="r"><code>matchMatrixLinesToRef(mat0[,-2], ref=mat0[,2], inclInfo=TRUE)   # needs &#39;reverse grep&#39;</code></pre>
<pre><code>## $mat
##      a      c   d      e      ref   
## [1,] &quot;axxd&quot; &quot;9&quot; &quot;hgf&quot;  &quot;_ww_&quot; &quot;iwwy&quot;
## [2,] &quot;vv&quot;   &quot;9&quot; &quot;nvnn&quot; &quot;_yy_&quot; &quot;iyyu&quot;
## [3,] &quot;mvvk&quot; &quot;9&quot; &quot;hgf&quot;  &quot;_vv_&quot; &quot;kvvh&quot;
## [4,] &quot;bxxd&quot; &quot;9&quot; &quot;vxc&quot;  &quot;_xx_&quot; &quot;gxx&quot; 
## 
## $byColumn
## [1] 4
## 
## $newOrder
## [1] 2 4 1 3
## 
## $method
## [1] &quot;Reverse grep after trimming redundant text&quot;</code></pre>
</div>
<div id="order-matrix-according-to-reference" class="section level3">
<h3>Order Matrix According To Reference</h3>
<p>The function <code>orderMatrToRef()</code> has the aim of
facilitating brining a matrix of text/data in the order of a given
reference (character vector). This function will try all columns of the
input-matrix to see which gives the best coverage/ highest number of
matches to the reference. If no hits are found, this function will try
by partial matching (using <em>grep()</em>) all entries of the reference
and vice-versa all entries of the matrix.</p>
<pre class="r"><code>mat1 &lt;- matrix(paste0(&quot;__&quot;,letters[rep(c(1,1,2,2,3),3) +rep(0:2,each=5)], rep(1:5)), ncol=3)
orderMatrToRef(mat1, paste0(letters[c(3,4,5,3,4)],c(1,3,5,2,4)))</code></pre>
<pre><code>## $by
## [1] &quot;mat&quot;
## 
## $colNo
## [1] 3
## 
## $le
## c1 d3 e5 c2 d4 
##  1  1  1  1  1 
## 
## $ord
## [1] 1 4 2 5 3
## 
## $mat
##                           ref 
## [1,] &quot;__a1&quot; &quot;__b1&quot; &quot;__c1&quot; &quot;c1&quot;
## [2,] &quot;__b4&quot; &quot;__c4&quot; &quot;__d4&quot; &quot;d3&quot;
## [3,] &quot;__a2&quot; &quot;__b2&quot; &quot;__c2&quot; &quot;e5&quot;
## [4,] &quot;__c5&quot; &quot;__d5&quot; &quot;__e5&quot; &quot;c2&quot;
## [5,] &quot;__b3&quot; &quot;__c3&quot; &quot;__d3&quot; &quot;d4&quot;</code></pre>
<pre class="r"><code>mat2 &lt;- matrix(paste0(&quot;__&quot;,letters[rep(c(1,1,2,2,3),3) +rep(0:2,each=5)], c(rep(1:5,2),1,1,3:5 )), ncol=3)
orderMatrToRef(mat2, paste0(letters[c(3,4,5,3,4)],c(1,3,5,1,4)))</code></pre>
<pre><code>## $by
## [1] &quot;ref&quot;
## 
## $colNo
## [1] 3
## 
## $le
## c1 d3 e5 c1 d4 
##  2  1  1  2  1 
## 
## $ord
## c1 d3 e5 c1 d4 
##  1  3  5  2  4 
## 
## $mat
##                           ref 
## [1,] &quot;__a1&quot; &quot;__b1&quot; &quot;__c1&quot; &quot;c1&quot;
## [2,] &quot;__b3&quot; &quot;__c3&quot; &quot;__d3&quot; &quot;d3&quot;
## [3,] &quot;__c5&quot; &quot;__d5&quot; &quot;__e5&quot; &quot;e5&quot;
## [4,] &quot;__a2&quot; &quot;__b2&quot; &quot;__c1&quot; &quot;c1&quot;
## [5,] &quot;__b4&quot; &quot;__c4&quot; &quot;__d4&quot; &quot;d4&quot;</code></pre>
<pre class="r"><code>mat3 &lt;- matrix(paste0(letters[rep(c(1,1,2,2,3),3) +rep(0:2,each=5)], c(rep(1:5,2),1,1,3,3,5 )), ncol=3)
orderMatrToRef(mat3, paste0(&quot;__&quot;,letters[c(3,4,5,3,4)],c(1,3,5,1,3)))</code></pre>
<pre><code>## $by
## [1] &quot;mat&quot;
## 
## $colNo
## [1] 3
## 
## $le
## a1 a2 b3 b4 c5 
##  2  2  2  2  1 
## 
## $ord
## [1] 1 3 5 2 4
## 
## $mat
##                     ref   
## [1,] &quot;a1&quot; &quot;b1&quot; &quot;c1&quot; &quot;__c1&quot;
## [2,] &quot;b3&quot; &quot;c3&quot; &quot;d3&quot; &quot;__d3&quot;
## [3,] &quot;c5&quot; &quot;d5&quot; &quot;e5&quot; &quot;__e5&quot;
## [4,] &quot;a2&quot; &quot;b2&quot; &quot;c1&quot; &quot;__c1&quot;
## [5,] &quot;b4&quot; &quot;c4&quot; &quot;d3&quot; &quot;__d3&quot;</code></pre>
</div>
<div id="value-matching-with-option-for-concatenated-terms" class="section level3">
<h3>Value Matching With Option For Concatenated Terms</h3>
<p>Sometimes we need to match terms in concatenated tables. The function
<code>concatMatch()</code> was designed to behave similar to
<em>match()</em> but also allowing to serach among concatenated terms
and some further text-simplifications.</p>
<pre class="r"><code>## simple example without concatenations or text-extensions
x0 &lt;- c(&quot;ZZ&quot;,&quot;YY&quot;,&quot;AA&quot;,&quot;BB&quot;,&quot;DD&quot;,&quot;CC&quot;,&quot;D&quot;)
tab0 &lt;- c(&quot;AA&quot;,&quot;BB,E&quot;,&quot;CC&quot;,&quot;FF,U&quot;)
match(x0, tab0)</code></pre>
<pre><code>## [1] NA NA  1 NA NA  3 NA</code></pre>
<pre class="r"><code>concatMatch(x0, tab0)         # same result as match(), but with names</code></pre>
<pre><code>## ZZ YY AA BB DD CC  D 
## NA NA  1  2 NA  3 NA</code></pre>
<pre class="r"><code>## now let&#39;s construct somthing similar but with concatenations and text-extensions
x1 &lt;- c(&quot;ZZ&quot;,&quot;YY&quot;,&quot;AA&quot;,&quot;BB-2&quot;,&quot;DD&quot;,&quot;CCdef&quot;,&quot;Dxy&quot;)            # modif of single ID (no concat)
tab1 &lt;- c(&quot;AA&quot;,&quot;WW,Vde,BB-5,E&quot;,&quot;CCab&quot;,&quot;FF,Uef&quot;)
match(x1, tab1)                   # match finds only the &#39;simplest&#39; case (ie &quot;AA&quot;)</code></pre>
<pre><code>## [1] NA NA  1 NA NA NA NA</code></pre>
<pre class="r"><code>concatMatch(x1, tab1)             # finds all hits as in example above</code></pre>
<pre><code>## ZZ YY AA BB DD CC  D 
## NA NA  1  2 NA  3 NA</code></pre>
<pre class="r"><code>x2 &lt;- c(&quot;ZZ,Z&quot;,&quot;YY,Y&quot;,&quot;AA,Z,Y&quot;,&quot;BB-2&quot;,&quot;DD&quot;,&quot;X,CCdef&quot;,&quot;Dxy&quot;)  # conatenated in &#39;x&#39;
tab2 &lt;- c(&quot;AA&quot;,&quot;WW,Vde,BB-5,E&quot;,&quot;CCab,WW&quot;,&quot;FF,UU&quot;)
concatMatch(x2, tab2)               # concatenation in both &#39;x&#39; and &#39;table&#39;</code></pre>
<pre><code>##   ZZ,Z   YY,Y AA,Z,Y     BB     DD   X,CC      D 
##     NA     NA      1      2     NA      3     NA</code></pre>
</div>
<div id="check-for-strict-order" class="section level3">
<h3>Check for (Strict) Order</h3>
<p>Thi function <code>checkStrictOrder()</code> was designed to scan
each line of an (numeric) input matrix for up- down- or
equal-development, ie the chang to the next value on the right. For
example when working with a matrix of with 4 columns one can look 3
times a the neighbour value following to the right (in the same line),
thus the output will mention 3 events (for each line). If <em>all
counts</em> are ‘up’ and 0 counts are ‘down’ or ‘eq’, the line follows a
permanently increase (not necessarily linear), etc.</p>
<p>In some automated procedures (where the numer of columns of initial
input may vary) it may be easier to test if any 0 occur. For this reason
the argument <em>invertCount</em> was introduced, in this case a line
with a ‘0’ occurring characterizes a constant behaviour (for the
respective column).</p>
<pre class="r"><code>set.seed(2005); mat1 &lt;- rbind(matrix(round(runif(40),1),nc=4), rep(1,4))
head(mat1)</code></pre>
<pre><code>##      [,1] [,2] [,3] [,4]
## [1,]  0.8  0.5  0.2  0.0
## [2,]  0.1  0.6  0.9  1.0
## [3,]  0.9  0.4  0.5  0.8
## [4,]  0.1  0.0  0.2  0.5
## [5,]  0.7  0.6  0.4  0.7
## [6,]  0.7  0.8  0.3  0.7</code></pre>
<pre class="r"><code>checkStrictOrder(mat1); mat1[which(checkStrictOrder(mat1)[,2]==0),]</code></pre>
<pre><code>##       up down eq
##  [1,]  0    3  0
##  [2,]  3    0  0
##  [3,]  2    1  0
##  [4,]  2    1  0
##  [5,]  1    2  0
##  [6,]  2    1  0
##  [7,]  1    2  0
##  [8,]  2    1  0
##  [9,]  1    2  0
## [10,]  2    1  0
## [11,]  0    0  3</code></pre>
<pre><code>##      [,1] [,2] [,3] [,4]
## [1,]  0.1  0.6  0.9    1
## [2,]  1.0  1.0  1.0    1</code></pre>
<p>A slightly more general way of testing can be done using
<code>checkGrpOrder()</code>. Here, simlpy a logical value will produced
for each line of input indicating if there is constant behaviour. When
the argument <em>revRank=TRUE</em> (default) constant up- or constant
down-characteristics will be tested</p>
<pre class="r"><code>head(mat1)</code></pre>
<pre><code>##      [,1] [,2] [,3] [,4]
## [1,]  0.8  0.5  0.2  0.0
## [2,]  0.1  0.6  0.9  1.0
## [3,]  0.9  0.4  0.5  0.8
## [4,]  0.1  0.0  0.2  0.5
## [5,]  0.7  0.6  0.4  0.7
## [6,]  0.7  0.8  0.3  0.7</code></pre>
<pre class="r"><code>checkGrpOrder(mat1)</code></pre>
<pre><code>##  [1]  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE</code></pre>
<pre class="r"><code>checkGrpOrder(mat1, revRank=FALSE)    # only constant &#39;up&#39; tested</code></pre>
<pre><code>##  [1] FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE</code></pre>
</div>
</div>
<div id="WorkingWithRegressions" class="section level2">
<h2>Working With Regressions</h2>
<div id="best-starting-point-for-linear-regressions-start-of-linearity" class="section level3">
<h3>Best Starting Point For Linear Regressions (Start of linearity)</h3>
<p>In many types of measurments the very low level measures are
delicate. Especially when the readout starts with a baseline signal
before increasing amounts of the analyte start producing a linear
relationship. In such cases some of the very lowest levels of the
analyte are masked by the (random) baseline signal. The function
<code>linModelSelect()</code> presented here allows omitting some of the
lowest analyte measures to focus on the linear part of the dose-response
relationship.</p>
<pre class="r"><code>li1 &lt;- rep(c(4,3,3:6), each=3) + round(runif(18)/5,2)
names(li1) &lt;- paste0(rep(letters[1:5], each=3), rep(1:3,6))
li2 &lt;- rep(c(6,3:7), each=3) + round(runif(18)/5, 2)
dat2 &lt;- rbind(P1=li1, P2=li2)
exp2 &lt;- rep(c(11:16), each=3)
exp4 &lt;- rep(c(3,10,30,100,300,1000), each=3)

## Check &amp; plot for linear model 
linModelSelect(&quot;P1&quot;, dat2, expect=exp2)</code></pre>
<pre><code>## linModelSelect :  best slope pVal starting at level no 3</code></pre>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABUAAAAPACAMAAADDuCPrAAABsFBMVEUAAAAAADoAAGYAAP8AOjoAOmYAOpAAOv8AZrYAZv86AAA6AGY6AP86OgA6Ojo6OmY6Ov86ZmY6ZpA6ZrY6Zv86kLY6kNs6kP9mAABmADpmAP9mOgBmOjpmOv9mZgBmZjpmZmZmZpBmZv9mkGZmkJBmkLZmkNtmkP9mtttmtv+QOgCQOv+QZgCQZjqQZmaQZv+QkGaQkLaQkNuQkP+QtraQttuQtv+Q27aQ29uQ2/+2ZgC2Zjq2Zv+2kDq2kGa2kP+2tpC2tra2ttu2tv+229u22/+2///bkDrbkGbbkP/btmbbtpDbtrbbttvbtv/b25Db27bb29vb2//b/7bb/9vb///umknummvumovuq2vuq4vuq6nuvanuvcfxmknxq2vxq4vxvanxvcfxzuP0mkn0q0n0q2v0zqn0zsf03uP03v/3q0n3vWv3zsf33uP37+P37//5vUn5vWv5zov5zqn53sf57+P57//5/+P5///8zmv8zov83ov83qn878f87//8////tmb/tv//25D/27b/29v/2///3ov/76n/78f/7+P//7b//8f//9v//+P///8tuXsQAAAACXBIWXMAAB2HAAAdhwGP5fFlAAAgAElEQVR4nO3d+4MUyWHY8V6Gx96EgxOcOLxw0Z1sdCwInR0bRQwrZFsHI8C5cFjLOXZ08SNyHMdxYsWvKH5o2AVJxqv5l9PVz6rq6p7umupHdX8/P9wxszM1PbPsl35U9wZrAICVoO8FAABfEVAAsERAAcASAQUASwQUACwRUACwREABwBIBBQBLBBQALBFQALBEQAHAEgEFAEsEFAAsEVAAsERAAcASAQUASwQUACwRUACwREABwBIBBQBLBBQALBFQALBEQAHAEgEFAEsEFAAsEVAAsERAAcASAQUASwQUACwRUACwREABwBIBBQBLBBQALBFQALBEQAHAEgEFAEsEFAAsEVAAsERAAcASAQUASwQUACwRUACwREABwBIBBQBLBBQALBFQALBEQAHAEgEFAEsEFAAsEVAAsERAAcASAQUASwQUACwRUACwREABwBIBBQBLBBQALBFQALBEQAHAEgEFAEsEFAAsEVAAsERAAcASAQUASwQUACwRULjw5moguXDx7qH2gGV496lHJc9eBMHOvfiPJw/eDh+5c/Hf6QO4txCLulv9mCdfy//89I5YtNNfupvcFu95w9MxdgQULqgBFQm8Wfx6WUBXeciO5snzzw4hoE+vBVekP6fO3MsH2G93GTFwBBQuFAKqpSWKVUlAT25lK6D5MB2s2m0K6PGd8OtpQJfKvw7xexO17yD0GDACChcMAU03yoU4PyUBXeYrnKvs2VeMD3VqU0AX0nJka8byexPl72JBMVwEFC5EAU2S+dmDuboSeXI/qAho9NQkQ8u0TicdLHODgEapDHa+drg++bb03lYV+yUwCQQULsgBTdfX0rQcp3sPza2RK7TsaPdnpEFA4zcUb7gv87citx+TREDhghrQuD1xcKI9iRUBjVbu0owNNaArafGjmCZvddHh4mKICChc0AK6ygIq7xw1BnSVpTbfARp1bRn363tvB8HpG0mknsUziS7dzZ6+iF/35MGF8A8X4/ufXg//fOFGSdiir56+eagG9FU0QLBz8Ya+N1Ys3dMPrl+YJ6WM39G+tvCYJgIKF6oDunPjSWlAF9kTjQG9H2RDrY+kmUR3lad/T5r9lO0xkI9iZbKvnnkoB/R7+UGina/pC6MWUn6r0Z+ZCzphBBQuVAb00kNlG7j4xHjdzhTQC9K6qzKTKN31GAX0Qn732f+Yp9DwetLR9J2384AWhy4PqPxWov0PHEaaMAIKF0z7QKObb34p2iYuDWhUtPyYth7QkqTlBV0EFQrHd+Kj6bLdbCFyYjlLAxoPIe+0Na7pYhoIKFxQA7rKOrSW7zEFdKmETj6IJAVUDBzvetwROX4yz/qcBvTy83SCUbhx/kn6kMLxnXhMsf1/fEsKaDTImYfpBr50hKjYYOn4WPq+OA4/XQQULkgBPfns/ryw/lca0IWyimcI6OVD6YHKCUvR4xbSS8V/jp++NL1gvPaY3LvIAiotvDxfyRjQZZ7d7PHsBJ0uAgoXDGciKfUqC2iUtHwbuBjQdCUyfoE0Z6uspvI5oktp5dD4gnIekxtR/E5+5xsXdqWXKQ+ofkpVNAgTmaaLgMKFYkDVPYNlAdUuMlIM6L5xgHhVUsRtoT/DMFvTvBTqzkzlfZQGNF6mnX318RxFmi4CChcKARV7FCW2Ac0SqE2xz6YgyXORyqa7Z9RBChPpT5796ttStYsBva/3k4BOHQGFC0pAT1/48KH2dduAZl9aqrXLbhYCmjy7RkCVIY8fXM8PxZsDerIorlpruyAwNQQULmjTmApsA2qunfOAPlHnMRkDmvRTXbUmoBNHQOFCNwGtswlfFdCVMkj+1OR0pwsf/vbvlu8DlY/xZ5hJP3EEFC60HlDTQSTRueYBLR5Eio/p382WxxjQ+PjR5erlx9QQULhgG1BtDa48oJXTmOoGVM6jNI1JKmVpQONzAwpT5qUzUTFFBBQubBXQinmg2ka7MpE+P4mobkDlifTJWZ278pwode5U8Yr0xRnzzAOdOAIKF2wDuulMpLxNccLMp3LWDWiyHhmdyplclSkLqPgteK/kaz8lU0wfrp89N5xyvy8NyKmc00VA4YJ1QNUCVQRUu2KSUrnaATVfTEQfWVkbjW5qVxvRAsoFQaeLgMIF64CqJ5NXBbT8cnb1A7p+k19SNPhS+tLyJNYL+fJk1bxSTGwazfxqppgkAgoXrAMarRMaJysVf72H4VezNw3o+iT7DSNX8nZnV2reuSkfVk826IPd4oprElB16TE9BBQuWAc06qR6vlFpQNfr42/Ev9Ljk+yepgFdr59Fv9LjxnN55ffkyYUg+c0h8qGj+Ld/fOlu6W+957fKTR0BRb+ijPm6F3HFFvzEEVD0S/mtnL7ht3JOHQFFz+TfC++ZKP5swU8ZAUXPogr5uQ3vcfvhBgFF31bebsMvWAGdOgKKvolVUC+PxIhj8KyAThsBRe9Wnq7ILb3d9wBXCCj6t/ByTU6sgPq56wHOEFAAsERAAcASAQUASwQUACwRUACwREABwBIBBQBLBBQALBFQALBEQAHAEgEFAEsEFAAsEVAAsERAAcASAQUASwQUACwRUACwREABwBIBBQBLBBQALBFQALBEQAHAEgEFAEsEFAAsEVAAsERAAcASAQUASwQUACwRUACwREB7sTd7r8GjDx61sQybRo2+/vr8bN/RSzQeqvCET9+ZzWbvPi8+8va5w1rD355lCySP9fp8k+/Glp9JyfK4HeX1x+dns3P7h82fHb65ew6WaTIIaC+aBPTT805+zBqOmnx9m1hoL7F1QG/PYoUf8APxuBrDP55lC6SOddBoyZwFVFoet6OEn3zk3OaC6s++bfh8UY6A9qJJQN38mDUd1cGrakNsG9CDWdTJ9wsL9nL2Vt3lSZ+qj7XX5M26Cqi0PG5HeRmm8+F6/Z3Z5g9Gf/Zj0z9QKEdAe0FAa1CfkN0qfHa36/3IH8yyWBTGetxkl4qjgErL43iU28mq5+bvof7s1+cJaDMEtBcEtAb1CdloB9p6Vb0V0E/Dtc130iGKYzVZBXUSUGV53I7yMm3gpgUtPvv27KsEtBEC2oswoK8/Fkcx0p1Uz8O/y7N3vinfOveR+OLLeG9W/oMQ/lQ8Clcczt0rPGv9nfCn4Z2H8WEA+WGVo74WzwqX5KE8+K+nX49/BsV/xfZu8ijtpXLyWKYF39ff60G2m+52nDL5HZX8/OsBvR0/yjS88onP9l8WgpWNdbDhXzTps8tf6VP5lfbCOyu+pTrz8hQfpQ1aZ5SDwr7PkkUpPPvx7K2XBLQRAtqLvdm759WjGPJe/8fJLfFX29ShryZfU5+VHhj5KA1o+rCEedSX59O796XBv1sI6FeV5VVeKqOMVRpQean1lSXlHZkDqt/7OjlUZRpe/sTDBhVSk4+1oWXyZ1d4pbhuYev2Sr+l2fOF90qXp0AdtOYot/V/DEo+ksKzxUdJQJshoL3Yi9Py6fns5+u98P+Pz0crROHfY/Ez+Wl8y7AlLB78Xf1Z4sckXEP6NNmLlT8sf55p1L3oeEP0tEfa4HksxN3yYQn1paR3JY9VsgmvLnW+E1I8tvA5FAOafmSZx8lKpHH4nJiwpKdGHmuvamtX/ezy2Is7D5LPRHxL3zuU37y0HMX0mZanSB205ijirYhZWuf200/I/JEUni3W5QloMwS0F3uzbLvzPakU8d/ex+oxgGKHzqlbki/TYqZDJjf10JhGzQZ/rD2rENDoYQdpZuWXyl9BGcscUG2p083NaAu+5B1JbsdBUe96r3x4lZoadazCalv5Z5e9UtZ+8UqV31KzWgGVBq03injp26YVeeOiSM+O/ikioM0Q0F7spZ2KAvI4a120T04LT7FD6Q+u9qxsyKQ+6o9c9ah5s95Tvq7F4mWyJqS8VMHLioBqS5081Pg1Q0D33jmv7xBMVx2NQxSWS1ogdazijkOJ+k7SV0rvi9eiK7+lZnUCKg9ab5ToSLq0bly9KPmz4x3aBLQZAtqLPaVT+dpP9JddTOP7KD/fpuxgtvas2+lPR8nqW9Woz7/71Zn2LD2g8kqM9lKqbCzzgmtLnXwS8UO1r5n3gWrb8NlxLPPw+kegBksay/Bw5YnSZ5e+UlqjA+mNrM3f0tJhNwZU/feszijRbpj0Sfc2fCTSs+PHEdBmCGgvsj1u0d/XPXnfVnZwKD3iXRZQ7VnZz1p2FF6rT8mo0aHk9DhFvYBqL5VTxjIvePG9ih/q28kOUeVrJUfhX8pHpvTDUPrw+jOLU87V91tC+ezK/iWo+pYa1TsKr77NzaNIO2+ib1T1omTPTupKQJshoL3Y8NMWnag9S364XQXUPGqShm9+6iCg6lj1AvpSSmW9gErrfuttA5qPtWHeq/zZpa+UB1Q8tfJbWjz8U7I8GnXQeqO8zg8WRe9OXZTXymyK/Nnpt5KANkNAe6H/tBWPEHzn/fTntTygyrM2B9Q06uN0vUrf8LcIqDZWWUC19yo+iuSR2tfKAnpQGdCKY0GGYB3UDOha+uzqrYEqy9FlQKXXPogDKi9KWUCVsUv32kJHQHuh7zAz/o1N9tCV7wNVnrVpH6h5VHkNbNt9oNpYZftAtfcqfsiTO7Wv1VoDLewDrfjhr14DrXHljfizq7cPtEaE2tkHKr129KfqRSGg2yGgvdjLz4B5K50clNE2K8sCqj3rQD00XqiPedTsJ/R2g4BqL5W/KWUs84If6D/u4ZAP85npxneqvj9tlUo9Cl8YXnup9AzOwliVR+HVz67sKHzFt3TD8pRSB605irZk1YuiP5tN+GYIaC/2Ztkep315r9VtZRrTQeUaqPas4jxQNaDmUdM0vJw1CGjJPFBtrNJ5oG+pD98TJz+l++FM72idjpr9wyH/iBfmgWrDS7JYGMbaMA9U/uxK54GWf0vNas0DlQatOUr22tms3YpFIaDbIaC90M5EOoj3HopTluOfxeiMnviaa/pf6Twr2rMO0iFLNuGNox7Ek8kPlN176/zr5unp6kultLFKFlxb6vjx2XqW/DXtLYTrtfthvT6e6bsXlfMKCsNL5Ck7+liVZyKpn530StqZSOXfUqN6ZyLtG06/qh7lcXyp6IPk3VUuCgHdDgHtxZ44jVw4l67ZzPKjvPk55e+KW9Fu/7wZUlbUZ6UnqH+1JKDmUZNjtOe+qZ5Ak3695Pwe5aWkdyWPVbbg2lJHK6zGd6S/hXSOlLqq+LrkXHhDEKVY6GMlXypb01M+O/2V0nPh30m+pdnujbLlKC5P2evqg9Yc5UBa2g2LQkC3Q0B7Ea7vRFdj+ij9uYhmUJ5Lf11F9BsZsimbn54vCaj2rOQSSS+l8w0V5lEPzseXGdK3muOvlwRUeamcMlbpgmtLLbqbjSJ/rfAW4l/D8XCt0q/GpA+fkxdXGyu5GlPpprL82amv9M7D9F28Jy5Ylf8ejfLlKC5PeUC1QWuOol1+qWJRCOh2COhYZEdBNm8YevRSNbysc/x8g9fZbx/Zq9qSr9Ls11wVn14W0G0GResI6Fg8zi811/YslA5fqo6aV6Svkl2R/vV527G2a13J6xLQoSOgYyHO4Hu4jg6MtL0N1uFL1VH3dyJVyC5I/7H12ux2rSt5XQI6dAR0NB5XHCrw96XqaPZLNQ0eZ4fO3tH3sNa2VevKXpeADh0BHY/4l4EXDrJ4/lJ13N5uL+jr8w72RLTSOgI6dAQUACwNO6ABADjjPlHOR3So708bwLg4b5TrAV1q4R+MKeJjBCIEFM3xMQKR2cz1iIP+2eIn3wk+RkCYEVA0x8cIrKN+sgmPxvgYgbUIKPtA0RwfIxAhoGiOjxGIEFA0x8cIRAgomuNjBCIEFM3xMQIRAorm+BgxafnsTwKK5vgYMWUzAopt8DFiumby6UcEFM3xMWKylH4SUFjgY8SIpb9epuyL8k0Ciub4GDFes1lFQfV7CSia42PEaGWJNBZUv4+Aojk+RoyVlM06l6ojoGiOjxFjJVezRkEJKJrjY8RYEdAq/OQ7wceIsSKgVfjJd4KPEWNFQKvwk+8EHyPGKoxmNotJCmhZSwkomuNjxFjNFNK95ocTUDTHx4ixmhnmgZaelkRAYYOPEWNlCGhFPwlo+27Pzh0qN2ePul+IKs2XiIBirIqb8JW/+52Ato6AAt4oHESq7CcBjVVef2VLBBTwRmEaU3UVCKhQef2VbWkBHQMCirFiHmgV89utvv7Ktggo4A0CWsX4dhtef6UpAgp4g4BWKQmo+c+KPIPpn15/fD5M7zvfTOsY3T73URbL6Pa7D0v2gYp7n78fDaC+0N5sf/1xePfDsiHDJyRDVjxUW7jKm9k+0NcH4u53n+fv07iEBBTjxeXsqjgM6MvzyW7Tc3F9Hqe7UffXyu17pQH9OHnEu8oLhVW8Le59VD7ku+9nAS15qLZw1TfTgH56XhmjdAkJKEas2Q49AmoZ0Ndi9fK73/1OuIr2lrg3K1iYTHH7ZXrr3PslAc3tyy+0N/uquO+tiiHFqIdVD9UWrvpmukTS8PvrqiUkoBiz/K99jQcTUMuAPk6qtj6I8vM63lxfv76dxW12LrwdbQOXBVQ8Qaz2vSW/UPjEWbTNvHnI0odqC1d9M12iZPjX7882LCEBxag16CcBXVsG9CCtUOxxFpmDaH3tZXb7dmlA4weE8VO+vpeu75mGPFSGLH2otnDVN5MleiwP/17VEhJQjF7NfhLQtf0a6Oyjh9KX08noYW7ekyP1sjSg9/SRI3vpSOVDpkUrfai2cNU3k2crw79VtYQEFGNXt58EdF3zuFvhINJevC/y1+N79/Kt3Nvij1Jz9kqPwusjqw/fPGTpQ7WF23AzXiJp+PiPpUtIQDFytftJQIU6x90KOYn2FUYhEitze9IRF/F1JWm2Ad00ZOlDtYXbcDNeoj05oGpRCSgmpX4/CWikxnE3Q04+TWf53IuO4jgOqGFIbRWx/KHqwm26yRooIGtwPg0BjWzsZ0lOXn/n/UIw9QfZr4GWDlmxCS/JFm7DTQIKSDbXIEdAa8oiUjgm/b7oj35Fo+IRn3ygmgHdPGTpQ7WF23Cz9CASAcUE1dgezRHQmm5Lkyf19bOwPwfx1J91mp/82HvpNKZNATUMqc2MKn2otnDVN/NpTPkSv1e1hAQUIzbjTKRy9m83bJSYtP7642S79yA5BPP6IOpaOpU9mnYuSitPS7cL6OYhSx+qLVz1zfKJ9AQUkzMb5bnwT68HQXDxrn73yYO3g+D0jUPTU4zs3252ouNbyjSm7EiMdDLlW8rjS0/l3BTQ8iELAS08VFu46pulp3ISUEzOGK/GdHIriF1W7z++Gt996qH5eUVbvN2DpFyP0mlM55Xc5A17NzlGn3z9ke1BpOKQ2cVE9GlMhYdqC1d9M92D+rhwMRECiikRwRxhQLN+BsEV8/1n666DbvN2PxXbth8d5jn5zjsiqB8lV39LrxGXxTy6OFzl5ezSO8oCWhwyu5zdW5seqi1c1c38cnbRJfHky9kZl5CAYpRmIw3oMgh2bort9Xlw6pF6/5lvhZv3cy2sVQs3jp9887Sl7ozkYwRys1nhVyCNI6Dhimayjb4Mdu6p90c9fXO19iqozz/52UWUxJ/e63VRfP4YAZOknyMM6NE82C+5P1nxVMNaxeeffLGbU1xDXhw8n9V8vy3x+WMEDGb55CX5zo3P8yCgS3XDPbPKspmndBOvf/Klg+f9roD6/TECBVk/RziNaRFuoL+6Pw+Ci58o9+dhDbfhpxDQ/OC5/is2uub1xwgUSK2cjWwi/cmtYHc1NxyEX8gB3TUuioHjpetWfPD83dqzttri+ccIVMg39Go82IuAnp6bpjEtskNHorHGRRlbQIeCjxEj1qCffgQ0CM6EW+/HdwJlb+jmgBoWjp98F/gYgYgfAU1KuQzk4/EEtDd8jEDEj4Am2VT3dW7eB1rET74TfIxAxIuApqFU1zQndxR+OPgYMQ4Nrj1vNvyAhmua6XxPNaDKPFDjVPsifvKd4GPEKNQ8UlTBg4Cusk14dcL81M5EGhA+RoxA3SPtVTwI6FF2DZGFchBpaufCDwgfI/znop8+BFR0c+duPI1JCeUyvt/R1ZhevNhqIUP/8pNtR4j84n+8+AM3I7WGgMJ7LvLpR0DfXM2mwUcroOlspvx+F9cD3Tagv/jR7/3f7UZIByKgQNvc9NOLgK6Pr8WdFFcFXUvTQY/mDq9Iv2VAw+wRUMAXbvrpR0Dj3320cynpZD6f3uXvRCKg9RFQIOJHQJ0hoE4QUCBCQFMEtD4CCkQIaKo6oFHV/ulPX7x48Yd/md73Lz/64sWLz//4n8Wf/+pF5E/UJ6h/+vlffBE9P61jdPs//VkWy+j2H/0dAQV8QUBTmwP6F3EkX/xxfNc/fBHf/Py/r2sF9KfJ41/8frym+uPk5ud/vpZvf/6/CCjgCQKa2hjQXFS8nyq3Nwf0Z1+8+PyP/uZv/vqHL178QNz94+zpn/9vZbzf/yEBBdri6PB7goCuXxQVHxQF9I/+br3+xy/iAP7rfw1TF97+eRhEsfNT3wdaCOiPk1CGrRUP/NkX8Xg/DwcWXxbj/UF4+5/C8Qgo0BJH8z9TBNTQz5KARiuOonxxD1/84CfpV/6kRkD/Kg1o7MfpeGLl9c+jFdAfZK9EQIE2ODl9U0ZAUxs34ZP+FXoYFvUHtdZAX3z+3/5W+nL68PD5fyKP91MCCrTCeT8JaKbGUXjpT9Kh8uyO6oCKbXSxh/N/RveGt36QP/IH8njhlwgo4J7zfBLQXLOASpWL07kxoOuf/TA9SvR3WU4Tf/ATNagEFHCuhX4S0Ezba6Chf/yL7LD7z74goECnWugnAc10ENDQz//6T/Vg6g8ioIAvCGiqWUAbHERKDttn/vWH4SMLZ34q4xFQwAsENNUwoD9Oj5WXT2PK5n2qq6zxI/8qm3UfB/in8ngEFPACAU01DKg+kV6f5ykK+flfihPck4nx4e3fF7OY/uVH0YzPdCL9L/7hi+iJ0Xh/G49HQAE/ENBUw4Bqp3ImJ3Pmp3LmX//PyjSm7NzN/FTOeG8op3IC3iGgqaYBXf8/+WIiSQDlA0M/Snr49+k0pvTAe/KErKB/HA+cXJzk9/6eg0iAQ20cfU8R0HpMB9Xjy9HFl7Nbx0FVyvePfxrG8s9+kj3hF//nv7wQ169LnxA9//M/zM5Oii6Px+XsAKfamP6ZIaBojo8RvnB/9qaCgKI5PkZ4ouV+ElBY4GOEH1rOJwGFDT5GeKH1fhJQWOBjhBda7ycBhQU+RiBCQNEcHyMQIaBojo8RiBBQNMfHCEQIKJrjYwQiBBTN8TFi0No/+p4ioGiOjxFD1v70zwwBRXN8jBiwDvtJQGGBjxHD1WU/CSgs8DFisDrtJwGFBT5GDFW3/SSgsMDHiKHqtp8EFBb4GIEIAUVzfIxAhICiOT5GIEJA0RwfIxAhoGiOjxGIEFA0x8eIoen46HtqcgGFE31/IwFFx9M/MwQUNvr+RgKStn95cbnJBbTvJQDgWH/9JKAA/NZfPgkoAL/12U8CCsBrffaTgAKALQIKAJYIKABYIqAAYImAAoAlAgrAR70efU8RUAAe6nX6Z4aAAvBOj2dvKggoAN8MpZ8EFIBvhpJPAgrAN8PpJwEF4Jnh9JOAAoAtAgoAlggoAFgioABgiYACgCUCCsATAzr8niCgAPwwoPmfKQIKwAeDOX1TRkABeGCQ/SSgADwwyHx6EtBVkLpS6/6KhSOggIcG2k8/ArosCWXZ/RULR0ABDw20n34EdFESyrL7KxaOgAJwxoeAntwKdpvcX4GAAnDHh4C+uRrsN7m/AgEF4I4PAV0FO/ea3F+BgAJwx4eALoNTj5rcX4GAAnDHh4AugrPfvz8PgksP691fgYACPhnq0feUBwE9uRWcnhsOtpfdLy2KgeulA9CaoU7/zHgQ0DdX8/xdqXG/tCgEFPDXMM/eVHgQ0KN5cObu4Xp9fCdQdnqW3V+5cAQU8IQH/fQhoLlFYJ63VHZ/EQEFPOFBPj0LaLjRbpw5X3Z/EQEF/OBFP/0K6PanJBFQwA9e9JOAAoAtDwK6yA4RHc3lw+1l91choADc8SCgy3SWUriiKZ+7WXZ/5cIRUADOeBBQMd/z8vP1+tm1IDh7uPn+yoUjoACc8SCg0nWT4xXNZTJrSb+/zsIRUADO+BDQrJRJJ9OA6vfXWTgCCgyaH0ffU14EdH18Zx4Ep28k2+lZQLX76ywcAQWGzI/pnxk/AuoMAQWGzLN+ElAAg+FbPwkogKHwrp8EFMBA+NdPAgpgIPzrJwEFAFsEFAAsEVAAsERAAcASAQUASwQUQL88PPqeIqAAeuXh9M8MAQXQIx9+eXE5AgqgP373k4AC6I/f+SSgAPrjez8JKIDe+N5PAgoAtggoAFgioABgiYACgCUCCgCWCCiArnl/9D1FQAF0zPvpnxkCCqBTnp+9qSCgALo0pn4SUABdGlM+CSiALo2rnwQUQIfG1U8CCgC2CCgAWCKgAGCJgAKAJQIKAJYIKIAOjOzwe4KAAmjfyOZ/pggogLaN6vRNGQEF0LLR9pOAAmjZaPNJQAG0bMT9JKAA2jXifhJQALBFQAHAEgEFAEsEFAAsEVAAsERAAbRizEffUwQUQBvGPP0zQ0ABuDfeszcVBBSAcxPpJwEF4NxE8klAATg3mX4SUACuTaafBBTA1maJvpejcwQUwJZms6kWlIAC2E4WzukVlIAC2IqUTQK6/YiuB3SJgAKuydWcWkEJKICtyCugBHTrEV0P6BIBBVzLojnBw0gEFMBW5ENIBHTrEV0P6BIBBVxLohmtfRLQrUd0PaBLBBRwLY5mvPVOQLce0fWALhFQwLVk1XOK/SSgALaU7fyc3DEkAgpgW5zK6XBE1wO6RECBFky1nwQUAGwRUACw5EVAV0HqivqFkwdvB8HpG4e1R6yF6OcAAB5zSURBVCKgQAvYhHc3ousB1+tlSUCPr8b3nnpYdyQCCjiVHn2faEHbDOib6xfMLj5qNuTCHNCTW+ndZ+uugxJQwCVpDuiaaUxORsz+9OZqYHaqWUDDUO6a7g9XTM98a71+Oi9s2pcvHAEFnJmp/WQivYsRsz+5Cmg4zr7h7rCr8UDh1+uughJQwJlZ8fSjqRW0zYCe/M5vJe6E64p3ReOe3Ql2vtZ0xFWwc89w99E8XfFcmh9gWjgCCjgyy64iIt/X08L0pJODSEtpG/tJYN4er7A0r7LmXc1TunHhCCjghrTnU76zn4XpSxcBXSnNXATGDfIKi+Ds9+/Pg+CSerA972q4DU9AgW5J11E23DkRXQR0oWxhh6uLtQ+aR05uBafnhoPwCzmgxrVa0/7XJq8MYDMC6nRE/Y4wb/ImuHZzM/lYlFzQRRbissP0BBRoHwF1OqJ+x7YBDVdZoyNQx3fU4/ebA2pYOAIKOMY0Jqcj6neExZQ34VcN5r1r1N2nBBQYBCbSuxyxcM9CPogkTh9qehg+pe7r3LwP1LBwBBRwjlM5HY5YuGcl7bw8uR/UnrRZoK5pchQe6IGpklPtZycBjc5ZP/Mbn4XE1ZOsV0C1gCrzQGvOjCKgwHammMlynUykV8/pbLoHNN9UVyfMcyYS0LVJrmZW6OZydid38n5+uekRpOw8pnAFVA4l58IDHaOfmq6uB/rqwQVRz4sNLn6cEuuvl5+v18+uaWuvYVl37nI1JqAr5FPnwwWV8+spxyugy2Q2U75ngOuBAu2jnwU+BDQraLIBnwZU7AWNL4/HFemB9tHPgu424d8W5xG9uX7TZhL98Z259LuPsoDyO5EA9Kmjg0j3kwsph1vdZ2xngbpAQAG400lA019eFAXUfh69AwQUgDudBHQRVvPm70YXEXkytz8V3gECCsCdLgJ6NBdrnclVmMSBn4YXVHaIgAJwp6OLiVzJL2O33OJczq0RUKAxjr6X6iCgyQlEaUAbX5HeJQIKNMX0z3LdXVA5DWjjCyq7RECBhuhnBQIKoAL9rNLdFenZhAf8Qz8rdXQQaZ+DSICH6Ge1LgK6jKZ+5lvyta+d5B4BBZqgn9W6CKho5u5hHNDja0GPu0AJKACHOjkTSfxSpJ2vzIOdX74uzujsbx49AQXgUDcXE3ki/0qP/jbgCSgAlzq6nJ3Yco+duev6BZsgoADc6eyCyie/+UHo12pf+rgdBBSAO15ckd4dAgrUwdH3ejqZB3rmbn8XsFMRUKAGpn/W1M3FRPo88K4goMBG/PLi2ro7F34QCCiwCf2sj4ACkJHPBro7F34QCChQjX420cmpnNeCnZuuX8YOAQWq0c8mugjoq2dfD4LgwgeZD7mcHYAR6GYfqIYLKgMYAwIKAJa6mAf6jQ80bMIDGANO5QQASwQUwJqj73YIKACmf1oioAA4e9MSR+GByaOftggoMHXk01oPAb1w4SIBBQaDftrrdh/oybM78+Byj1dXJqCAjn7a6/wg0tE82HX9kvURUADudH8Uftnnxe0IKAB3ug9or6ugBBSAO90HtNcL1BNQAO4QUACw1H1AV8wDBQaBw+9b6zygx1cD9oECA8D8z+11fT3Qa2IqPUfhgb5x+qYLfZzKeba/mfQEFIjQTyd6COglzkQCekY+3eh6E/7D3+oxnwQUiNBPR7geKDA99NMRAgoAlggoAFjqOqDPXb9cMwQUgDtdBfQ/iGNHx9d6PghPQAE41ElAT74dnb2ZzGc69dD1S9ZHQAG400lAF/Hp7wsm0gO94ui7Y10E9GgeBVSsgJ49FDc4lRPoA9M/XesioMt4pXMVBDv3oltcTAToHmdvutfFmUi34nXOZEM+XAXtbxuegGKy6GcLujkXXoRTdHR3zQWVgV6QzzZ0F1Cx8/PKmoACfaCfreguoKvkQqBhSAko0DH62Ypu9oGKg0fJLlARUvaBAhiDLo7CL8S2+5vkV3mIXaFXXL9mbQQUgDtdBFRsvH/pWrwFf3wrnszUEwIKwJ2uzkRKzkCKzubsbwWUgAJwqJtz4W+Jfp5JToe/7PoVGyCgANzp6GpMz371w98W/3/zS5d6vJQIAcXkcPS9VVxQGRgxpn+2i4AC40U/W9ZdQD9L/c6v/hsm0gMdoJ9t6yagT68pvxmeM5GADtDP1nUS0GUQOAjosvC8VTZi3ZlRBBTTQT/b19UFlWWXPrEZ13AO/ZKAAqXoZ/s6uqDyzt3klPinc8uJ9GIuqR7QBQEF0KOOLqgsAreIzuW0vRjTorjpHw7c9Nr2BBSAO91czi46+30pd7SpVXD263pAw4GbjkRAAbjT3fVAxSGf3fx/zby5unNvoQd01fyyJAQUgDsdBjT5ZUjhzcbXAw031q+sCwEtHpbfvHAEFIAz3ewDjUKXlNPmV3osxUprIaCL4Oz378+DoMHp9QQU48fR9+50d0X6NKQWAT2ai2foAQ3HOz2vPAgfGDR7ZcA7TP/sUEfTmKK9nosopM0PwycHi/SARtcWrZzGREAxOfzy4k51NZFebGbHh+EXjX8n0iLuox7QcNgzd8ORju/UP7eJgGLc6Ge3OjuVM0ycCOmXvtL4kvSrJLiFfaCZ+jOjCChGjXx2rJsr0t+P1xGXNqfCH82TyUrlAQ035mvOjCKgGDP62bWurkh/XcRPhLTx75RTr0RiDGX9U5IIKMaMfnat4wsqHz/48G7DSaAEFMBADf+K9KUBzTfpj+Z1d6sSUADuDD+gGX0f6DI9GpVONK2BgAJwp6uAvnrwtjh69Ob6zaancWZM80AvP1+vn12rPzGKgAJwp5uAxkePRECvBmeaXgAklQV0mcxayjfuax+XIqAA3OlmGtOtIA9o80soJQoBzQpaf0QCijHi6HtfOgnoImzczd+NzoF/Mm98IlI+ih7Q9fGdcLjTN+qPR0AxQkz/7E1Hp3KG64jJRUTE6UgWF1R2hIBidDh7s0ddBHQRHS5Pr8K0tLmgsisEFGNDP/vU3eXstOsq94OAYmTIZ6+6uyJ9GlCbCyo7Q0AxLvSzXwQU8Bj97Fd3v5WTTXgAI9PRQaR9DiIBGJ2OfqVHuM6Zb8k3vKCySwQUgDtdBFQ0c/cwDujxtaYXVHaKgAJwp5MzkVbidMuvzIOdX74uzrzsbx49AQXgUDcXE3kiX9Kzvw14AorR4PD7IHR0OTux5R47c9f1CzZBQDEOzP8chs4uqHzymx+Efu2h65drhoBiDDh9cyg8uiK9CwQUI0A/B4OAAp4hn8NBQAG/0M8B6SagT68rv1qTc+EBa/RzQDoJ6P0gIKAARqeLgK4CAgpghDq6mMjO1z5z/TpWCCgAd7q5nF2vZx/JCCgAd7q7oPIgEFAA7hBQwA8cfR+gbvaBiivSDwIBha+Y/jlEHR2FZx8osA3O3hymTuaBLgezCkpA4SX6OVDdnIm0DIJLv/FZ5rnr16yNgMJH5HOoOjqV8xoT6QFb9HOwOJUTGDr6OVjdncp5+kLmIgEFMAIdBPTkVhDs9PqLPHIEFIA7HZ3K2eMv4lQQUADucCYSAFjqZhOegAIYIU7lBIaKo++D10VAj+bBrutXsURA4Q+mfw5fR6dyBl8+dP06VggovEE/PdBFQF999r0gCL70K7+V+u3ealr77b540epyAJvQTx90NI3JuzORCCj6RT+9QEDNCCh6RT/90MU0pm98oPmQTXigEv30QzdXYxoMAgrAHQJqRkABbERAzQgogI0IqBkBBbARATUjoAA2IqCqFwadLBmmZpbQ7+1naWCHgCpM/SSgaMFsZioo0z89Q0DNyCZalZVSTia/vNg7BNSMgKJNUinlP9FP3xBQFZvw6IJcStO6KDxBQBXsA0UnDAGlnz4ioGZkE20yBrSnZcEWCKgZAUWbTJvw8BABNSOgaBMBHQkCakZA0SYCOhIE1IyAok3GaUzwDwE1I6BolXEiPbxDQM0IKNo1M5/LCb8QUDMCipYR0DEgoGYEFC2jn2NAQM0IKNrFCugoEFAzAopWReEU/6GgXiOgZgQUbcr6yTQmvxFQMwKKNsnppKAeI6BmBBRt4kykkSCgZgQUbSKgI0FAzQgo2kRAR4KAqrigMrpAQEfCo4Aug1OPtLtOHrwdBKdvHNYegyvSYxDi+UvxNFAC6jF/Ano0LwT0+GoQOfWw7iBswmMAZqq+Fwf2vAnoya1AD6i4K3a27jooAUX/lPnzBNRr3gR0ERQCugyCM99ar5/Og+BKzVEIKPqWbLazBjoKvgR0FZz9uhbQcAU0vuPN1dqroAQUPZslJyGxD3QUPAnom6s79xZaQI/m6YrnMti5V28cAop+JSucHIUfCT8CGq5sXlnrAV1l2cxTugkBRa9mhtM3CajH/AjoMthdFwKaT2sKt+EJKHyQHzoq3gcPeRHQo7lIpR7QhRzQXeOiGNR8SQKKNhHQkfAhoGEf99emgKaHjsItfAIKnxDQkfAhoIt4A715QIsIKAaBX2s8Eh4EdJWEstOAAq1iIv04DD+gR/PkYHvzfaBFBBQDwTz6URh+QJfKLsxd+QstHoUHXDJkkn6OgccBVeaB7tdcOAKKHtDJsfI4oK2eiQQ4w3rmeA0/oBl9H2ir58IDrtDPEfM4oGLddOduS1djAhwhn2PmY0DDcEa7PN9cbe96oIAb9HPUfA6o2Ava1hXpATfo56h5HVD3vxMJAOrzKKAuEFAA7hBQALBEQAHAEgEFAEsEFGgDR98ngYACLWD65zQQUMA5zt6cCgIKuEY/J4OAAo6Rz+kgoIBb9HNCCCjgFv2cEAIKAJYIKABYIqAAYImAAoAlAgoAlggo4AiH36eHgAJuMP9zgggo4AKnb04SAQUcoJ/TRECB7ZHPiSKgwNbo51QRUGBr9HOqCCgAWCKgAGCJgAKAJQIKAJYIKABYIqCANY6+Tx0BBWwx/XPyCChgh7M3QUABO/QTBBSwQz6xJqCAFfoJgYACFugnBAIKAJYIKABYIqAAYImAAoAlAgoAlggo0ABH3yEjoEB9TP+EgoACtdFPqAgoUBf9hIaAAjXRT+gIKFAP/UQBAQXqoZ8oIKAAYImAAoAlAgoAlggoAFgioABgiYAC1Tj6jlIEFKjE9E+UI6BABX55MaoQUKAc/UQlAgqUIp+oRkCBMvQTGxBQoAz9xAYEFAAsEVAAsERAAcASAQUASwQUACwRUEDH0XfUREABDdM/URcBBRScvYn6CCggo59ogIACEvKJJvwI6LPrQRBcvKvfvQpSV2oOREBRiX6iES8Cej/J5NlD9f4lAYVb9BON+BDQvJO76hcWBBRAjzwI6Jurwc7NcN3zyTzYuSd/4eSWXtSNCCgAdzwI6Crt5kpb0wzLut9wLAIKwB0PApoJg6msca60NdIaCCgAdzwLqLIGugxOPWo4BAEF4I5PAdXXOBfB2e/fnwfBpYe1hyCgMOPwO2z4E9BX97VdoCe3gtPzyoPwgUFLSwe/Mf8TVnwJqJjKtKPOpA+36DdMYyKgqIXTN2HJl4B++8KFcG3zsjyT/mgenLkb3nF8J6i9M5SAooh+wpYvARWezEvmfS6CuvOZCCgKyCes+RRQMRHUGEp9flM5Agod/YQ9rwJaFsr6pyQRUOjoJ+x5FdCyUBJQAH3wIKCL7BCRugaa3380r3s1EQIKwB0PArrMZiktlPlK2f3hCmjdczoJKAB3PAiomO95+fl6fXxNna6U3v/sWvFKoaULR0ABOONBQKXrgcYH4Zf5/xO1LypCQAG440NAs1Lu3Exv7qv3174oEwFFiqPv2J4XAV0f35kHwekbz+NbWUDT+2tuv68JKDJM/4QDfgTUGQKKCGdvwgkCigmin3CDgGJ6yCccIaCYHPoJVwgoJod+whUCCgCWCCgAWCKgAGCJgAKAJQIKAJYIKCaDo+9wjYBiKpj+CecIKCaCfsI9AoppoJ9oAQHFJNBPtIGAYgroJ1pBQDEF9BOtIKAAYImAAoAlAgoAlggoAFgioABgiYBizDj6jlYRUIwY0z/RLgKK0eKXF6NtBBRjRT/ROgKKkSKfaB8BxTjRT3SAgGKc6Cc6QEABwBIBBQBLBBQALBFQALBEQAHAEgHFuHD0HR0ioBgVpn+iSwQUI8LZm+gWAcV40E90jIBiNMgnukZAMRb0E50joBgL+onOEVAAsERAAcASAQUASwQUACwRUACwREAn4MWLvpfAkVmicHcvSwMQ0CkYS0BnM2NBmf+J3hDQCRhJQLNQKsXk9E30iIBOwDgCOpMp9/a4UJg4AjoBIwzoLL+z14XCxBHQCRhPQA1/6m+BAAI6BaMJaOGP9BP9IqATMJaAmv8M9IeATgABBdpBQEfshUHfy2SPgGJ4COh4mfrpdUCL+0CBfhHQCfA5mznTUXigXwR0AsYT0JKTOYGeENAJIKBAOwjoBIwjoGv6icEhoBMwkoCWXY0J6A0BnYCRBJQ1UAwOAR2xMU5jiv5LQDEQBHS8RjcPVP8v0DcCOl6jDGjxz0B/COgE+JzNHAHF8BDQCSCgQDsI6AQQUKAdfgT02fUgCC7eLdx/8uDtIDh947D2QATUXwQUw+NFQO8HsbNaKY+vxvefelh3JALqK2X2J/3EQPgQ0GWQ2lXuP7kVlJS1fOEIqJ9EPflNSBgcDwL65mqwczMs5JN5sHNP/kIY1jPfWq+fzoPgSt2FI6BeyibRcyISBsWDgK7Sbq7UUIYroKceiT+Eha27CkpAvZQmk35iYDwIaCYMpbwNfzRPe7rUVk3LEVAfkUwMlWcBlddAszVTKaWbEFAP0U8Mlk8BXakrmstkC75Q1goE1EP0E4PlT0Bf3deOFS3kgO6anhIYtLR0ACbIl4CKqUw76kz6RXbo6OQWAQXQPV8C+u0LF+ZBcFk+2L45oEUEFIA7vgRUeDJXOklAAfTLp4CKiaD7+a3N+0CLCCgAd7wKqBpKjsKPHEffMXheBVTdVFfmge6bn6EjoP5g+ieGz4OAlm2qcybSmHHGJnzgQUCX2fzPhTITlHPhR4x+wgseBDTsY3D5+Xp9fC3I1kUjy3hqKFdjGh/yCT94EFDpeqDxrs5l8v83V7ke6DjRT3jCh4BmBd25md6Mjxkdzbki/SjRT3jCi4Cuj+/Mxe8+eh7fygJq8zuRAMAd17Eb9Dpe3x82gHFx3ijXAwLAVBBQALBEQAHAEgEFAEsEFAAsEVAAsERAAcASAQUASwQUACwRUACw5HlAT24pl8zTbnpGWvpX4rIBwcXal10ZHPk78SR8LzuXn/e5ONvR/1odzeteEnyApDeTXTit5u8oGx75OxNfguNm/UttOOF5QJf6NUd9Dmi+9KvkwlW1r5w6OPl7ObkVvxWPm6P9tQrf0TjezML7gEpv5knyM1P7Yplu+B3QpXrRZu2mZ/KlP5oHZz4J/0m9FdT97VFDI30nFtF1DY+v+fut0f9aLX3+10B6M2+u+vs2YtKbWQXBmYfrk293/a+BzwE9uR/If7W1m56Rlz79dzVc1en431M35PeS/grB+r+LdWAKf63EdW19LY/yZo7mXv7tyshvJvtR6Xoj1OOAPr0WBBfyj0u76Rl56fNfZ7ry8idV+U5kf6EXfm4oFv5ahd+dD7z8tqz1N7Py8zuSUt5M9pNS/3f+uuFvQMNVmp2bK/l3gMo3PVOy9F4erSh5L34GtPhmlsGun/+uFd7M0tcdRBH1zSz62lbzOaCXD9dyQJWbnilZei9/Us3vpes1A0cKb+ZofuqRl9+WdeHNLE79e3Hg+uIn/S6VJeXNhJsFPe0g8jegazEvRvqrrd30jHnpF16+H9N7eTr3c3eu/mbCn9R9P/9dE5Q3k/+WRz93TstvJnwv+ydiutzpmx0vhccBFbSfU38DKpjW2nzc7BVW2m7DIPiyl/2MSG9mKb4j3gZUyN5M+Ldr58bh+tV9Xwu6zt9M+F5u3mIaU3OjDmjYHW/fjvJe3vzShXBT8ZK3Bc3fTLxTehwBXaWT5PzczolIAQ2CcJNeHJhnGlMDYw7oib/TQA3fCW+34dfSm0l2tY0joBlvZ5ipAY3fw7Lj7w0BHQ516UU/ff17bfpOrPz95yB7M8v4H4GRBTSfNucdKaDJP89d/2tAQIejsN/Q336O9cc0DufIAurpDDNBCmjyFrr+a0ZAh0Ne+jfXgqDrA4oujfLHNLv4hs/nj4/yOyOtd3b8ZgjocEhLf3w12PF1gzcyyjXQkQa0v0mUW5PmgbIGamOkARVnWfi7kSgUTxEZwaGK/LbH353id8bTcxwEae90PruVfaD1jTOgfl8vLWKaLOPtexpnQNN34eslawR5Umu84tn1nCwCOhzSP6ferhKklH8Mbh6uX93x+JjYOAMafWeiCw36+7dNPrE/uPQ8mgfa7V8zAjoc0h7xnKfVkXZHXPP7nazHGtAondGlrv09Wil9Z+4nf80ud7sEBHQ4lNMqRhPQdXSO8s4lf389yVgDuj55MKbvzLPr4rfg3O14CTwPKAD0h4ACgCUCCgCWCCgAWCKgAGCJgAKAJQIKAJYIKABYIqAAYImAAoAlAgoAlggoAFgioABgiYACgCUCCgCWCCgAWCKgAGCJgAKAJQIKAJYIKABYIqAAYImAAoAlAgoAlggoAFgioABgiYACgCUCCgCWCCgAWCKgAGCJgAKAJQIKAJYIKABYIqAAYImAAoAlAgoAlggoAFgioABgiYACgCUCCgCWCCgAWCKgAGCJgAKAJQIKAJYIKABYIqAAYImAAoAlAgoAlggoAFgioABgiYACgCUCCgCWCCgAWCKgAGCJgAKAJQIKAJYIKABYIqAAYImAAoAlAgoAlggoAFgioABgiYACgCUCCgCWCCgAWCKgAGCJgAKAJQIKAJYIKABYIqAAYImAAoAlAgoAlggoAFgioABgiYACgCUCCgCWCCgAWCKgAGCJgAKAJQIKAJYIKABYIqAAYImAAoAlAgoAlggoAFgioABgiYACgCUCCgCWCCgAWCKgAGCJgAKAJQIKAJYIKCZvEQRX+l4G+ImAYsyeXr+3+UEEFLYIKMbr5FawQ0DRIgKK8XpzlYCiVQQU40VA0TICivEioGgZAcV4EVC0jIBiCI7vzINg59LD6MZR+OfddfbHfXEwKPzv8fUgCC5+UvKkyMmDt8Vj7mbPFZKGFh598jQccOfyIQGFNQKK/p3cDxJhzkLLtHqinLvx//ZXyUMuHZqfFPpekszgrLhHCWjx0cfX0i8TUNgioOid6GNqN70jamBY0lOP4tu/ksYx/krxSdGj5cfIAS0++igb79S/JaCwREDROxG+y8/X61diLTFKmajblXQDPs3fmXDr/dm19CHmJ525m6xsRvfk+0ALj46GFPc8jVZECSisEFD0LcxclMnQKl7jjI7r7NwTX8jWSIPdeMVzET/E8KRFunIqchn9KQto8dGitjfX2eAEFFYIKPq2zLbBowhGoRPFu7JIcyoaF/8pa2HxSVIk03BmAS0+epHfk6zuAs0RUPRtkYUvWj+8kv5BiL8gAnpFevgV05NW2QpoJgto4dHxcX1lRKA5Aoqeycd3pCNCC2nXpJK7aG3S8KSVtJaZSANafLQyQ3RJQGGJgKJnet2S1UixRZ5utisXBVmZAho+aVk/oGcPw6+kg0urvUBDBBQ9KwnoSl0DVdYXCSgGgoCiZ8r2eUasgGYnEZk34bUnbQjovvEr6TMJKKwQUPTNeAxHHCX/ujxpvngQSXuSfBApial8EEl9NAeR4AQBRd+WavmilkWzNbP5RdmZSeto0pGIYvFJ0jSmNI/yNCbt0dI90ZSptt8kxomAom/SPMykjmnTFoG0DzN+SNpSw5MW8v7TaA9nFtDio/N7xNR8Ago7BBS9EwUT52mePEgvw5S0UHRU/D8+CCQupBSdyrlvflJ2Kue3A2nN9Ur5S+QjElDYIaDonXyQPFpzXKWHj1Zx28QDLmQPuWJ+UuFiItlj9k2Pzu/Z+QoBhSUCiv6d3EljdkZcrlPaKRmfzRnt00yuR7fzNfOThCfK5ezW6flMV4yPTgu6s89ReNgioBiCZ+Jqx+mVkBfqAZ500pK4btLpG89LnhRRLqgsPBG3v1zy6GfRFZofMo0J1ggohs88VRToHQHF8BFQDBQBxfARUAwUAcXwEVAMFAHF8BFQDBQBxfARUAwUAcXwEVAMFAEFAEsEFAAsEVAAsERAAcASAQUASwQUACwRUACwREABwBIBBQBLBBQALBFQALBEQAHAEgEFAEsEFAAsEVAAsERAAcASAQUASwQUACwRUACwREABwBIBBQBLBBQALBFQALBEQAHAEgEFAEsEFAAsEVAAsERAAcASAQUASwQUACwRUACwREABwBIBBQBLBBQALBFQALBEQAHAEgEFAEsEFAAsEVAAsERAAcASAQUASwQUACz9f5vI93UxGHTZAAAAAElFTkSuQmCC" width="672" /></p>
<pre><code>## $coef
##              Estimate Std. Error   t value     Pr(&gt;|t|)
## (Intercept) -9.952667 0.22137502 -44.95840 7.131292e-13
## conc         1.003000 0.01522206  65.89121 1.578505e-14
## 
## $name
## [1] &quot;P1&quot;
## 
## $startLev
## [1] 3</code></pre>
<pre class="r"><code>linModelSelect(&quot;P2&quot;, dat2, expect=exp2)</code></pre>
<pre><code>## linModelSelect :  best slope pVal starting at level no 2</code></pre>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABUAAAAPACAMAAADDuCPrAAABrVBMVEUAAAAAADoAAGYAAP8AOjoAOmYAOpAAOv8AZrYAZv86AAA6AGY6AP86OgA6Ojo6OmY6Ov86ZmY6ZpA6ZrY6Zv86kLY6kNs6kP9mAABmADpmAP9mOgBmOjpmOv9mZgBmZjpmZmZmZpBmZv9mkGZmkJBmkLZmkNtmkP9mtttmtv+QOgCQOv+QZgCQZjqQZmaQZv+QkGaQkLaQkNuQkP+QtraQttuQtv+Q27aQ2/+2ZgC2Zjq2Zv+2kDq2kGa2kP+2tpC2tra2ttu2tv+229u22/+2///bkDrbkGbbkP/btmbbtpDbtrbbttvbtv/b25Db27bb29vb2//b/7bb/9vb///umknummvumovuq2vuq4vuq6nuvanuvcfxmknxq2vxq4vxvanxvcfxzuP0mkn0q0n0q2v0zqn0zsf03uP03v/3q0n3vWv3zsf33uP37+P37//5vUn5vWv5zov5zqn53sf57+P57//5/+P5///8zmv8zov83ov83qn878f87//8////tmb/tv//25D/27b/29v/2///3ov/76n/78f/7+P//7b//8f//9v//+P////M2yEIAAAACXBIWXMAAB2HAAAdhwGP5fFlAAAgAElEQVR4nO3d/YPcZmLYd6xGlKitROkkmWJIqb67RHciafmcJnS54uli35F7lFxVJ5dUavcusR27aeKktZvE6TVOvSRFvzDr/Zs7wAwwAAaYxTyLAQbA5/ODtLOLwQCz3O/i5QE2OgMgSNT3AgAMlYACBBJQgEACChBIQAECCShAIAEFCCSgAIEEFCCQgAIEElCAQAIKEEhAAQIJKEAgAQUIJKAAgQQUIJCAAgQSUIBAAgoQSEABAgkoQCABBQgkoACBBBQgkIACBBJQgEACChBIQAECCShAIAEFCCSgAIEEFCCQgAIEElCAQAIKEEhAAQIJKEAgAQUIJKAAgQQUIJCAAgQSUIBAAgoQSEABAgkoQCABBQgkoACBBBQgkIACBBJQgEACChBIQAECCShAIAEFCCSgAIEEFCCQgAIEElCAQAIKEEhAAQIJKEAgAQUIJKAAgQQUIJCA0oYX16KcK2/eeZT74ucfvzH/5MvfulP37KMoOri7+PD003jagzf/h0d1E7fmKF7Uy5un+ex7q4/L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" width="672" /></p>
<pre><code>## $coef
##              Estimate Std. Error   t value     Pr(&gt;|t|)
## (Intercept) -9.012667 0.17332584 -51.99840 1.806130e-16
## conc         1.008000 0.01231773  81.83325 5.058935e-19
## 
## $name
## [1] &quot;P2&quot;
## 
## $startLev
## [1] 2</code></pre>
<p>This function was designed for use with rather small data-sets with
no (or very few) measures of base-line. When larger panels of data ara
available, it may be better to first define a confidence interval for
the base-line measurement and then only to consider points outside this
confidence interval for regressing dose-response relationships (see also
<a href="https://en.wikipedia.org/wiki/Detection_limit">Detection
limit</a>).</p>
</div>
<div id="high-throughput-testing-for-linear-regressions" class="section level3">
<h3>High Throughput Testing For Linear Regressions</h3>
<p>Once we have run multiple linear regressions on differt parts of the
data we might wat to compare them in a single plot. Below, we construct
10 series of data that get modeled the same way, ideally one would
obtain a slope close to 1.0. We still allow omitting some starting
points, if the resulting model would fit better.</p>
<pre class="r"><code>set.seed(2020)
x1 &lt;- matrix(rep(c(2,2:5),each=20) + runif(100) +rep(c(0,0.5,2:3,5),20), 
  byrow=FALSE, ncol=10, dimnames=list(LETTERS[1:10],NULL))
## just the 1st regression :
   summary(lm(b~a, data=data.frame(b=x1[,1], a=rep(1:5,each=2))))</code></pre>
<pre><code>## 
## Call:
## lm(formula = b ~ a, data = data.frame(b = x1[, 1], a = rep(1:5, 
##     each = 2)))
## 
## Residuals:
##     Min      1Q  Median      3Q     Max 
## -2.3811 -0.6719 -0.5001  1.3683  2.6876 
## 
## Coefficients:
##             Estimate Std. Error t value Pr(&gt;|t|)  
## (Intercept)   2.7850     1.3668   2.038   0.0759 .
## a             0.5545     0.4121   1.346   0.2153  
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
## 
## Residual standard error: 1.843 on 8 degrees of freedom
## Multiple R-squared:  0.1846, Adjusted R-squared:  0.08263 
## F-statistic: 1.811 on 1 and 8 DF,  p-value: 0.2153</code></pre>
<pre class="r"><code>## all regressions
x1.lmSum &lt;- t(sapply(lapply(rownames(x1), linModelSelect, dat=x1, 
  expect=rep(1:5,each=2), silent=TRUE, plotGraph=FALSE), 
  function(x) c(x$coef[2,c(4,1)], startFr=x$startLev)))
x1.lmSum &lt;- cbind(x1.lmSum, medQuantity=apply(x1,1,median))
x1.lmSum[,1] &lt;- log10(x1.lmSum[,1])
head(x1.lmSum)</code></pre>
<pre><code>##    Pr(&gt;|t|)  Estimate startFr medQuantity
## A -4.298797 0.7837628       1    3.781966
## B -4.828403 1.1542815       2    3.756802
## C -5.873269 0.6638477       1    5.883383
## D -6.518075 0.7793624       1    6.703049
## E -5.288792 0.8599269       1    8.725195
## F -5.031322 0.9901120       2    3.286851</code></pre>
<p>Now we can try to plot :</p>
<pre class="r"><code>wrGraphOK &lt;- requireNamespace(&quot;wrGraph&quot;, quietly=TRUE)      # check if package is available
if(wrGraphOK) wrGraph::plotW2Leg(x1.lmSum, useCol=c(&quot;Pr(&gt;|t|)&quot;,&quot;Estimate&quot;,&quot;medQuantity&quot;,&quot;startFr&quot;), 
  legendloc=&quot;topleft&quot;, txtLegend=&quot;start at&quot;)</code></pre>
<p><img src="data:image/png;base64,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" width="672" /></p>
</div>
</div>
<div id="CombinatoricsIssues" class="section level2">
<h2>Combinatorics Issues</h2>
<div id="all-pairwise-ratios" class="section level3">
<h3>All Pairwise Ratios</h3>
<p><code>ratioAllComb()</code> calculates all possible pairwise ratios
between all individual calues of x and y.</p>
<pre class="r"><code>set.seed(2014); ra1 &lt;- c(rnorm(9,2,1), runif(8,1,2))</code></pre>
<p>Let’s assume there are 2 parts of ‘x’ for which we would like to know
the representative ratio : The ratio of medians does not well reflect
the typical ratio (if each element has the same chance to be
picked).</p>
<pre class="r"><code>median(ra1[1:9]) / median(ra1[10:17])</code></pre>
<pre><code>## [1] 1.327086</code></pre>
<p>Instead, we’ll build all possible ratios and summarize then.</p>
<pre class="r"><code>summary( ratioAllComb(ra1[1:9], ra1[10:17]))</code></pre>
<pre><code>##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
##   0.359   1.142   1.274   1.290   1.506   2.777</code></pre>
<pre class="r"><code>boxplot(list(norm=ra1[1:9], unif=ra1[10:17], rat=ratioAllComb(ra1[1:9],ra1[10:17])))</code></pre>
<p><img src="data:image/png;base64,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tLSty5ieruP58PFyFpcf2uJR/E0CWtJtAd18Hujq3wjop/j96fFiLgW0uO0L6RdL9rOHbzdvi59/3z57Mt4vN1kCChAkoABBAgoQJKAAQQIKECSgAEECChAkoABBAgoQJKAAQQIKECSgAEECChAkoABBAgoQJKAAQQIKECSgAEECChAkoABBAgoQJKAAQQIKECSgAEECChAkoABBAgoQJKAAQQIKECSgAEECChAkoABBAgoQJKAAQQIKECSgAEECChAkoABBAgoQJKAAQQIKECSgAEECChAkoABBAgoQJKAAQQIKECSgAEECChAkoABBAgoQJKAAQQIKECSgAEECChAkoABBAgoQJKAAQQIKECSgAEECChAkoABBAgoQJKAAQQIKECSgAEECChAkoABBAgoQJKAAQQIKECSgAEECChAkoABBAgoQJKAAQQIKECSgAEECChAkoABBAgoQJKAAQQIKECSgAEECChAkoABBAgoQJKAAQQIKECSgAEECChAkoABBAgoQJKAAQQIKECSgAEECChAkoABBAgoQJKAAQQIKECSgAEECChAkoABBAgoQJKAAQQIKECSgAEECChAkoABBAgoQJKAAQQIKECSgAEECChAkoABBAgoQJKAAQQIKECSgAEECChAkoABBAgoQJKAAQQIKECSgAEH/C1BKbgsw36UHAAAAAElFTkSuQmCC" width="672" /></p>
</div>
<div id="count-frequency-of-terms-combined-from-different-drawings-combineasn" class="section level3">
<h3>Count Frequency Of Terms Combined From Different Drawings
(combineAsN)</h3>
<p>The main idea of this function is to count frequency of terms when
combining different drawings. Suppose, you are asking students for their
prefered hobbies. Now, you want to know how many terms will occur in
common in groups of 3 students. In the example below, simple letters are
shown instead of names of hobbies …</p>
<p>In the simplest way of using <code>combineAsN()</code> does something
similar to <em>table</em> : Here we’re looking at the full combinatorics
of making groups of <em>nCombin</em> students and let’s count the
frequency of terms found 3 times identical, 2 times or only once (ie not
cited by the others). In case multiple groups of <em>nCombin</em>
students can be formed, the average of the counts, standard error of the
mean (sem), 95% confidence interval (CI) and sd aregiven to resume the
results.</p>
<pre class="r"><code>tm1 &lt;- list(a1=LETTERS[1:7], a2=LETTERS[3:9], a3=LETTERS[6:10], a4=LETTERS[8:12])
combineAsN(tm1, nCombin=3, lev=gl(1,4))[,1,]</code></pre>
<pre><code>##       n       sem       CI       sd
## sing  5 0.8164966 2.598457 1.632993
## doub  5 0.8164966 2.598457 1.632993
## trip  1 0.5773503 1.837386 1.154701
## min2 10 1.1547005 3.674772 2.309401
## any  11 0.5773503 1.837386 1.154701</code></pre>
<p>One may imagine that different locations/coties/countries will give
different results. Thus, we’ll declare the different origins/location
using the <em>lev</em> argument. Now, this function focusses (by
default) on combinations of students from <em>nCombin</em> different
origins/location and counts how many hobbies were mentioned as all
different (‘sing’, ie number of hobbies only one student mentioned),
single repeat (‘doub’) or three times repeated (‘trip’), plus minumum
twice or ‘any’ (ie number of hobies citied no matter how many repeats).
The output is an array, the 3rd dimension contains the counts, fllowed
by sem, CI and sd.</p>
<pre class="r"><code>## different levels/groups in list-elements
tm4 &lt;- list(a1=LETTERS[1:15], a2=LETTERS[3:16], a3=LETTERS[6:17], a4=LETTERS[8:19],
  b1=LETTERS[5:19], b2=LETTERS[7:20], b3=LETTERS[11:24], b4=LETTERS[13:25], c1=LETTERS[17:26],
  d1=LETTERS[4:12], d2=LETTERS[5:11], d3=LETTERS[6:12], e1=LETTERS[7:10])
te4 &lt;- combineAsN(tm4, nCombin=4, lev=substr(names(tm4),1,1))</code></pre>
<pre><code>## combineAsN :  argument &#39;nCombin&#39; combined to &#39;remDouble&#39;=TRUE  is too high for given data, re-setting to 4</code></pre>
<pre class="r"><code>str(te4)</code></pre>
<pre><code>##  num [1:5, 1:7, 1:4] 4 4 3 8 19 ...
##  - attr(*, &quot;dimnames&quot;)=List of 3
##   ..$ : chr [1:5] &quot;sing&quot; &quot;doub&quot; &quot;trip&quot; &quot;min2&quot; ...
##   ..$ : chr [1:7] &quot;a_a_a_a&quot; &quot;a_b_c_d&quot; &quot;a_b_c_e&quot; &quot;a_b_d_e&quot; ...
##   ..$ : chr [1:4] &quot;n&quot; &quot;sem&quot; &quot;CI&quot; &quot;sd&quot;</code></pre>
<pre class="r"><code>te4[,,1]           # the counts part only</code></pre>
<pre><code>##      a_a_a_a   a_b_c_d a_b_c_e   a_b_d_e   a_c_d_e b_b_b_b   b_c_d_e
## sing       4  6.562500  7.5000  7.437500 15.333333       3 10.333333
## doub       4 12.583333 12.5625  6.708333  4.166667       8  9.666667
## trip       3  4.395833  2.8750  3.520833  3.750000       3  2.000000
## min2       8 19.145833 20.0625 14.145833 19.500000      11 20.000000
## any       19 23.541667 22.9375 19.541667 23.250000      21 22.000000</code></pre>
</div>
</div>
<div id="importexport" class="section level2">
<h2>Import/Export</h2>
<div id="batch-reading-of-csv-files" class="section level3">
<h3>Batch-Reading Of CSV Files</h3>
<p>Some software do produce a series of csv files, where a large
experiment/data-set get recorded as multiple files. The function
<code>readCsvBatch()</code> was designed for reading multiple csv files
of exactly the same layout and to join their content. As output a list
with the content of each file can be produced (one matrix per file), or
the data may be fused into an array, as shown below.</p>
<pre class="r"><code>path1 &lt;- system.file(&quot;extdata&quot;, package=&quot;wrMisc&quot;)
fiNa &lt;-  c(&quot;pl01_1.csv&quot;,&quot;pl01_2.csv&quot;,&quot;pl02_1.csv&quot;,&quot;pl02_2.csv&quot;)
datAll &lt;- readCsvBatch(fiNa, path1, silent=TRUE)
str(datAll)</code></pre>
<pre><code>##  num [1:96, 1:4, 1] 158808 174272 183176 175752 49272 ...
##  - attr(*, &quot;dimnames&quot;)=List of 3
##   ..$ : chr [1:96] &quot;A01&quot; &quot;B01&quot; &quot;C01&quot; &quot;D01&quot; ...
##   ..$ : chr [1:4] &quot;1_1.csv&quot; &quot;1_2.csv&quot; &quot;2_1.csv&quot; &quot;2_2.csv&quot;
##   ..$ : chr &quot;StainA&quot;</code></pre>
<p>When setting the first argument <em>fileNames</em> to <em>NULL</em>,
you can read all files of a given path.</p>
<pre class="r"><code>## batch reading of all csv files in specified path :
datAll2 &lt;- readCsvBatch(fileNames=NULL, path=path1, silent=TRUE)
str(datAll2)</code></pre>
<pre><code>##  num [1:96, 1:4, 1] 158808 174272 183176 175752 49272 ...
##  - attr(*, &quot;dimnames&quot;)=List of 3
##   ..$ : chr [1:96] &quot;A01&quot; &quot;B01&quot; &quot;C01&quot; &quot;D01&quot; ...
##   ..$ : chr [1:4] &quot;1_1.csv&quot; &quot;1_2.csv&quot; &quot;2_1.csv&quot; &quot;2_2.csv&quot;
##   ..$ : chr &quot;StainA&quot;</code></pre>
</div>
<div id="batch-reading-of-tabulated-files" class="section level3">
<h3>Batch-Reading Of Tabulated Files</h3>
<p>The function <code>readTabulatedBatch()</code> allows fast batch
reading of tabulated files. All files specified (or all files from a
given directory) will be read into separate data.frames of a list.
Default options are US-style comma, automatic testing for head in case
the package <em>data.table</em> is available (otheriwse : no header).
Furthermore it is possible to design a given (numeric) column and
directly filter for all lines passing a given threshold, allowing to get
smaller objects.</p>
<pre class="r"><code>path1 &lt;- system.file(&quot;extdata&quot;, package=&quot;wrMisc&quot;)
fiNa &lt;-  c(&quot;a1.txt&quot;,&quot;a2.txt&quot;)
allTxt &lt;- readTabulatedBatch(fiNa, path1)
str(allTxt)</code></pre>
<pre><code>## List of 2
##  $ a1.txt:&#39;data.frame&#39;:  33 obs. of  3 variables:
##   ..$ V1: int [1:33] 3697 3626 732 388503 10747 1564 3699 256394 345 3950 ...
##   ..$ V2: num [1:33] 4 6.24 6.63 6.71 8 ...
##   ..$ V3: num [1:33] 0.621 0.507 0.575 0.502 0.525 ...
##  $ a2.txt:&#39;data.frame&#39;:  35 obs. of  3 variables:
##   ..$ V1: int [1:35] 6414 57381 8404 10580 79611 4739 10252 221395 4256 4811 ...
##   ..$ V2: num [1:35] 1.73 5.83 6.71 7.48 9.49 ...
##   ..$ V3: num [1:35] 0.412 0.407 0.391 0.368 0.348 ...</code></pre>
</div>
<div id="reading-incomplete-tables" class="section level3">
<h3>Reading Incomplete Tables</h3>
<p>Sometimes were may get confronted with data which look like
‘incomplete’ tables. In such cases some rows do not contain as many
elements/columns as other columns. Files with this type of data may pose
a problem for <code>read.table()</code> (from the <em>utils</em>
package). In some cases using the argument <em>fill=TRUE</em> may allow
to overcome this problem. The function <em>readVarColumns()</em> (from
this package) was designed to provide better help in such odd cases.
Basically, each line is read and parsed separately, the user should
check/decide on the separator to be used.</p>
<p>The example below lists people’s names in different locations, some
locations have more persons … Sometimes exporting such data will
generate shorter lines in locations with fewer elements (here ‘London’)
and no additional separators will get added (to mark all empty fields)
towards the end. The function <code>readVarColumns()</code> (from this
package) provides help to read such data, if the content (and
separators) of the last columns are missing.</p>
<pre class="r"><code>path1 &lt;- system.file(&quot;extdata&quot;, package=&quot;wrMisc&quot;)
fiNa &lt;- &quot;Names1.tsv&quot;
datAll &lt;- readVarColumns(fiName=file.path(path1,fiNa), sep=&quot;\t&quot;)</code></pre>
<pre><code>## readVarColumns : Setting &#39;refCo&#39; to &#39;Location&#39;</code></pre>
<pre class="r"><code>str(datAll)</code></pre>
<pre><code>##  chr [1:2, 1:5] &quot;Paris&quot; &quot;London&quot; &quot;Caroline&quot; &quot;James&quot; &quot;Marie&quot; &quot;Stella&quot; ...
##  - attr(*, &quot;dimnames&quot;)=List of 2
##   ..$ : chr [1:2] &quot;Paris&quot; &quot;London&quot;
##   ..$ : chr [1:5] &quot;Location&quot; &quot;Names&quot; &quot;Names_2&quot; &quot;Names_3&quot; ...</code></pre>
<p>In this example <em>readVarColumns()</em> would give a warning (and
column-names are not recognized), if you use the argument
<em>header=TRUE</em> you’ll get an error and nothing gets read.</p>
</div>
<div id="converting-url-for-reading-tabulated-data-from-github" class="section level3">
<h3>Converting Url For Reading Tabulated Data From GitHub</h3>
<p><a href="https://github.com/">GitHub</a> allows sharing code and (to
a lower degree) data. In order to properly read tabulated (txt, tsv or
csv) data directly from a given url, the user should switch to the ‘Raw’
view. The function <code>gitDataUrl()</code> allows to conventiently
switch any url (on git) to the format from ‘Raw view’, suitable for
directly reading the data using <em>read.delim()</em> ,
<em>read.table()</em> or <em>read.csv()</em> etc …).</p>
<pre class="r"><code>## An example url with tabulated data :
url1 &lt;- &quot;https://github.com/bigbio/proteomics-metadata-standard/blob/master/annotated-projects/PXD001819/PXD001819.sdrf.tsv&quot;
gitDataUrl(url1)</code></pre>
<pre><code>## [1] &quot;https://raw.githubusercontent.com/bigbio/proteomics-metadata-standard/master/annotated-projects/PXD001819/PXD001819.sdrf.tsv&quot;</code></pre>
<p>The example below shows how this is used in the function
<em>readSampleMetaData()</em> in <a href="https://CRAN.R-project.org/package=wrProteo">wrProteo</a>.</p>
<pre class="r"><code>dataPxd &lt;- try(read.delim(gitDataUrl(url1), sep=&#39;\t&#39;, header=TRUE))
str(dataPxd)</code></pre>
<pre><code>## &#39;data.frame&#39;:    27 obs. of  24 variables:
##  $ source.name                          : chr  &quot;Sample 1&quot; &quot;Sample 1&quot; &quot;Sample 1&quot; &quot;Sample 2&quot; ...
##  $ characteristics.organism.            : chr  &quot;Saccharomyces cerevisiae&quot; &quot;Saccharomyces cerevisiae&quot; &quot;Saccharomyces cerevisiae&quot; &quot;Saccharomyces cerevisiae&quot; ...
##  $ characteristics.organism.part.       : chr  &quot;not available&quot; &quot;not available&quot; &quot;not available&quot; &quot;not available&quot; ...
##  $ characteristics.disease.             : chr  &quot;not available&quot; &quot;not available&quot; &quot;not available&quot; &quot;not available&quot; ...
##  $ characteristics.cell.type.           : chr  &quot;not applicable&quot; &quot;not applicable&quot; &quot;not applicable&quot; &quot;not applicable&quot; ...
##  $ characteristics.mass.                : chr  &quot;2 mg&quot; &quot;2 mg&quot; &quot;2 mg&quot; &quot;2 mg&quot; ...
##  $ characteristics.spiked.compound.     : chr  &quot;CT=mixture;QY=12500 amol;CN=UPS1;CV=Standards Research Group&quot; &quot;CT=mixture;QY=12500 amol;CN=UPS1;CV=Standards Research Group&quot; &quot;CT=mixture;QY=12500 amol;CN=UPS1;CV=Standards Research Group&quot; &quot;CT=mixture;QY=125 amol;CN=UPS1;CV=Standards Research Group&quot; ...
##  $ characteristics.biological.replicate.: int  1 1 1 1 1 1 1 1 1 1 ...
##  $ material.type                        : chr  &quot;lysate&quot; &quot;lysate&quot; &quot;lysate&quot; &quot;lysate&quot; ...
##  $ assay.name                           : chr  &quot;run 1&quot; &quot;run 2&quot; &quot;run 3&quot; &quot;run 4&quot; ...
##  $ technology.type                      : chr  &quot;proteomic profiling by mass spectrometry&quot; &quot;proteomic profiling by mass spectrometry&quot; &quot;proteomic profiling by mass spectrometry&quot; &quot;proteomic profiling by mass spectrometry&quot; ...
##  $ comment.label.                       : chr  &quot;AC=MS:1002038;NT=label free sample&quot; &quot;AC=MS:1002038;NT=label free sample&quot; &quot;AC=MS:1002038;NT=label free sample&quot; &quot;AC=MS:1002038;NT=label free sample&quot; ...
##  $ comment.instrument.                  : chr  &quot;AC=MS:1001742;NT=LTQ Orbitrap Velos&quot; &quot;AC=MS:1001742;NT=LTQ Orbitrap Velos&quot; &quot;AC=MS:1001742;NT=LTQ Orbitrap Velos&quot; &quot;AC=MS:1001742;NT=LTQ Orbitrap Velos&quot; ...
##  $ comment.precursor.mass.tolerance.    : chr  &quot;5 ppm&quot; &quot;5 ppm&quot; &quot;5 ppm&quot; &quot;5 ppm&quot; ...
##  $ comment.fragment.mass.tolerance.     : chr  &quot;0.8 Da&quot; &quot;0.8 Da&quot; &quot;0.8 Da&quot; &quot;0.8 Da&quot; ...
##  $ comment.cleavage.agent.details.      : chr  &quot;NT=trypsin/P;AC=MS:1001313&quot; &quot;NT=trypsin/P;AC=MS:1001313&quot; &quot;NT=trypsin/P;AC=MS:1001313&quot; &quot;NT=trypsin/P;AC=MS:1001313&quot; ...
##  $ comment.modification.parameters.     : chr  &quot;NT=Carbamidomethyl;TA=C;MT=fixed;AC=UNIMOD:4&quot; &quot;NT=Carbamidomethyl;TA=C;MT=fixed;AC=UNIMOD:4&quot; &quot;NT=Carbamidomethyl;TA=C;MT=fixed;AC=UNIMOD:4&quot; &quot;NT=Carbamidomethyl;TA=C;MT=fixed;AC=UNIMOD:4&quot; ...
##  $ comment.modification.parameters..1   : chr  &quot;NT=Oxidation;MT=variable;TA=M;AC=UNIMOD:35&quot; &quot;NT=Oxidation;MT=variable;TA=M;AC=UNIMOD:35&quot; &quot;NT=Oxidation;MT=variable;TA=M;AC=UNIMOD:35&quot; &quot;NT=Oxidation;MT=variable;TA=M;AC=UNIMOD:35&quot; ...
##  $ comment.modification.parameters..2   : chr  &quot;NT=Acetyl;AC=UNIMOD:67;PP=Protein N-term;MT=variable&quot; &quot;NT=Acetyl;AC=UNIMOD:67;PP=Protein N-term;MT=variable&quot; &quot;NT=Acetyl;AC=UNIMOD:67;PP=Protein N-term;MT=variable&quot; &quot;NT=Acetyl;AC=UNIMOD:67;PP=Protein N-term;MT=variable&quot; ...
##  $ comment.technical.replicate.         : int  1 2 3 1 2 3 1 2 3 1 ...
##  $ comment.fraction.identifier.         : int  1 1 1 1 1 1 1 1 1 1 ...
##  $ comment.file.uri.                    : chr  &quot;https://ftp.pride.ebi.ac.uk/pride/data/archive/2015/12/PXD001819/UPS1_12500amol_R1.raw&quot; &quot;https://ftp.pride.ebi.ac.uk/pride/data/archive/2015/12/PXD001819/UPS1_12500amol_R2.raw&quot; &quot;https://ftp.pride.ebi.ac.uk/pride/data/archive/2015/12/PXD001819/UPS1_12500amol_R3.raw&quot; &quot;https://ftp.pride.ebi.ac.uk/pride/data/archive/2015/12/PXD001819/UPS1_125amol_R1.raw&quot; ...
##  $ comment.data.file.                   : chr  &quot;UPS1_12500amol_R1.raw&quot; &quot;UPS1_12500amol_R2.raw&quot; &quot;UPS1_12500amol_R3.raw&quot; &quot;UPS1_125amol_R1.raw&quot; ...
##  $ factor.value.spiked.compound.        : chr  &quot;CT=mixture;QY=12500 amol;CN=UPS1;CV=Standards Research Group&quot; &quot;CT=mixture;QY=12500 amol;CN=UPS1;CV=Standards Research Group&quot; &quot;CT=mixture;QY=12500 amol;CN=UPS1;CV=Standards Research Group&quot; &quot;CT=mixture;QY=125 amol;CN=UPS1;CV=Standards Research Group&quot; ...</code></pre>
<hr />
</div>
</div>
<div id="Normalization" class="section level2">
<h2>Normalization</h2>
<p>The main reason of normalization is to remove variability in the data
which is not directly linked to the (original/biological) concept of a
given experiment. High throughput data from real world measurements may
easily contain various deformations due to technical reasons, eg slight
temperature variations, electromagnetic interference, instability of
reagents etc. In particular, transferring constant amounts of
liquids/reagents in highly repeated steps over large experiments is
often also very challenging, small variations of the amounts of liquid
(or similar) are typically addressed by normalization. However, applying
aggressive normalization to the data also brings considerable risk of
starting to loose some of the effects one intended to study. At some
point it may rather be better to eliminate a few samples or branches of
an experiment to avoid too invasive intervention. This shows that
quality control can be tightly linked to decisions about
data-normalization. In conclusion, normalization may be far more
challenging than simply running some algorithms..</p>
<p>In general, the use has to assume/define some hypothesis to justify
intervention. Sometimes specific elements of an experiment are known to
be not affected and can therefore be used to normalize the rest. Eg, if
you observe growth of trees in a forest, big blocks of rock on the floor
are assumed no to change their location. So one could use them as
alignment-marks to superpose pictures taken at slightly different
positions.</p>
<p>The hypothesis of no global changes is very common : During the
course of many biological experiments (eg change of nutrient) one
assumes that only a small portion of the elements measured (eg the
abundance of all different gene-products) do change, since many
processes of a living cell like growth, replication and interaction with
neighbour-cells are assumed not to be affected. So, if one assumes that
there are no global changes one normalizes the input-data in a way that
the average or median across each experiment will give the same value.
In analogy, if one takes photographs on a partially cloudy day, most
cameras will adjust light settings (sun r clouds) so that global
luminosity stays the same. However, if too many of the measured elements
are affected, this normalization approach will lead to (additional) loss
of information.</p>
<p>It is <em>essential</em> to understand the type of deformation(s)
data may suffer from in order to choose the appropriate approacges for
normalization. Of course, graphical representations (<a href="https://en.wikipedia.org/wiki/Principal_component_analysis">PCA</a>,
<a href="https://en.wikipedia.org/wiki/MA_plot">MA-plots</a>, etc) are
extremely important to identifying abnormalities and potential problems.
The package <a href="https://CRAN.R-project.org/package=wrGraph">wrGraph</a> offers
also complementary options useful in the context of normalization.
Again, graphical representation(s) of the data help to visualize how
different normalization procedures affect outcomes.</p>
<p>Before jumping into normalization it may be quite useful to
<em>filter</em> the data first. The overall idea is, that most
high-throughput experiments do produce some non-meaningful data
(artefacts) and it may be wise to remove such ‘bad’ data first, as they
may effect normalization (in particular <em>extreme values</em>). A
special case of problematic data concerns <em>NA</em>-values.</p>
<div id="filter-lines-of-matrix-to-reduce-content-of-nas" class="section level3">
<h3>Filter Lines Of Matrix To Reduce Content Of NAs</h3>
<p>Frequent <em>NA</em>-values may represent another potential issue.
With NA-values there is no general optimal advice. To get started, you
should try to investigate how and why NA-values occurred to check if
there is a special ‘meaning’ to them. For example, on some measurement
systems values below detection limit may be simply reported as NAs. If
the lines of your data represent different features quantified (eg
proteins), than lines with mostly NA-values represent features that may
not be well exploited anyway. Therefore many times one tries to filter
away lines of ‘bad’ data. Of course, if there is a column (sample) with
an extremely high content of NAs, one should also investigate what might
be particular with this column (sample), to see if one might be better
of to eliminate the entire column.</p>
<p>Please note, that imputing <em>NA</em>-values represents another
option instead of filtering and removing, multiple other packages
address this in detail, too. All decisions of which approach to use
should be data-driven.</p>
<div id="filter-for-each-group-of-columns-for-sufficient-data-as-non-na" class="section level4">
<h4>Filter For Each Group Of Columns For Sufficient Data As Non-NA</h4>
<p>Filter for each group of columns for sufficient data as non-NA The
function <code>presenceGrpFilt()</code> allows to</p>
<pre class="r"><code>dat1 &lt;- matrix(1:56,ncol=7)
dat1[c(2,3,4,5,6,10,12,18,19,20,22,23,26,27,28,30,31,34,38,39,50,54)] &lt;- NA
grp1 &lt;- gl(3,3)[-(3:4)]
dat1</code></pre>
<pre><code>##      [,1] [,2] [,3] [,4] [,5] [,6] [,7]
## [1,]    1    9   17   25   33   41   49
## [2,]   NA   NA   NA   NA   NA   42   NA
## [3,]   NA   11   NA   NA   35   43   51
## [4,]   NA   NA   NA   NA   36   44   52
## [5,]   NA   13   21   29   37   45   53
## [6,]   NA   14   NA   NA   NA   46   NA
## [7,]    7   15   NA   NA   NA   47   55
## [8,]    8   16   24   32   40   48   56</code></pre>
<pre class="r"><code>## now let&#39;s filter
presenceGrpFilt(dat1, gr=grp1, presThr=0.75)  # stringent</code></pre>
<pre><code>##          1     2     3
## [1,]  TRUE  TRUE  TRUE
## [2,] FALSE FALSE FALSE
## [3,] FALSE FALSE  TRUE
## [4,] FALSE FALSE  TRUE
## [5,] FALSE  TRUE  TRUE
## [6,] FALSE FALSE FALSE
## [7,]  TRUE FALSE FALSE
## [8,]  TRUE  TRUE  TRUE</code></pre>
<pre class="r"><code>presenceGrpFilt(dat1, gr=grp1, presThr=0.25)  # less stringent</code></pre>
<pre><code>##          1     2    3
## [1,]  TRUE  TRUE TRUE
## [2,] FALSE FALSE TRUE
## [3,]  TRUE FALSE TRUE
## [4,] FALSE FALSE TRUE
## [5,]  TRUE  TRUE TRUE
## [6,]  TRUE FALSE TRUE
## [7,]  TRUE FALSE TRUE
## [8,]  TRUE  TRUE TRUE</code></pre>
</div>
<div id="filter-as-separate-pairwise-groups-of-samples" class="section level4">
<h4>Filter As Separate Pairwise Groups Of Samples</h4>
<p>If you want to use your data in a pair-wise view (like running
t-tests on each line) the function <code>presenceFilt()</code> allows to
eliminate lines containing too many <em>NA</em>-values for each
pair-wise combination of the groups/levles.</p>
<pre class="r"><code>presenceFilt(dat1, gr=grp1, maxGr=1, ratM=0.1)</code></pre>
<pre><code>## presenceFilt :  correcting &#39;maxGrpMiss&#39; for group(s) 1, 2 and 3  due to ratMaxNA=0.1</code></pre>
<pre><code>##        1-2   1-3   2-3
## [1,]  TRUE  TRUE  TRUE
## [2,] FALSE FALSE FALSE
## [3,] FALSE  TRUE  TRUE
## [4,] FALSE  TRUE  TRUE
## [5,]  TRUE  TRUE  TRUE
## [6,] FALSE FALSE FALSE
## [7,]  TRUE  TRUE FALSE
## [8,]  TRUE  TRUE  TRUE</code></pre>
<pre class="r"><code>presenceFilt(dat1, gr=grp1, maxGr=2, rat=0.5)</code></pre>
<pre><code>## presenceFilt :  correcting &#39;maxGrpMiss&#39; for group(s) 1 and 2  due to ratMaxNA=0.5</code></pre>
<pre><code>##        1-2  1-3  2-3
## [1,]  TRUE TRUE TRUE
## [2,] FALSE TRUE TRUE
## [3,]  TRUE TRUE TRUE
## [4,] FALSE TRUE TRUE
## [5,]  TRUE TRUE TRUE
## [6,]  TRUE TRUE TRUE
## [7,]  TRUE TRUE TRUE
## [8,]  TRUE TRUE TRUE</code></pre>
</div>
<div id="cleaning-replicates" class="section level4">
<h4>Cleaning Replicates</h4>
<p>This procedures aims to remove (by setting to as <em>NA</em>) the
most extreme of noisy replicates. Thus, it is assumed that all columns
of the input matrix (or data.frame) are replicates of the other columns.
The <em>nOutl</em> most distant points are identified and will be set to
<em>NA</em>.</p>
<pre class="r"><code>(mat3 &lt;- matrix(c(19,20,30,40, 18,19,28,39, 16,14,35,41, 17,20,30,40), ncol=4))</code></pre>
<pre><code>##      [,1] [,2] [,3] [,4]
## [1,]   19   18   16   17
## [2,]   20   19   14   20
## [3,]   30   28   35   30
## [4,]   40   39   41   40</code></pre>
<pre class="r"><code>cleanReplicates(mat3, nOutl=1)</code></pre>
<pre><code>## cleanReplicates :  rownames of &#39;x&#39; either NULL or not unique, replacing by row-numbers</code></pre>
<pre><code>## cleanReplicates : removing 1 entries in lines 2</code></pre>
<pre><code>##   [,1] [,2] [,3] [,4]
## 1   19   18   16   17
## 2   20   19   NA   20
## 3   30   28   35   30
## 4   40   39   41   40</code></pre>
<pre class="r"><code>cleanReplicates(mat3, nOutl=3)</code></pre>
<pre><code>## cleanReplicates :  rownames of &#39;x&#39; either NULL or not unique, replacing by row-numbers</code></pre>
<pre><code>## cleanReplicates : removing 3 entries in lines 1,2,3</code></pre>
<pre><code>##   [,1] [,2] [,3] [,4]
## 1   NA   18   16   17
## 2   20   19   NA   20
## 3   30   28   NA   30
## 4   40   39   41   40</code></pre>
</div>
</div>
<div id="the-function-normalizethis" class="section level3">
<h3>The Function normalizeThis()</h3>
<p>In biological high-throughput data columns typically represent
different samples, which may be organized as replicates. During
high-throughput experiments thousands of (independent) elements are
measured (eg abundance of gene-products), they are represented by rows.
As real-world experiments are not always as perfect as we may think,
small changes in the signal measured may easily happen. Thus, the aim of
normalizing is to remove or reduce any trace/variability in the data not
related to the original experiement but due to imperfections during
detection.</p>
<p>Note, that some experiments may produce a considerable amount of
missing data (NAs) which require special attention (dedicated
developments exist in other R-packages eg in <a href="https://CRAN.R-project.org/package=wrProteo">wrProteo</a>). My
general advice is to first carefully look where such missing data is
observed and to pay attention to replicate measurements where a given
element once was measured with a real numeric value and once as missing
information (NA).</p>
<pre class="r"><code>set.seed(2015); rand1 &lt;- round(runif(300) +rnorm(300,0,2),3)
dat1 &lt;- cbind(ser1=round(100:1 +rand1[1:100]), ser2=round(1.2*(100:1 +rand1[101:200]) -2),
  ser3=round((100:1 +rand1[201:300])^1.2-3))
dat1 &lt;- cbind(dat1, ser4=round(dat1[,1]^seq(2,5,length.out=100) +rand1[11:110],1))
## Let&#39;s introduce some NAs
dat1[dat1 &lt;1] &lt;- NA
## Let&#39;s get a quick overview of the data
summary(dat1)</code></pre>
<pre><code>##       ser1             ser2             ser3            ser4          
##  Min.   :  2.00   Min.   :  1.00   Min.   :  1.0   Min.   :     37.5  
##  1st Qu.: 26.75   1st Qu.: 28.00   1st Qu.: 50.0   1st Qu.:  67210.0  
##  Median : 49.50   Median : 59.00   Median :109.0   Median : 332524.0  
##  Mean   : 51.14   Mean   : 58.79   Mean   :115.1   Mean   : 542279.4  
##  3rd Qu.: 76.25   3rd Qu.: 89.50   3rd Qu.:173.5   3rd Qu.: 925759.5  
##  Max.   :100.00   Max.   :121.00   Max.   :263.0   Max.   :2123191.7  
##                                    NA&#39;s   :1</code></pre>
<pre class="r"><code>## some selected lines (indeed, the 4th column appears always much higher)
dat1[c(1:5,50:54,95:100),]</code></pre>
<pre><code>##       ser1 ser2 ser3      ser4
##  [1,]  100  121  251   10000.6
##  [2,]  100  117  244   11500.2
##  [3,]   99  120  263   12948.1
##  [4,]   99  120  242   14885.1
##  [5,]   97  114  236   16382.3
##  [6,]   51   60  111  892534.1
##  [7,]   48   58  109  812490.4
##  [8,]   49   55  108  982907.4
##  [9,]   50   56  107 1188787.7
## [10,]   45   47  102  915343.6
## [11,]    3    6    5     206.4
## [12,]    5    2    7    2570.0
## [13,]    8    1    3   27125.8
## [14,]    6    4    5    6975.9
## [15,]    3    3    1     237.0
## [16,]    2    1   NA      37.5</code></pre>
<p>Our toy data may be normalized by a number of different criteria. In
real applications the nature of the data and the type of deformation
detected/expected will largely help deciding which normalization might
be the ‘best’ choice. Here we’ll try first normalizing by the mean, ie
all columns will be forced to end up with the same column-mean. The
trimmed mean does not consider values at extremes (as outliers are
frequently artefacts and display extreme values). When restricting even
stronger which values to consider one will eventually end up with the
median (3rd method used below).</p>
<pre class="r"><code>no1 &lt;- normalizeThis(dat1, refGrp=1:3, meth=&quot;mean&quot;)
no2 &lt;- normalizeThis(dat1, refGrp=1:3, meth=&quot;trimMean&quot;, trim=0.4)
no3 &lt;- normalizeThis(dat1, refGrp=1:3, meth=&quot;median&quot;)
no4 &lt;- normalizeThis(dat1, refGrp=1:3, meth=&quot;slope&quot;, quantFa=c(0.2,0.8))</code></pre>
<p>It is suggested to verify normalization results by plots. Note, that
<a href="https://en.wikipedia.org/wiki/Box_plot">Box plots</a> may not
be appropriate in some cases (eg multimodal distributions), for
displaying more details you may consider using <a href="https://en.wikipedia.org/wiki/Violin_plot">Violin-Plots</a> from
packages <a href="https://CRAN.R-project.org/package=vioplot">vioplot</a> or <a href="https://CRAN.R-project.org/package=wrGraph">wrGraph</a>, another
option might be a (cumulated) frequency plot (eg in package <a href="https://CRAN.R-project.org/package=wrGraph">wrGraph</a>).</p>
<p><img src="data:image/png;base64,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" width="672" /></p>
<p>You can see clearly, that the 4th data-set has a problem of range. So
we’ll see if some proportional normalization may help to make it more
comparable to the other ones.</p>
<p><img src="data:image/png;base64,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" width="672" /></p>
</div>
<div id="normalize-by-rows" class="section level3">
<h3>Normalize By Rows</h3>
<p>The standard approach for normalizing relies on consisting all
columns as collections of data who’s distribution is not supposed to
change. In some cases/projects we may want to formulate a much more
‘aggressive’ hypothesis : We consider the content of all columns
strictly as the same. For example this may be the case when comparing
with technical replicates only. In such cases one may use the function
<code>rowNormalize()</code> which tries to find the average or mean
optimal within-line normalization factor.</p>
<p>Besides, an additional mode of operation for <em>sparse data</em> has
been added : Basically, once a row contains just one NA, this row can’t
be used any more to derive a normalization factor for all rows. Thus,
with many NA-values the number of ‘complete’ rows will be low or even 0
redering this approach inefficient or impossible. Once the content of
NA-values is above a customizable threshold, the data will be broken in
smaller subsets with fewer groups of fewer columns, thus increasing the
chances of finding ‘complete’ subsets of data which will be normalized
first and added to other subsets in later steps.</p>
<p>This approach relies on the <strong>hypothesis</strong> that <em>all
data in a given line should be (aproximately) the same value</em> !
Thus, this procedure is particularly well adopted to the case when
<em>all</em> samples are multiple replicate measurements of the
<em>same</em> sample.</p>
<pre class="r"><code>set.seed(2); AA &lt;- matrix(rbinom(110, 10, 0.05), nrow=10)
AA[,4:5] &lt;- AA[,4:5] *rep(4:3, each=nrow(AA))

AA1 &lt;- rowNormalize(AA)
round(AA1, 2)</code></pre>
<pre><code>##          1    2    3    4    5    6    7    8    9   10   11
##  [1,] 0.65 0.87 2.13 0.34 3.21 0.48 2.04 0.97 0.74 4.34 0.82
##  [2,] 1.72 0.87 0.80 0.34 0.29 0.48 2.04 0.97 1.98 1.00 0.82
##  [3,] 0.65 2.33 2.13 2.59 0.29 1.27 2.04 0.97 0.74 1.00 3.57
##  [4,] 0.65 0.87 0.80 2.59 0.29 2.06 0.77 0.97 0.74 1.00 2.20
##  [5,] 2.80 0.87 0.80 0.34 3.21 0.48 2.04 0.97 0.74 1.00 0.82
##  [6,] 2.80 2.33 0.80 2.59 1.75 1.27 0.77 2.59 1.98 1.00 0.82
##  [7,] 0.65 3.79 0.80 2.59 3.21 1.27 0.77 0.97 3.21 1.00 2.20
##  [8,] 1.72 0.87 0.80 0.34 0.29 2.85 0.77 2.59 0.74 1.00 0.82
##  [9,] 0.65 0.87 3.47 2.59 0.29 1.27 0.77 0.97 1.98 1.00 0.82
## [10,] 0.65 0.87 0.80 0.34 1.75 1.27 0.77 0.97 0.74 1.00 0.82</code></pre>
<p>Now, let’s make this sparse and try normalizing:</p>
<pre class="r"><code>AC &lt;- AA
AC[which(AC &lt;1)] &lt;- NA

(AC1 &lt;- rowNormalize(AC))</code></pre>
<pre><code>##              1  2        3        4        5        6   7    8        9
##  [1,]       NA NA 2.343543       NA 3.870829       NA NaN   NA       NA
##  [2,] 1.388298 NA       NA       NA       NA       NA NaN   NA 3.597222
##  [3,]       NA  2 2.343543 3.499743       NA 2.663721 NaN   NA       NA
##  [4,]       NA NA       NA 3.499743       NA 5.327441  NA   NA       NA
##  [5,] 2.776596 NA       NA       NA 3.870829       NA NaN   NA       NA
##  [6,] 2.776596  2       NA 3.499743 1.935414 2.663721  NA 2.25 3.597222
##  [7,]       NA  4       NA 3.499743 3.870829 2.663721  NA   NA 7.194444
##  [8,] 1.388298 NA       NA       NA       NA 7.991162  NA 2.25       NA
##  [9,]       NA NA 4.687086 3.499743       NA 2.663721  NA   NA 3.597222
## [10,]       NA NA       NA       NA 1.935414 2.663721  NA   NA       NA
##             10       11
##  [1,] 2.583333       NA
##  [2,]       NA       NA
##  [3,]       NA 3.407407
##  [4,]       NA 1.703704
##  [5,]       NA       NA
##  [6,]       NA       NA
##  [7,]       NA 1.703704
##  [8,]       NA       NA
##  [9,]       NA       NA
## [10,]       NA       NA</code></pre>
<p>Like with <em>normalizeThis()</em> we can define some reference-lines
(only these lines will be considered to determine
normalization-factors)</p>
<pre class="r"><code>(AC3 &lt;- rowNormalize(AC, refLines=1:5, omitNonAlignable=TRUE))</code></pre>
<pre><code>##         1  2        3        4     5        6   7   8   9   10       11
##  [1,]  NA NA 1.909091       NA 1.750       NA NaN  NA  NA 1.75       NA
##  [2,] NaN NA       NA       NA    NA       NA NaN  NA NaN   NA       NA
##  [3,]  NA  2 1.909091 2.409836    NA 2.684932 NaN  NA  NA   NA 4.083333
##  [4,]  NA NA       NA 2.409836    NA 5.369863  NA  NA  NA   NA 2.041667
##  [5,] NaN NA       NA       NA 1.750       NA NaN  NA  NA   NA       NA
##  [6,] NaN  2       NA 2.409836 0.875 2.684932  NA NaN NaN   NA       NA
##  [7,]  NA  4       NA 2.409836 1.750 2.684932  NA  NA NaN   NA 2.041667
##  [8,] NaN NA       NA       NA    NA 8.054795  NA NaN  NA   NA       NA
##  [9,]  NA NA 3.818182 2.409836    NA 2.684932  NA  NA NaN   NA       NA
## [10,]  NA NA       NA       NA 0.875 2.684932  NA  NA  NA   NA       NA</code></pre>
<p>Please note, that the iterative procedure for <em>sparse data</em>
may consume large amounts of computational resources, in particular when
a small number of subgroups has been selected.</p>
</div>
<div id="matrix-coordinates-of-valuespoints-according-to-filtering" class="section level3">
<h3>Matrix Coordinates Of Values/Points According To Filtering</h3>
<p>Sometimes one needs to obtain the coordinates of values/points of a
matrix according to a given filtering condition. The standard approach
using <em>which()</em> gives only a <em>linearized</em> index but not
row/column, which is sufficient for replacing indexed values. If you
need to know the true row/column indexes, you may use
<code>coordOfFilt()</code>.</p>
<pre class="r"><code>set.seed(2021); ma1 &lt;- matrix(sample.int(n=40, size=27, replace=TRUE), ncol=9)
## let&#39;s test which values are &gt;37
which(ma1 &gt;37)      # doesn&#39;t tell which row &amp; col</code></pre>
<pre><code>## [1]  2  3  6  7  9 14 26</code></pre>
<pre class="r"><code>coordOfFilt(ma1, ma1 &gt;37)</code></pre>
<pre><code>##      row col
## [1,]   2   1
## [2,]   3   1
## [3,]   3   2
## [4,]   1   3
## [5,]   3   3
## [6,]   2   5
## [7,]   2   9</code></pre>
</div>
<div id="trimmed-mean" class="section level3">
<h3>Trimmed Mean</h3>
<p>Under certain circumstances using the trimmed mean may be more stable
towards outlyer values. The base function <code>mean()</code> allows to
preform symmetric trimming, thus with more trimming the result will
start converging to the <em>mean</em>. The function
<code>trimmedMean()</code> gives more flexible options for assinging
different upper- and lower fractions of the initial data to be trimmed.
When outlyer values always appear at the high (or low) end of data, such
proceeding may be useful. However, the user is encouraged to use this
with caution since there is also a risk of introducing bias.</p>
<pre class="r"><code>x &lt;- c(17:11,27:28)
mean(x)</code></pre>
<pre><code>## [1] 17</code></pre>
<pre class="r"><code>mean(x, trim=0.15)       # symmetric trimming</code></pre>
<pre><code>## [1] 16.28571</code></pre>
<pre class="r"><code>mean(x[x &lt; 25])          # manual trimming</code></pre>
<pre><code>## [1] 14</code></pre>
<pre class="r"><code>trimmedMean(x, trim=c(l=0, u=0.7))   # asymmetric trim</code></pre>
<pre><code>## [1] 13.5</code></pre>
</div>
</div>
<div id="StatisticalTesting" class="section level2">
<h2>Statistical Testing</h2>
<div id="normal-random-number-generation-with-close-fit-to-expected-mean-and-sd" class="section level3">
<h3>Normal Random Number Generation with Close Fit to Expected mean and
sd</h3>
<p>When creating random values to an expected <em>mean</em> and
<em>sd</em>, the results ontained using the standard function
<code>rnorm()</code> may deviate somehow from the expected mean and sd,
in particular with low <em>n</em>. To still produce random values
fitting closely to the expected <em>mean</em> and <em>sd</em> you may
use the function <code>rnormW()</code>. The case of <em>n=2</em> is
quite simple with one possible results. In other cases
(<em>n&gt;2</em>), there will be a random initiation which can be fixed
using the argument <em>seed</em>.</p>
<pre class="r"><code>## some sample data :
x1 &lt;- (11:16)[-5]
mean(x1); sd(x1)</code></pre>
<pre><code>## [1] 13.2</code></pre>
<pre><code>## [1] 1.923538</code></pre>
<pre class="r"><code>## the standard way for gerenating normal random values
ra1 &lt;- rnorm(n=length(x1), mean=mean(x1), sd=sd(x1))
## In particular with low n, the random values deviate somehow from expected mean and sd :
mean(ra1) -mean(x1) </code></pre>
<pre><code>## [1] -1.103347</code></pre>
<pre class="r"><code>sd(ra1) -sd(x1)</code></pre>
<pre><code>## [1] 0.3920622</code></pre>
<pre class="r"><code>## random numbers with close fit to expected mean and sd :
ra2 &lt;- rnormW(length(x1), mean(x1), sd(x1))
mean(ra2) -mean(x1) </code></pre>
<pre><code>## [1] 0</code></pre>
<pre class="r"><code>sd(ra2) -sd(x1)   # much closer to expected value</code></pre>
<pre><code>## [1] -4.440892e-16</code></pre>
<p>Thus, the second data-sets fits even with few <em>n</em> very well to
the global characteristics defined/expected.</p>
</div>
<div id="moderated-pair-wise-t-test-from-limma" class="section level3">
<h3>Moderated Pair-Wise t-Test from limma</h3>
<p>If you are not familiar with the way data is handled in the
Bioconductor package <a href="https://bioconductor.org/packages/release/bioc/html/limma.html">limma</a>
and you would like to use some of the tools for running moderated
t-tests therein, this will provide easy access using
<code>moderTest2grp()</code> :</p>
<pre class="r"><code>set.seed(2017); t8 &lt;- matrix(round(rnorm(1600,10,0.4),2), ncol=8,
  dimnames=list(paste(&quot;l&quot;,1:200), c(&quot;AA1&quot;,&quot;BB1&quot;,&quot;CC1&quot;,&quot;DD1&quot;,&quot;AA2&quot;,&quot;BB2&quot;,&quot;CC2&quot;,&quot;DD2&quot;)))
t8[3:6,1:2] &lt;- t8[3:6,1:2]+3     # augment lines 3:6 for AA1&amp;BB1
t8[5:8,5:6] &lt;- t8[5:8,5:6]+3     # augment lines 5:8 for AA2&amp;BB2 (c,d,g,h should be found)
t4 &lt;- log2(t8[,1:4]/t8[,5:8])
fit4 &lt;- moderTest2grp(t4, gl(2,2))
## now we&#39;ll use limma&#39;s topTable() function to look at the &#39;best&#39; results
if(&quot;list&quot; %in% mode(fit4)) {  # if you have limma installed we can look further
  library(limma)
  topTable(fit4, coef=1,n=5)                      # effect for 3,4,7,8
  fit4in &lt;- moderTest2grp(t4, gl(2,2), testO=&quot;&lt;&quot;)
  if(&quot;list&quot; %in% mode(fit4in)) topTable(fit4in, coef=1,n=5) }</code></pre>
<pre><code>## moderTest2grp : Testing alternative hypothesis: true difference in means is less than 0 (ie focus on 101 results with A less than B)</code></pre>
<pre><code>##           logFC    AveExpr         t      P.Value    adj.P.Val         B
## l 7  -0.4975806 -0.2436786 -8.712092 3.994695e-17 7.989390e-15 30.668381
## l 4   0.4020373  0.1890232  7.039234 1.000000e+00 1.000000e+00 17.723883
## l 8  -0.3735170 -0.2259811 -6.539873 9.417239e-11 9.417239e-09 14.392733
## l 3   0.3508834  0.1488240  6.143585 1.000000e+00 1.000000e+00 11.923522
## l 27 -0.1348878 -0.1011609 -2.361738 9.333949e-03 6.222633e-01 -3.878176</code></pre>
</div>
<div id="multiple-moderated-pair-wise-t-tests-from-limma" class="section level3">
<h3>Multiple Moderated Pair-Wise t-Tests From limma</h3>
<p>If you want to make multiple pair-wise comparisons using
<code>moderTestXgrp()</code> :</p>
<pre class="r"><code>grp &lt;- factor(rep(LETTERS[c(3,1,4)], c(2,3,3)))
set.seed(2017); t8 &lt;- matrix(round(rnorm(208*8,10,0.4),2), ncol=8,
  dimnames=list(paste(letters[], rep(1:8,each=26),sep=&quot;&quot;), paste(grp,c(1:2,1:3,1:3),sep=&quot;&quot;)))
t8[3:6,1:2] &lt;- t8[3:6,1:2] +3                    # augment lines 3:6 (c-f) 
t8[5:8,c(1:2,6:8)] &lt;- t8[5:8,c(1:2,6:8)] -1.5    # lower lines 
t8[6:7,3:5] &lt;- t8[6:7,3:5] +2.2                  # augment lines 
## expect to find C/A in c,d,g, (h)
## expect to find C/D in c,d,e,f
## expect to find A/D in f,g,(h)  
test8 &lt;- moderTestXgrp(t8, grp) 
head(test8$p.value, n=8) </code></pre>
<pre><code>##             A-C          A-D          C-D
## a1 8.736828e-02 6.776543e-02 9.397304e-01
## b1 4.384118e-01 5.400019e-01 8.205610e-01
## c1 1.094834e-19 6.344497e-01 2.571471e-21
## d1 2.671725e-13 9.915692e-01 2.858699e-13
## e1 1.802454e-03 2.413137e-08 9.735465e-16
## f1 3.188362e-01 2.527208e-32 2.226490e-22
## g1 1.166242e-29 6.410057e-33 5.484445e-01
## h1 1.141181e-05 1.943795e-05 5.674938e-01</code></pre>
</div>
<div id="transform-p-values-to-local-false-discovery-rate-lfdr" class="section level3">
<h3>Transform p-values To Local False Discovery Rate (lfdr)</h3>
<p>To get an introduction into local false discovery rate estimations
you may read <a href="https://doi.org/10.1093/bioinformatics/btn209">Strimmer 2008</a>.
A convenient way to get lfdr values calculated by the package <a href="https://CRAN.R-project.org/package=fdrtool">fdrtool</a> is
available via the function <code>pVal2lfdr()</code>.</p>
<p>Note, that the toy-example used below is too small for estimating
meaningful lfdr values. For this reason the function <em>fdrtool()</em>
from package <a href="https://CRAN.R-project.org/package=fdrtool">fdrtool</a> will issue
warnings.</p>
<pre class="r"><code>set.seed(2017); t8 &lt;- matrix(round(rnorm(160,10,0.4),2), ncol=8, dimnames=list(letters[1:20],
  c(&quot;AA1&quot;,&quot;BB1&quot;,&quot;CC1&quot;,&quot;DD1&quot;,&quot;AA2&quot;,&quot;BB2&quot;,&quot;CC2&quot;,&quot;DD2&quot;)))
t8[3:6,1:2] &lt;- t8[3:6,1:2] +3   # augment lines 3:6 (c-f) for AA1&amp;BB1
t8[5:8,5:6] &lt;- t8[5:8,5:6] +3   # augment lines 5:8 (e-h) for AA2&amp;BB2 (c,d,g,h should be found)
head(pVal2lfdr(apply(t8, 1, function(x) t.test(x[1:4], x[5:8])$p.value)))</code></pre>
<pre><code>## Warning in fdrtool::fdrtool(z, statistic = &quot;pvalue&quot;, plot = FALSE, verbose =
## !silent): There may be too few input test statistics for reliable FDR
## calculations!</code></pre>
<pre><code>##         a         b         c         d         e         f 
## 1.0000000 0.5753562 0.5753562 1.0000000 1.0000000 1.0000000</code></pre>
</div>
<div id="confindence-intervals-under-normal-distribution" class="section level3">
<h3>Confindence Intervals (under Normal Distribution)</h3>
<p>The <a href="https://en.wikipedia.org/wiki/Confidence_interval">confindence
interval (CI)</a> is a common way of describing the uncertainity of
measured or estimated values. The function <code>confInt()</code> allows
calculating the confidence interval of the mean (using the functions
<em>qt()</em> and <em>sd()</em>) under a given <a href="https://en.wikipedia.org/wiki/Statistical_significance">significance
level (alpha)</a>. assuming that the <a href="https://en.wikipedia.org/wiki/Normal_distribution">Normal
distribution</a> is valid.</p>
<pre class="r"><code>set.seed(2022); ran &lt;- rnorm(50)
confInt(ran, alpha=0.05)</code></pre>
<pre><code>## [1] 0.248199</code></pre>
<pre class="r"><code>## plot points and confindence interval of mean
plot(ran, jitter(rep(1, length(ran))), ylim=c(0.95, 1.05), xlab=&quot;random variable &#39;ran&#39;&quot;,main=&quot;Points and Confidence Interval of Mean (alpha=0.05)&quot;, ylab=&quot;&quot;, las=1)
points(mean(ran), 0.97, pch=3, col=4)     # mean
lines(mean(ran) +c(-1, 1) *confInt(ran, 0.05), c(0.97, 0.97), lwd=4, col=4)  # CI
legend(&quot;topleft&quot;,&quot;95% conficence interval of mean&quot;, text.col=4,col=4,lty=1,lwd=1,seg.len=1.2,cex=0.9,xjust=0,yjust=0.5)</code></pre>
<p><img src="data:image/png;base64,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" width="672" /></p>
</div>
<div id="extract-groups-of-replicates-from-pair-wise-column-names" class="section level3">
<h3>Extract Groups Of Replicates From Pair-Wise Column-Names</h3>
<p>When running multiple pairwise tests (using <em>moderTestXgrp()</em>)
the column-names are concatenated group-names. To get the index of which
group has been used in which pair-wise set you may use the function
<code>matchSampToPairw()</code>, as shown below.</p>
<pre class="r"><code>## make example if limma is not installed
if(!requireNamespace(&quot;limma&quot;, quietly=TRUE)) test8 &lt;- list(FDR=matrix(1, nrow=2, ncol=3, dimnames=list(NULL,c(&quot;A-C&quot;,&quot;A-D&quot;,&quot;C-D&quot;))))
matchSampToPairw(unique(grp), colnames(test8$FDR)) </code></pre>
<pre><code>##     le ri
## A-C  2  1
## A-D  2  3
## C-D  1  3</code></pre>
</div>
<div id="extract-numeric-part-of-column-names" class="section level3">
<h3>Extract Numeric Part Of Column-Names</h3>
<p>When running multiple pairwise tests (using <em>moderTestXgrp()</em>)
the results will be in adjacent columns and the group-names reflected in
the column-names. In the case measurements from multiple levels of a
given variable are compared it is useful to extract the numeric part,
the function <code>numPairDeColNames()</code> provides support to do so.
When extracting just the numeric part, unit names will get lost, though.
Note, if units used are not constant (eg seconds and milliseconds mixed)
the extracted numeric values do not reflect the real quantitative
context any more.</p>
<pre class="r"><code>mat1 &lt;- matrix(1:8, nrow=2, dimnames=list(NULL, paste0(1:4,&quot;-&quot;,6:9)))
numPairDeColNames(mat1)</code></pre>
<pre><code>## numPartDeColNames : PROBLEM ? : &#39;stripTxt&#39; does REMOVE the separator &#39;sep&#39; ! Select a different separator or &#39;stripTxt&#39; strategy to resolve pairwise combinations !</code></pre>
<pre><code>##      index log2rat conc1 conc2
## [1,]     1   2.585     1     6
## [2,]     2   1.807     2     7
## [3,]     3   1.415     3     8
## [4,]     4   1.170     4     9</code></pre>
</div>
<div id="automatic-determination-of-replicate-structure-based-on-meta-data" class="section level3">
<h3>Automatic Determination Of Replicate Structure Based On
Meta-Data</h3>
<p>In order to run statistical testing the user must know which sample
should be considered replicate of whom. The function <code>()</code>
aims to provide help by checking all column of a matrix of meta-data
with the aim of identifying the replicate-status.</p>
<p>To do so, all columns are examined how many groups of replicats they
may design. Depending on the argumen <em>method</em> various options for
choosing automatically exist : The default <em>method=“combAll”</em>
will select the column with the median number of groups (not counting
all-different or all-same columns)). When using as
<em>method=“combAll”</em> (ie combine all columns that are neither
all-different nor all-same), there is risk all lines (samples) will be
be considered different and no replicates remain. To avoid this
situation the argument -method_ can be set to <em>“combNonOrth”</em>.
Then, it will be checked if adding more columns will lead to complete
loss of replicates, and -if so- concerned columns omitted.</p>
<pre class="r"><code>## column a is all different, b is groups of 2,
## c &amp; d  are groups of 2 nut NOT &#39;same general&#39; pattern as b
strX &lt;- data.frame(a=letters[18:11], b=letters[rep(c(3:1,4), each=2)],
 c=letters[rep(c(5,8:6), each=2)], d=letters[c(1:2,1:3,3:4,4)],
 e=letters[rep(c(4,8,4,7),each=2)], f=rep(&quot;z&quot;,8) )
strX</code></pre>
<pre><code>##   a b c d e f
## 1 r c e a d z
## 2 q c e b d z
## 3 p b h a h z
## 4 o b h b h z
## 5 n a g c d z
## 6 m a g c d z
## 7 l d f d g z
## 8 k d f d g z</code></pre>
<pre class="r"><code>replicateStructure(strX[,1:2])</code></pre>
<pre><code>## $col
## b 
## 2 
## 
## $lev
## c c b b a a d d 
## 1 1 2 2 3 3 4 4 
## 
## $meth
## [1] &quot;single informative col&quot;</code></pre>
<pre class="r"><code>replicateStructure(strX[,1:4], method=&quot;combAll&quot;)</code></pre>
<pre><code>## $col
## b d 
## 2 4 
## 
## $lev
## c_a c_b b_a b_b a_c a_c d_d d_d 
##   1   2   3   4   5   5   6   6 
## 
## $meth
## [1] &quot;comb all col&quot;</code></pre>
<pre class="r"><code>replicateStructure(strX[,1:4], method=&quot;combAll&quot;, exclNoRepl=FALSE)</code></pre>
<pre><code>## $col
## a 
## 1 
## 
## $lev
## 1 2 3 4 5 6 7 8 
## 1 2 3 4 5 6 7 8 
## 
## $meth
## [1] &quot;(shortcut, first) single col at max divergence&quot;
## 
## $allCols
##      a b c d
## [1,] 1 1 1 1
## [2,] 2 1 1 2
## [3,] 3 2 2 1
## [4,] 4 2 2 2
## [5,] 5 3 3 3
## [6,] 6 3 3 3
## [7,] 7 4 4 4
## [8,] 8 4 4 4</code></pre>
<pre class="r"><code>replicateStructure(strX[,1:4], method=&quot;combNonOrth&quot;, exclNoRepl=TRUE)</code></pre>
<pre><code>## $col
## b d 
## 2 4 
## 
## $lev
## c_a c_b b_a b_b a_c a_c d_d d_d 
##   1   2   3   4   5   5   6   6 
## 
## $meth
## [1] &quot;combNonOrth col&quot;</code></pre>
<pre class="r"><code>replicateStructure(strX, method=&quot;lowest&quot;)</code></pre>
<pre><code>## $col
## e 
## 5 
## 
## $lev
## d d h h d d g g 
## 1 1 2 2 1 1 3 3 
## 
## $meth
## [1] &quot;single min col&quot;</code></pre>
</div>
</div>
<div id="WorkingWithClustering" class="section level2">
<h2>Working With Clustering</h2>
<p>Multiple concepts for clustering have been deeveloped, most of them
allow extracting a vector with the cluster-numbers. Here some functions
helping to work with the output of such clustering results are
presented.</p>
<div id="prepare-data-for-clustering" class="section level3">
<h3>Prepare Data For Clustering</h3>
<p>The way how to prepare data for clustering may be as important as the
choice of the actual clustering-algorithm …</p>
<p>Many clustering algorithms are available in R (eg see also <a href="https://CRAN.R-project.org/view=Cluster">CRAN Task View: Cluster
Analysis &amp; Finite Mixture Models</a>), many of them require the
input data to be standardized. The regular way of standardizing sets all
elements to mean=0 and sd=1. To do so, the function <code>scale()</code>
may be used.</p>
<pre class="r"><code>dat &lt;- matrix(2*round(runif(100),2), ncol=4)
mean(dat); sd(dat)</code></pre>
<pre><code>## [1] 1.0348</code></pre>
<pre><code>## [1] 0.5991349</code></pre>
<pre class="r"><code>datS &lt;- scale(dat)
apply(datS, 2, sd)</code></pre>
<pre><code>## [1] 1 1 1 1</code></pre>
<pre class="r"><code># each column was teated separately
mean(datS); sd(datS); range(datS)</code></pre>
<pre><code>## [1] 1.274615e-17</code></pre>
<pre><code>## [1] 0.9847319</code></pre>
<pre><code>## [1] -1.898224  1.708967</code></pre>
<pre class="r"><code># the mean is almost 0.0 and the sd almost 1.0

datB &lt;- scale(dat, center=TRUE, scale=FALSE)
mean(datB); sd(datB); range(datB)              # mean is almost 0</code></pre>
<pre><code>## [1] 4.435522e-18</code></pre>
<pre><code>## [1] 0.5815165</code></pre>
<pre><code>## [1] -1.2096  0.8984</code></pre>
<p>However, if you want the entire data-set and not each column
sparately, you may use <code>standardW()</code>. Thus, relative
differences visible within a line will be conserved. Furthermore, in
case of 3-dim arrays, this function returns also the same dimensions as
the input.</p>
<pre class="r"><code>datS2 &lt;- standardW(dat)
apply(datS2, 2, sd)</code></pre>
<pre><code>## [1] 1.1773030 0.9158595 0.9519728 0.8688335</code></pre>
<pre class="r"><code>summary(datS2)</code></pre>
<pre><code>##        V1                V2                V3                V4         
##  Min.   :-1.6938   Min.   :-1.6270   Min.   :-1.6604   Min.   :-1.5602  
##  1st Qu.:-1.0929   1st Qu.:-0.5922   1st Qu.:-0.9594   1st Qu.:-1.0595  
##  Median : 0.9767   Median : 0.2757   Median :-0.3585   Median :-0.4587  
##  Mean   : 0.3251   Mean   : 0.1115   Mean   :-0.1289   Mean   :-0.3078  
##  3rd Qu.: 1.3106   3rd Qu.: 0.8098   3rd Qu.: 0.7431   3rd Qu.: 0.3425  
##  Max.   : 1.5442   Max.   : 1.6110   Max.   : 1.2438   Max.   : 1.1770</code></pre>
<pre class="r"><code>mean(datS2); sd(datS2)</code></pre>
<pre><code>## [1] 1.046597e-16</code></pre>
<pre><code>## [1] 1</code></pre>
<pre class="r"><code>datS3 &lt;- standardW(dat, byColumn=TRUE)
apply(datS3, 2, sd)</code></pre>
<pre><code>## [1] 0.849399 1.091871 1.050450 1.150969</code></pre>
<pre class="r"><code>summary(datS3)</code></pre>
<pre><code>##        V1                V2                 V3                V4         
##  Min.   :-1.7149   Min.   :-1.97112   Min.   :-1.6439   Min.   :-1.5952  
##  1st Qu.:-1.0060   1st Qu.:-1.05991   1st Qu.:-0.7672   1st Qu.:-0.6347  
##  Median :-0.1696   Median : 0.01531   Median : 0.2672   Median : 0.4987  
##  Mean   :-0.2762   Mean   :-0.12174   Mean   : 0.1354   Mean   : 0.3542  
##  3rd Qu.: 0.4613   3rd Qu.: 0.82628   3rd Qu.: 1.0474   3rd Qu.: 1.3536  
##  Max.   : 1.0922   Max.   : 1.63725   Max.   : 1.8276   Max.   : 2.2084</code></pre>
<pre class="r"><code>mean(datS3); sd(datS3)</code></pre>
<pre><code>## [1] 0.022922</code></pre>
<pre><code>## [1] 1.065665</code></pre>
<p>Sometimes it is sufficient to only set the minimum and maximum to a
given range.</p>
<pre class="r"><code>datR2 &lt;- apply(dat, 2, scaleXY, 1, 100)
summary(datR2); sd(datR2)</code></pre>
<pre><code>##        V1               V2               V3               V4        
##  Min.   :  1.00   Min.   :  1.00   Min.   :  1.00   Min.   :  1.00  
##  1st Qu.: 19.37   1st Qu.: 32.64   1st Qu.: 24.90   1st Qu.: 19.11  
##  Median : 82.65   Median : 59.18   Median : 45.38   Median : 40.84  
##  Mean   : 62.73   Mean   : 54.15   Mean   : 53.21   Mean   : 46.30  
##  3rd Qu.: 92.86   3rd Qu.: 75.51   3rd Qu.: 82.93   3rd Qu.: 69.82  
##  Max.   :100.00   Max.   :100.00   Max.   :100.00   Max.   :100.00</code></pre>
<pre><code>## [1] 32.14382</code></pre>
</div>
<div id="characterize-clustering-results" class="section level3">
<h3>Characterize Clustering Results</h3>
<p>Here a very basic clustering example…</p>
<pre class="r"><code>nGr &lt;- 3
irKm &lt;- stats::kmeans(iris[,1:4], nGr, nstart=nGr*4)             # no need to standardize
   table(irKm$cluster, iris$Species)</code></pre>
<pre><code>##    
##     setosa versicolor virginica
##   1      0         48        14
##   2      0          2        36
##   3     50          0         0</code></pre>
<pre class="r"><code>   #wrGraph::plotPCAw(t(as.matrix(iris[,1:4])), sampleGrp=irKm,colBase=irKm$cluster,useSymb=as.numeric(as.factor(iris$Species)))</code></pre>
<p>Using the function <code>reorgByCluNo()</code> we can now ‘apply’ the
clustering result to the initial data to obtain other information.</p>
<pre class="r"><code>## sort results by cluster number
head(reorgByCluNo(iris[,-5], irKm$cluster))</code></pre>
<pre><code>##     Sepal.Length Sepal.Width Petal.Length Petal.Width index  geoMean cluNo
## 118          7.7         3.8          6.7         2.2   118 4.557146     1
## 110          7.2         3.6          6.1         2.5   110 4.458884     1
## 132          7.9         3.8          6.4         2.0   132 4.427465     1
## 136          7.7         3.0          6.1         2.3   136 4.242945     1
## 119          7.7         2.6          6.9         2.3   119 4.221922     1
## 106          7.6         3.0          6.6         2.1   106 4.216232     1</code></pre>
<pre class="r"><code>tail(reorgByCluNo(iris[,-5], irKm$cluster))</code></pre>
<pre><code>##    Sepal.Length Sepal.Width Petal.Length Petal.Width index  geoMean cluNo
## 23          4.6         3.6          1.0         0.2    23 1.349033     3
## 33          5.2         4.1          1.5         0.1    33 1.337272     3
## 38          4.9         3.6          1.4         0.1    38 1.253593     3
## 10          4.9         3.1          1.5         0.1    10 1.228605     3
## 13          4.8         3.0          1.4         0.1    13 1.191578     3
## 14          4.3         3.0          1.1         0.1    14 1.091429     3</code></pre>
<p>Let’s calculate the median and sd values for each cluster:</p>
<pre class="r"><code>## median an CV
ir2 &lt;- reorgByCluNo(iris[,-5], irKm$cluster, addInfo=FALSE, retList=TRUE)</code></pre>
<pre class="r"><code>sapply(ir2, function(x) apply(x, 2, median))</code></pre>
<pre><code>##                1    2   3
## Sepal.Width  2.8 3.00 3.4
## Petal.Length 4.5 5.65 1.5
## Petal.Width  1.4 2.10 0.2</code></pre>
<pre class="r"><code>sapply(ir2, colSds)</code></pre>
<pre><code>## Warning in colSums(matrix(as.numeric(!is.na(t(dat))), ncol = nrow(dat)) * :
## longer object length is not a multiple of shorter object length
## Warning in colSums(matrix(as.numeric(!is.na(t(dat))), ncol = nrow(dat)) * :
## longer object length is not a multiple of shorter object length
## Warning in colSums(matrix(as.numeric(!is.na(t(dat))), ncol = nrow(dat)) * :
## longer object length is not a multiple of shorter object length</code></pre>
<pre><code>## $`1`
##         51         52         54         55         56         57         58 
## 0.07001335 0.06000809 0.07828623 0.02853218 0.02287431 0.08354720 0.15709795 
##         59         60         61         62         63         64         65 
## 0.03700469 0.06364329 0.15923773 0.04151695 0.10273735 0.04399074 0.10485173 
##         66         67         68         69         70         71         72 
## 0.04523536 0.03599045 0.06735713 0.07202384 0.08265631 0.09082568 0.05363288 
##         73         74         75         76         77         79         80 
## 0.07271801 0.04979830 0.02853218 0.03251681 0.05263765 0.02518504 0.12859209 
##         81         82         83         84         85         86         87 
## 0.09794136 0.11384682 0.07020193 0.09312551 0.03599045 0.08717141 0.06031574 
##         88         89         90         91         92         93         94 
## 0.05991990 0.05238589 0.06200184 0.03547245 0.04189733 0.06161683 0.16120159 
##         95         96         97         98         99        100        102 
## 0.03076184 0.05048383 0.03584321 0.02853218 0.18621084 0.04183417 0.10854413 
##        107        114        115        120        122        124        127 
## 0.04856173 0.11088184 0.15338493 0.10502810 0.09748133 0.08025421 0.07035242 
##        128        134        139        143        147        150 
## 0.08625665 0.09108731 0.07709505 0.10854413 0.10296872 0.10685009 
## 
## $`2`
##         53         78        101        103        104        105        106 
## 0.16732675 0.13693850 0.09030345 0.02903775 0.05785108 0.02620532 0.14163626 
##        108        109        110        111        112        113        116 
## 0.10589162 0.10474356 0.12618014 0.10821691 0.09923436 0.04187571 0.08444247 
##        117        118        119        121        123        125        126 
## 0.06096385 0.19876132 0.20908513 0.04354104 0.16419450 0.03814256 0.06491885 
##        129        130        131        132        133        135        136 
## 0.05091989 0.07895804 0.07922781 0.16153057 0.05495068 0.13704234 0.07088912 
##        137        138        140        141        142        144        145 
## 0.07967540 0.05990466 0.05660830 0.05906771 0.11215440 0.05021665 0.08003167 
##        146        148        149 
## 0.09749905 0.09069640 0.08635798 
## 
## $`3`
##           1           2           3           4           5           6 
## 0.015080735 0.062129555 0.040492882 0.047626095 0.026933024 0.078655020 
##           7           8           9          10          11          12 
## 0.012408029 0.009415575 0.076230585 0.051575979 0.039781033 0.021162153 
##          13          14          15          16          17          18 
## 0.065206736 0.082751657 0.090118290 0.140693907 0.074606998 0.015612658 
##          19          20          21          22          23          24 
## 0.063558426 0.053973538 0.034859485 0.044981629 0.070731455 0.052981321 
##          25          26          27          28          29          30 
## 0.063042584 0.064577749 0.029810284 0.013358480 0.011731694 0.038635925 
##          31          32          33          34          35          36 
## 0.051258449 0.023010202 0.098389480 0.110835786 0.047626095 0.050049771 
##          37          38          39          40          41          42 
## 0.026164316 0.033424908 0.065705589 0.009415575 0.026474478 0.162978902 
##          43          44          45          46          47          48 
## 0.040492882 0.055244170 0.084990276 0.062260808 0.057061370 0.034387943 
##          49          50 
## 0.039781033 0.021354157</code></pre>
<p>Besides, we have already seen the function
<code>cutArrayInCluLike()</code> in section <a href="#WorkingWithArrays">Working with Arrays</a> ‘Working with
Arrays’.</p>
</div>
<div id="remove-or-reassign-orphans" class="section level3">
<h3>Remove or Reassign Orphans</h3>
<p>In some some circumstances clusters/groups with very vew individuals
are not productive during further evalualtions (in particular in the
context of interaction-netwoks). The function <code>rmOrphans()</code>
allows identifying and modifying cluster- or group-assignments of such
very small groups (‘orphans’).</p>
<p>In the example below a vector of cluster-assignments (‘x’) is treated
by different options to remove orphans :</p>
<pre class="r"><code>x=c(3:1,3:4,4:6,5:3)
cbind(x, def=rmOrphans(x), assign1=rmOrphans(x, reassign=TRUE), 
  assign1=rmOrphans(x, minN=0.2, reassign=TRUE) )</code></pre>
<pre><code>##       x def assign1 assign1
##  [1,] 3   3       3       3
##  [2,] 2  NA       3       3
##  [3,] 1  NA       3       3
##  [4,] 3   3       3       3
##  [5,] 4   4       4       4
##  [6,] 4   4       4       4
##  [7,] 5   5       5       4
##  [8,] 6  NA       5       4
##  [9,] 5   5       5       4
## [10,] 4   4       4       4
## [11,] 3   3       3       3</code></pre>
</div>
</div>
<div id="TreeLikeStructures" class="section level2">
<h2>Tree-Like Structures</h2>
<div id="filter-lists-of-connected-nodes-extension-of-networks-as-sandwich" class="section level3">
<h3>Filter Lists Of Connected Nodes, Extension Of Networks As
‘Sandwich’</h3>
<p>When interogating network-databases (like String for proteins or the
coexpressionDB for gene co-expression) typically a (semi-)quantitatve
value is supplied with the connection of node ‘A’ to node ‘B’.<br />
In many cases, it may be useful to filter the initial query-output to
retain only strong interactions. Furthermore, it may be of interest to
expand such networks by nodes allowing to (further) inter-connect
initial query-nodes (so called ‘Sandwich’ nodes as they are in the
middle of initial nodes), for such nodes a separate (eg even more
stringent) threshold can be applied.</p>
<p>Here let’s suppose nodes have 3-digit names (ie numbers). 7 nodes of
an initial query gave 1 to 7 conected nodes, the results are presented
as list of data.frames where the 1st column is the connected node and
the 2nd column the quality score of the connection (edge). Furthemore,
let’s assume that here lower scores are better.</p>
<pre class="r"><code>lst2 &lt;- list(&#39;121&#39;=data.frame(ID=as.character(c(141,221,228,229,449)),11:15), 
  &#39;131&#39;=data.frame(ID=as.character(c(228,331,332,333,339)),11:15), 
  &#39;141&#39;=data.frame(ID=as.character(c(121,151,229,339,441,442,449)),c(11:17)), 
  &#39;151&#39;=data.frame(ID=as.character(c(449,141,551,552)),11:14),
  &#39;161&#39;=data.frame(ID=as.character(171),11),
  &#39;171&#39;=data.frame(ID=as.character(161),11),
  &#39;181&#39;=data.frame(ID=as.character(881:882),11:12) )</code></pre>
<p>Now, we’d like to keep the core network consisting of all (dirctly)
interconnected nodes with scores below 20 :</p>
<pre class="r"><code>(nw1 &lt;- filterNetw(lst2, limInt=20, sandwLim=NULL, remOrphans=FALSE))</code></pre>
<pre><code>## filterNetw : Invalid entry for &#39;filtCol&#39;: should be integer (of length=1) to designate which column to use or column-name; setting to 2</code></pre>
<pre><code>## filterNetw : 2 element(s) had no data remaining after filtering ...</code></pre>
<pre><code>## filterNetw : .filterNetw : Removing 3 (reverse) redundant mappings</code></pre>
<pre><code>##   Node1 Node2 edgeScore toSandw
## 1   121   141        11   FALSE
## 2   141   151        12   FALSE
## 3   161   171        11   FALSE</code></pre>
<p>In the resulting output the 1st column now represents the
query-nodes, the 2nd column all connected nodes based on filtering
scores for edges, and the 3rd colum the score for the edges.</p>
<p>Let’s also remove all nodes not connected to a backbone at least 3
nodes long, ie remove orphan pairs of nodes :</p>
<pre class="r"><code>(nw2 &lt;- filterNetw(lst2, limInt=20, sandwLim=NULL, remOrphans=TRUE))</code></pre>
<pre><code>## filterNetw : Invalid entry for &#39;filtCol&#39;: should be integer (of length=1) to designate which column to use or column-name; setting to 2</code></pre>
<pre><code>## filterNetw : 2 element(s) had no data remaining after filtering ...</code></pre>
<pre><code>## filterNetw : .filterNetw : Removing 3 (reverse) redundant mappings</code></pre>
<pre><code>##   Node1 Node2 edgeScore toSandw
## 1   121   141        11   FALSE
## 2   141   151        12   FALSE</code></pre>
<p>If you want to expand this network by nodes allowing to further
interconnect the nodes from above, we can add all ‘sandwich’ nodes
(let’s use a threshold of inferior/equal to 14 which will use only the
better ‘sandwich’-edges) :</p>
<pre class="r"><code>(nw3 &lt;- filterNetw(lst2, limInt=20, sandwLim=14, remOrphans=TRUE))</code></pre>
<pre><code>## filterNetw : Invalid entry for &#39;filtCol&#39;: should be integer (of length=1) to designate which column to use or column-name; setting to 2</code></pre>
<pre><code>## filterNetw : 1 element(s) had no data remaining after filtering ...</code></pre>
<pre><code>## filterNetw : .filterNetw : Removing 3 (reverse) redundant mappings</code></pre>
<pre><code>##   Node1 Node2 edgeScore toSandw
## 1   121   141        11   FALSE
## 2   121   228        13    TRUE
## 3   121   229        14    TRUE
## 4   131   228        11    TRUE
## 5   141   151        12   FALSE
## 6   141   229        13    TRUE</code></pre>
</div>
<div id="convert-collection-of-pairs-of-nodes-to-propensity-matrix" class="section level3">
<h3>Convert Collection Of Pairs Of Nodes To Propensity Matrix</h3>
<p>Many times networks get created from pairs of nodes. One way to
represent the full network is via propensisty matrixes. Several advanced
tools and packages rather accept such propensisty matrixes as input.
Here, it is assumed that each line of the input represents a separate
pair of nodes connected by an edge.</p>
<pre class="r"><code>pairs3L &lt;- matrix(LETTERS[c(1,3,3, 2,2,1)], ncol=2)      # loop of 3
(netw13pr &lt;- pairsAsPropensMatr(pairs3L))                # as prop matr</code></pre>
<pre><code>##   1 2 3
## 1 0 1 1
## 2 1 0 1
## 3 1 1 0</code></pre>
</div>
<div id="characterize-individual-contribution-of-single-edges-in-tree-structures" class="section level3">
<h3>Characterize Individual Contribution Of Single Edges In
Tree-Structures</h3>
<pre class="r"><code>path1 &lt;- matrix(c(17,19,18,17, 4,4,2,3), ncol=2,
  dimnames=list(c(&quot;A/B/C/D&quot;,&quot;A/B/G/D&quot;,&quot;A/H&quot;,&quot;A/H/I&quot;), c(&quot;sumLen&quot;,&quot;n&quot;)))
contribToContigPerFrag(path1)</code></pre>
<pre><code>##   sumLe n.frag len.rat
## A    19      4   1.000
## B    19      4   1.000
## C    17      4   0.895
## D    19      4   1.000
## G    19      4   1.000
## H    18      2   0.947
## I    17      3   0.895</code></pre>
</div>
<div id="count-same-start--and-end--sites-of-edges-or-fragments" class="section level3">
<h3>Count Same Start- And End- Sites Of Edges (Or Fragments)</h3>
<p>If you have a set of fragments from a common ancestor and the
fragment’s start- and end-sites are marked by index-positions
(integers), you can make a simple graphical display :</p>
<pre class="r"><code>frag1 &lt;- cbind(beg=c(2,3,7,13,13,15,7,9,7, 3,3,5), end=c(6,12,8,18,20,20,19,12,12, 4,5,7))
rownames(frag1) &lt;- letters[1:nrow(frag1)]
simpleFragFig(frag1)</code></pre>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABUAAAAPACAMAAADDuCPrAAAAvVBMVEUAAAAAADoAAGYAOjoAOmYAOpAAZrY6AAA6OgA6Ojo6OmY6ZmY6ZpA6ZrY6kJA6kLY6kNtmAABmOgBmOjpmZjpmZmZmZpBmkLZmkNtmtttmtv+QOgCQZgCQZjqQZmaQtraQttuQ29uQ2/+zs7O2ZgC2Zjq2kDq2kGa225C229u22/+2///MzMzbkDrbkGbbtmbbtpDbtrbb25Db27bb2//b/7bb/9vb////tmb/25D/27b/29v//7b//9v///+WDMyvAAAACXBIWXMAAB2HAAAdhwGP5fFlAAAgAElEQVR4nO3dbWMb55WY4aEsiYkbN5KTXddmt3UVum5sMfZ20+rFIv//z1oABMl5yAMaPAKfmcO5ri9yBAoHGuLcAYgBNFwAkDJMfQMAqhJQgCQBBUgSUIAkAQVIElCAJAEFSBJQgCQBBUgSUIAkAQVIElCAJAEFSBJQgCQBBUgSUIAkAQVIElCAJAEFSBJQgCQBBUgSUIAkAQVIElCAJAEFSBJQgCQBBUgSUIAkAQVIElCAJAEFSBJQgCQBBUgSUIAkAQVIElCAJAEFSBJQgCQBBUgSUIAkAQVIElCAJAEFSBJQgCQBBUgSUIAkAQVIElCAJAEFSBJQgCQBBUgSUIAkAQVIElCAJAEFSBJQgCQBBUgSUIAkAQVIElCAJAEFSBJQgCQBBUgSUIAkAQVIElCAJAEFSBJQgCQBBUgSUIAkAQVIElCAJAEFSBJQgCQBBUgSUIAkAQVIElCAJAEFSBJQgCQBBUgSUIAkAQVIElCAJAEFSBJQgCQBBUgSUIAkAQVIElCAJAEFSBJQgCQBBUgSUIAkAQVIElCAJAEFSBJQgCQBBUgSUIAkAQVIElCAJAEFSBJQgCQBBUgSUIAkAQVIElCAJAEFSBJQgCQBBUgSUIAkAQVIElCAJAEFSBJQgCQBBUgSUIAkAQVIElCAJAEFSBJQgCQBBUgSUIAkAQVIElCAJAEFSBJQgCQBBUgSUIAkAQVIElCAJAEFSBJQgCQBBUgSUIAkAQVIElCAJAEFSBJQgCQBBUgSUIAkAQVIElCAJAEFSBJQgCQBBUgSUIAkAQVIElCAJAEFSBJQgCQBBUgSUIAkAQVImndAB4CDOXyiDn6NBzT10QaeloM36tBXeEiP8H8YwGIJKECSgAIkCShAkoACJAkoQJKATu9vf3uKo7rOmr/c0XAMJ7L3gRfQ6QnoAghoKQIaE9Buoyx/Q0BLEdCYgHYbZfkbAlqKgMYEtNsoy98Q0FIENCag3UZZ/oaAliKgMQHtNsryNwS0FAGNCWi3UZa/IaClCGhMQLuNsvwNAS1FQGOzDCh08o/jYfh26hvxpAgoLMX79QcAfzf1rXhSBBSW4mx4+W7nhW8Z2feQCigsxdnwatdFUwdrhvY6pAIKy/DheP0M/mV42dSxmqV9DqqAwjII6APtc1AFFJZi91P4qVs1S/scUgGdnvNAF2AW54EK6IPsc0gFdHoCugACWs8+h1RApyegCzDzgCroXXsdUgGdnoAuwNwDSsNbOWMC2m2UgDYEtBQBjQlot1EC2hDQUgQ0JqDdRgloQ0BLEdCYgHYbJaANAS1FQGMC2m2UgDYEtBQBjc0yoEBRAgqQJKAASQIKkCSgAEkCCpAkoABJAjo954EuwCzOA2VfzgONCWi3UZa/IaClCGhMQLuNsvwNAS1FQGMC2m2U5W8IaCkCGhPQbqMsf0NASxHQmIB2G2X5GwJaioDGBLTbKMvfENBSBDQmoN1GWf6GgJYioDEB7TbK8jcEtBQBjc0yoEBRAgqQJKAASQIKkCSgAEkCCpAkoABJAjo954EugPNAS3EeaExAu42y/A0BLUVAYwLabZTlbwhoKQIaE9Buoyx/Q0BLEdCYgHYbZfkbAlqKgMYEtNsoy98Q0FIENCag3UZZ/oaAliKgMQHtNsryNwS0FAGNCWi3UZa/IaClCGhslgEFihJQgCQBBUgSUIAkAQVIElCY0q9fD8MX3+669C3T2PfbJ6AwobNh42V44dQVWba9vn8COj3ngS7AjqPx4fj53y8uPp4M3wUXTl2Qpdvn+yqg0xPQBdhxNE6P3qx/+fT6xbu7F04dkKXb5/sqoNMT0AWIj8b5ybD17Oe7l04dkKXb5/sqoNMT0AWIj8an1wI6X/t8XwV0egK6ALsCGoXzytQBWbp9vq8COj0BXYBdAb38GegOUxdk2fb6vgro9AR0AXa9iHR5AtOH4+hFJMdwMj6NKSag3UZZ/saOo/F+GP787uLj18Orh/wpHpuAxgS02yjL39h1NLYn0scPQB3DqQhobJYBZcnWb+U8+ibuJ7MnoABJAgqQJKAASQIKkCSgAEkCCpAkoNNzHugC+HfhS3EeaExAu42y/A0BLUVAYwLabZTlbwhoKQIaE9Buoyx/Q0BLEdCYgHYbZfkbAlqKgMYEtNsoy98Q0FIENCag3UZZ/oaAliKgMQHtNsryNwS0FAGNCWi3UZa/IaClCGhslgEFihJQgCQBBUgSUIAkAQVIElCAJAEFSBLQ6TkPdAGcB1qK80BjAtptlOVvCGgpAhoT0G6jLH9DQEsR0JiAdhtl+RsCWoqAxgS02yjL3xDQUgQ0JqDdRln+hoCWIqAxAe02yvI3BLQUAY0JaLdRlr8hoKUIaExAu42y/A0BLUVAY7MMKFCUgAIkCShAkoACJAkoQJKAAiQJKEzubHg19U0gRUCn5zzQBbj/aOwKqGM4EeeBxgS02yjL3xDQUgQ0JqDdRln+RjKgb7nxKN+YmIDGBLTbKAFt7Doa5z8cD8/f7Ajo1MWan8f8Fo0JaExAu40S0MaOo3F+Mqz9MQzo1LWao8f9Ll0T0JiAdhsloI0dR+NseP7TxcdVRQV0P4/7XbomoDEB7TZKQBvx0fj0+ujNxeZxqIDu53G/S9cENCag3UYJaCM+Gh+OX7xb/xr/DHTqWM3Ro36TbghoTEC7jRLQRnw03g8vt78K6H4e83s0IqCxWQaUxbo/oAp6R9fvzj4EFCZz/1N45k9AYTLnJ/e9iMT8CShM52w4+v7i/DQ+jYn5E1CYzuWJ9Ed/FdCiBBQmdP7jPW/lZPYEFCBJQKfnPNAF8O/Cl+I80JiAdhtl+RsCWoqAxgS02yjL3xDQUgQ0JqDdRln+hoCWIqAxAe02yvI3BLQUAY0JaLdRlr8hoKUIaExAu42y/A0BLUVAYwLabZTlbwhoKQIaE9Buoyx/Q0BLEdDYLAMKFCWgAEkCCpAkoABJAgqQJKAASQIKkCSg03Me6AI4D7QU54HGBLTbKMvfENBSBDQmoN1GWf6GgJYioDEB7TbK8jcEtBQBjQlot1GWvyGgpQhoTEC7jbL8DQEtRUBjAtptlOVvCGgpAhoT0G6jLH9DQEsR0JiAdhtl+RsCWoqAxmYZUKAoAQVIElCAJAEFSBJQgCQBBUgSUIAkAZ2e80AXwHmgpTgPNCag3UZZ/oaAliKgMQHtNuqgs85Pjt4c7tqmIKClCGhMQLuNEtCGgJYioDEB7TZKQBsCWoqAxgS026i+AX07ewJaiYDGBLTbqIMH9B/Hw/MdFZ06jnt6+N9bQCcioDEB7Tbq0AH967ASPw6dOox7e/DfW0AnIqAxAe026sABHY6+vfh4MryKLp26i3t78N9bQCcioLFZBpTfdX6ZzvfDy+jSqbu4t85HjccnoBSwCuh3q18+HL94F1w6dRf31vuw8egElAK2r8ILKDMjoBRwf0CrFLTzQaMDAaWA3wkoTERAKUBAmScBpQABZZ4EdHrOA/1d9QPqvfClOA80JqDdRgloQ0BLEdCYgHYbZfkbAlqKgMYEtNsoy98Q0FIENCag3UZZ/oaAliKgMQHtNsryNwS0FAGNCWi3UZa/IaClCGhMQLuNsvwNAS1FQGMC2m2U5W8IaCkCGptlQIGiBBQgSUABkgQUIElAAZIEFCBJQAGSBHR6zgNdAOeBluI80JiAdhtl+RsCWoqAxgS02yjL3xDQUgQ0JqDdRln+hoCWIqAxAe02yvI3BLQUAY0JaLdRlr8hoKUIaExAu42y/A0BLUVAYwLabZTlbwhoKQIaE9Buoyx/Q0BLEdDYLAMKFCWgAEkCCpAkoABJAgqQJKAASQIKkCSg03Me6AI4D7QU54HGBLTbKMvfENBSBDQmoN1GWf6GgJYioDEB7TbK8jcEtBQBjQlot1GWvyGgpQhoTEAPeW3nPwzD8zdnw6sOs6oT0FIENCagB7yyT18PK0d/FdA9CGgpAhoT0ANe2dnw/KeLjyeDgO5BQEsR0JiAHu66Pr0+erP5ZVdA38L0UnduAY3NMqBFfTh+ufn1NA7o1HsDVx5xCwSUpPfDZUDjF5Gm3hm48XhbIKAkCShVPN4WCChJV0/hBZS5e7wtEFCS7n8RaeqVgRuPtwUCSta9pzFNvTJw4/GWQEDJOj8ZLnkVnll7xCUQ0OkVPQ/08q2cR1/97+G7DrOqcyJ9Kc4DjQno4a/zdPOj0D6z6hLQUgQ0JqCHu65Pr4++X/3yy/Gznx99Vn0CWoqAxgT0gFd2evkT0KP4GbzlbwhoKQIaE9ADXtn5j39Y9fPLn3rMKk9ASxHQmIB2G2X5GwJaioDGBLTbKMvfENBSBDQmoN1GWf6GgJYioDEB7TbK8jcEtBQBjc0yoEBRAgqQJKAASQIKkCSgAEkCCpAkoABJAjo954EugPNAS3EeaExAu42y/A0BLUVAYwLabZTlbwhoKQIaE9Buoyx/Q0BLEdCYgHYbZfkbAlqKgMYEtNsoy98Q0FIENCag3UZZ/oaAliKgMQHtNsryNwS0FAGNCWi3UZa/IaClCGhslgEFihJQgCQBBUgSUIAkAQVIElCAJAEFSBLQ6TkPdAGcB1qK80BjAtptlOVvCGgpAhoT0G6jLH9DQEsR0JiAdhtl+RsCWoqAxgS02yjL3xDQUgQ0JqDdRln+hoCWIqAxAe02yvI3BLQUAY0JaLdRlr8hoKUIaExAD3t9Z8OrbrNqE9BSBDQ2y4AWdl9A4ekTUIAkAeWxvGVk6u8Gj0JA+Qz3PIWfOlgz1PM7Qx8CymfYHdCpYzVLXb839CCgfAYBfZCu3xt6EFA+g4A+SNfvDT0I6PSe5HmgU7dqlh58fJ0HOhHngcYE9LDXJ6AP8uDjK6ATEdCYgB72+rwK/xAPP74COhEBjQnoYa/PWzn35a2cpQhoTEAPe30Cui8BLUVAYwJ62OsT0H0JaCkCGhPQw16fgO5LQEsR0JiAHvb6BHRfAlqKgMYEtNsoy98Q0FIENDbLgAJFCShAkoACJAkoQJKAAiQJKECSgAIkCej0nAe6AM4DLcV5oDEB7TbK8jcEtBQBjQlot1GWvyGgpQhoTEC7jbL8DQEtRUBjAtptlOVvCGgpAhoT0G6jLH9DQEsR0JiAdhtl+RsCWoqAxgS02yjL3xDQUgQ0JqDdRln+hoCWIqCxWQYUKEpAAZIEFCBJQAGSBBQgSUABkgQUIElAp+c80AVwHmgpzgONCWi3UZa/IaClCGhMQLuNsvwNAS1FQGMC2m2U5W8IaCkCGhPQbqMsf0NASxHQmIB2G2X5GwJaioDGBLTbKMvfENBSBDQmoN1GWf6GgJYioDEB7TbK8jcEtBQBjc0yoEBRAgqQJKAASQIKkCSgpJ3/eDwcffNu6psBkxFQss5PhrWXuy5/m9LzbwCfSUDJOhue/XTx4fjoTXhpLp8aSikCOr2i54Gen2zSeTa8ii79jH4+yYI6D7QU54HGBPRw1/Xp9bOfd18qoC0BLUVAYwJ6uOv6cPzintePBLQloKUIaExAD3ddAvoQAlqKgMYE9HDX5Sn8QwhoKQIaE9DDXdf2RaRdD0T1syGgpQhoTEAPeGWb05g+nsSvwlv+loCWIqAxAT3glW1PpN/1k1DLPyagpQhoTEAPeW2bt3J+teuVJMs/JqClCGhslgEFihJQgCQBBUgSUIAkAQVIElCAJAEFSBLQ6ZU9D3Q+s+bPeaClOA80JqDdRln+hoCWIqAxAe02yvI3BLQUAY0JaLdRlr8hoKUIaExAu42y/A0BLUVAYwLabZTlbwhoKQIaE9Buoyx/Q0BLEdCYgHYbZfkbAlqKgMYEtNsoy98Q0FIENDbLgAJFCShAkoACJAkoQJKAAiQJKECSgAIkCej0nAe6AM4DLcV5oDEB7TbK8jcEtBQBjQlot1GWvyGgpQhoTEC7jbL8DQEtRUBjAtptlOVvCGgpAhoT0G6jLH9DQEsR0JiAdhtl+RsCWoqAxgS02yjL3xDQUgQ0JqDdRln+hoCWIqCxWQYUKEpAAZIEFCBJQAGSBBQgSUCfnk+vn/089W2ARRDQp0dAoRMBnd6hT/a7J6DOA52K80BLcR5obPEBfduR5R8R0FIENLbwgPbM58Zh/2KVCWgpAhpbdkC791NBrwloKQIaE1ABnYaAliKgMQEV0GkIaCkCGhNQAZ2GgJYioDEBFdBpCGgpAhpbdkC9Cj8dAS1FQGOzDOiheScSdCKgT4+AQicC+vQIKHQioE+PgEInAvr0CCh0IqAASQIKkCSg0/Pvwi+A80BLcR5oTEC7jbL8DQEtRUBjAtptlOVvCGgpAhoT0G6jLH9DQEsR0JiAdhtl+RsCWoqAxgS02yjL3xDQUgQ0JqDdRln+hoCWIqAxAe02yvI3BLQUAY0JaLdRlr8hoKUIaGyWAQWKElCAJAEFSBJQgCQBBUgSUIAkAQVIEtDpOQ90AZwHWorzQGMC2m2U5W8IaCkCGhPQbqMsf0NASxHQmIB2G2X5GwJaioDGBLTbKMvfENBSBDQmoN1GWf6GgJYioDEB7TbK8jcEtBQBjQlot1GWvyGgpQhoTEC7jbL8DQEtRUBjswwoUJSAAiQJKECSgAIkCShAkoACJAkoQJKATs95oAvgPNBSnAcamyagp8N3910soAsgoKUIaExAu42y/A0BLUVAYwLabZTlbwhoKQIam2dA3/L0CWglAhqbLKC/HA9H37wLL516s+nl4fccAZ2IgMamCui/DGsvooJOvdX08+B7joBOREBjUwV0+Ordxa/Hw6vgwqmXmn4efM8R0IkIaGyqgG4ee74PH4JOvdT08+B7joBOREBjk76IdH7y7Oe7F0691PTT+47HoxPQDk6P3qx/OT+5/LU19VLTT+87Ho9OQDu4N6AKuhid73Z0IKAdbJ/Cf3odPYUHyhLQDk6Hl+tf4heRgLIEtIPTYfjz5jSme9+QBFQjoB1cnUj/corhwKMR0A62b+X8dsfFPkxkAXyYSCnOA435QOVuoyx/Q0BLEdCYgHYbZfkbAlqKgMYEtNsoy98Q0FIENCag3UZZ/oaAliKgMQHtNsryNwS0FAGNCWi3UZa/IaClCGhMQLuNsvwNAS1FQGMC2m2U5W8IaCkCGptlQIGiBBQgSUABkgQUIElAAZIEFCBJQAGSBHR6zgNdAOeBluI80JiAdhtl+RsCWoqAxgS02yjL3xDQUgQ0JqDdRln+hoCWIqAxAe02yvI3BLQUAY0JaLdRlr8hoKUIaExAu42y/A0BLUVAYwLabZTlbwhoKQIaE9Buoyx/Q0BLEdDYLAMKFCWgAEkCCpAkoABJAgqQJKAASQIKkCSg03Me6AI4D7QU54HGBLTbKMvfENBSBDQmoN1GWf6GgJYioDEB7TbK8jcEtBQBjQlot1GWvyGgpQhobKKAnh69uedSAV0AAS1FQGMC2m2U5W8IaCkCGptnQN/2I6ATEdBSBDQ2x4B2zOdGr7+05R8T0FIENDZlQD8cH30XXNa7n/0KCk+egPawDuin10PUTwGFugS0h1VAz0+GV+FlAgplCWgPq4Ce7uingEJdAtrD6dFfhxfv4ssEFMoS0B5Oh2HY+UK8fkJVAtrD6fDn050PQYGqBLSH06M3H47jF+EvvBNpEZwHWorzQGMTnsZ0Njz7Ob5UQBdAQEsR0NiEAd15HpOALoGAliKgsSnfifR+10NQAV0AAS1FQGOTvhf+dHgZXiqgCyCgpQhozAcqdxtl+RsCWoqAxgS02yjL3xDQUgQ0JqDdRln+hoCWIqAxAe02yvI3BLQUAY3NMqBAUQIKkCSgAEkCCpAkoABJAgqQJKAASQI6PeeBLoDzQEtxHmhMQLuNsvwNAS1FQGMC2m2U5W8IaCkCGhPQbqMsf0NASxHQmIB2G2X5GwJaioDGBLTbKMvfENBSBDQmoN1GWf6GgJYioDEB7TbK8jcEtBQBjQlot1GWvyGgpQhobJYBBYoSUIAkAQVIElCAJAEFSBJQgCQBBUgS0Ok5D3QBnAdaivNAYwLabZTlbwhoKQIaE9Buoyx/Q0BLEdCYgHYbZfkbAlqKgMYEtNsoy98Q0FIENCag3UZZ/oaAliKgsckC+un1s593XSagCyCgpQhoTEC7jbL8DQEtRUBjnsJ3G2X5GwJaioDGZhlQoCgB7eO+p/AXb1M63nogJKB93BPQXD41FKYnoH3sDuhn9FNBYVoC2oeAwhMkoH0IKDxBAtqHgMITJKB9zCSgzgOdivNAS3EeaGyGAe36KryATkVASxHQ2BwD6p1ISyCgpQhoTEC7jbL8DQEtRUBjAtptlOVvCGgpAhoT0G6jLH9DQEsR0JiAdhtl+RsCWoqAxiYL6IfjF+92XSagCyCgpQhobKqAng7Dy50XCugCCGgpAhqbKKDnJ8Pz3Z9mBxQloABJAgqQJKAASQIKkCSgAEkCCpAkoNNzHugCOA+0FOeBxgS02yjL3xDQUgQ0JqDdRln+hoCWIqAxAe02yvI3BLQUAY0JaLdRlr8hoKUIaExAu42y/A0BLUVAYwLabZTlbwhoKQIaE9Buoyx/Q0BLEdCYgHYbZfkbAlqKgMZmGVCgKAEFSBJQgCQBBUgSUIAkAQVIElCAJAGdnvNAF8B5oKU4DzQmoN1GWf6GgJYioDEB7TbK8jcEtBQBjQlot1GWvyGgpQhoTEC7jbL8DQEtRUBjAtptlOVvCGgpAhoT0G6jLH9DQEsR0JiAdhtl+RsCWoqAxgS02yjL3xDQUgQ0NsuAAkUJKECSgAIkCShAkoA+zPmPfxiGoz+923Hx26fpMw8aPFUC+iDnJ8PGs5+jS6fu3GP6vOMGT5OAPsjZ8OKni4uPr4fvggunbtzj+rwDB0+SgD7E+cnRm/WvZ8Or4NKpE/e4HnywnMM45jzQUpwHGjvAX/e3f//xL4OA/j7LPyagpQho7LP/uv84vvwhqID+Lss/JqClCGjs838GOnzxX775u6fwe7D8YwJaioDGPvOv++n1fT8DfdIFffjBsvxjAlqKgMY+86/74fjF+gzQ85M4oEk+TGQBBLQUAY199iPQ4duLi49fD8PLA92gNQFdAAEtRUBjn/vXPR22BHRWs+ZPQEsR0NhnvxPpx+Nh+OKb/3scvxUpR0AXQEBLEdCYDxMBDkdAAZIEFCBJQAGSBBQgSUABkgQUIElAp+c80AVwHmgpzgONCWi3UZa/IaClCGhMQLuNsvwNAS1FQGMC2m2U5W8IaCkCGhPQbqMsf0NASxHQmIB2G2X5GwJaioDGBLTbKMvfENBSBDQ2zNHf/vYUR3WdNX+5o+EYTuQBB/7gjTr0FR7SIx7yPAFdAAEtRUCJzPJHGJNxNEYcjLEJj4bvw4zZkjFHY8TBGBNQIrZkzNEYcTDGBJSILRlzNEYcjDEBJWJLxhyNEQdjTECJ2JIxR2PEwRgTUCK2ZMzRGHEwxgSUiC0ZczRGHIwxASViS8YcjREHY0xAidiSMUdjxMEYE1AitmTM0RhxMMYElIgtGXM0RhyMMQElYkvGHI0RB2NMQInYkjFHY8TBGBNQIrZkzNEYcTDGBJSILRlzNEYcjDEBJWJLxhyNEQdjTECJ2JIxR2PEwRgTUCK2ZMzRGHEwxgQUoB4BBUgSUIAkAQVIElCAJAEFSBJQgCQBBUgSUIAkAQVIElCAJAEFSBJQgCQBBUgSUIAkAQVIElCAJAEFSBJQgCQBBUgSUIAkAQVIElCAJAEFSBJQgCQBBUgSUIAkAZ2n85Ph2ndT35hpfXr97Oeb//Xx346H4ehPP013eyY1PhiLvo+c//jH1V/7i/EdYZK7hoDO06fXC16OxioTo4D+cnx5TI7+24Q3aTrNwVjyfeTqfjAMX93+rb53DQGdp/fDcpejcX46jJrxftlHZefBWNrRGP/VX975rZ4HQ0Dn6WxxOxHbPE29bsb6Mdfz1VO0//h6HJLFaA/Ggu8jm/vB3y8u7whHb65/a4K7hoDO0+kSA3HXr5unZdeHYpWMF+/W/7FOyasJb9ckbh2MBd9H3l8/7lzfETb/OdVdQ0BnaXUvuLw7LNrH1aOJ4U9fX3didVQuH25cXHw4XtoBun0wlnwfOb157L29I0x21xDQWVo9IXk59W2Y3upRxdG3o9dNVkflajVGC7MQtw+G+8jG9j4x2V1DQGdp9Rzlu49/WT3k+PL7qW/KhM6Ovno3fuH55plb8yBkGW4fDPeRjW05J7trCOgsnQ1Hf92+pPinhT5NW/lt/VdvA3r9063FvYJy+2C4j2xsyznZXUNAZ+l0dJrGUn/QtTVqxngz3i/wVaQ2oO4jF5sHoJvn65PdNQR0jtavJB5982795ophkaEYEdCR0cFwH1k7vXkRXkC5cvX/qxebe8ZST1a5JKAj7Stqi7+P3LyxQECJrR9oLOuHfbcI6Ej7vtbR7y7yPrJ5EH75fyICyg5niyzFDQEdiQO60PvIx+u3IQkoOy2zFDe8Cj+yI6CLvI98OB6G56NzurwKT2SRyzHiPNARAb12tv4kpuuTD5wHyg7LfKh1wzuRRnY/hV/afeSsPfXAO5EYGf1Ma/Ri6zK1Z+4s973wG+0PhBd8Hzkb2r+y98IzsroPbPfk/HRY+Due2zffLPnTmC6ag7Ho+8jqGfuz9pPnfRoTNzbnZ3z7bvx5h4t16/MzNp8DudDPA717Iv1C7yPBQ+6p7hoCOksfjm/eprfER1ojzY/9Fv6J9M3BWPB95GwYu2ypT6Rn5MPXV/eOZf7jPzfa103+4d9Euj4Yi72PjP81veuATnTXENCZOv91/UllX3zzz6lvyNRuvfC87H+Vsz0YS72PjP81vZuA+lc5AUoRUIAkAQVIElCAJAEFSBJQgCQBBUgSUIAkAQVIElCAJAEFSBJQgCQBBUgSUIAkAQVIElCAJAEFSBJQgCQBBUgSUIAkAQVIElCAJAEFSBJQgCQBBUgSUIAkAcaekTUAAAXTSURBVAVIElCAJAEFSBJQgCQBBUgSUIAkAQVIElCAJAEFSBJQgCQBBUgSUIAkAQVIElCAJAEFSBJQgCQBBUgSUIAkAQVIElCAJAEFSBJQgCQBBUgSUIAkAQVIElCAJAEFSBJQgCQB5aDOf/zDMBx91Xfox+/b23AyPPv5s67qc66BJRFQDmlVnrWXXWf+MLy6fSOS+bu6KgFlPwLKIb3f9PNW0B5/5qECenVVAsp+BJRDOhuGF+86z3yEgMJ+BJRDWgX0u94zBZTJCCiHJKAsioByMJ9eD9c/Aj1dPZX/9Q/D8OVPqwt++/GPq989+vL6xfKPfxnWF63+wPoJ/+aX819WX/18/RXnPx4PwxffXn3t+S/rP/zl95c/GdjE8fKl/j+tr/rqp67jbt8E9PzXv4z+7ObKbv7kxe1bdnNVu67hznQWTkA5mFsB/WX9n0dvNg9Lt7Y/H736jf96E9D/f3L1Rz9+PYxfyf9wvP3i55tirRP2f65+ax3N+wJ6dVXbP7u6su1vHG2/ur1lQUBvXcOd6SycgHIwbUC/ON5m8KZS2yfI70e/cRXQ/77930f/6+Tqok2grvs5XCbt/GT0h9d1vieg17dn+2dHv7H+k3du2d2A3r6GO9NZOAHlkK5/Bnq6juPmUds6Ql/9c/Uf//H1dS83D+h+Ob4J6Op3/r56vPf66sHer8eXD0E3X/v9+qn39jc2CTv69t36lM2bHsc/A13dhqNv3l3+SODl9kYdfXv5sPJldMvunMZ0+xqC6SyagHJI44Bun6+/Hz8bX2fp+lSn9aPLq4Be/s77YfRf22fV26tZfdH6Id86YdsfT55tr3hXQFdXv32QuP2v7VVc/8edW3Y7oHeuIZjOogkohzQO6J0HaKturetzev18++wmoN9dfcW2WNdfe/1E+TJu64Rtr3gVteZh47Vt/kaJO716iv7y1s1sb9ntgN65hmA6iyagHNI4oO2LLL/9+/843jx8u4rVxXWEbn7n9n9tX6a/+uKXm4RdJfX3Ajq6CZd/dsc5Vte37E5A71xDMJ1FE1AOaRTQm9dYzn/9y/HNSzGjKN6cxrQ7oGOrL94/oKOv3H7p6Z3Xfdpbdjugd69BQGkJKIcUBXT0Qvo6S6Py/G5Ax380EdDr0+kvB90J6K1bFgT01jUIKC0B5ZCCgF4+ivziy3/9n//v9tPyfQJ6q1KHfAR6+5Z5BMpDCSiHFAT07Po89uun5Q/5GeitN2Xmfgb6foh+Bnr7lt33M9DLaxBQWgLKId0N6Kg574ft47q7r8LvCOjoa7ceENB7XoXfvCR055bt9Sq8gDIioBzSfQFdnybfnAd6df7n7oCuv/bZT9dXHSds7/NAb35jk8O7t2yf80AFlBEB5ZCCp/Cnl0+UN+/muTqf/frdRr8X0PXXrt/5c/HbD8OuhL2//Rmk0fuINl+xfSfS+m1E22fo7S27vqpd1yCgtASUQwoCOn7n+3Wmxi+s3xfQ5mvXDw6DhF2+lv6w98JvruvuLbu6qnveCy+gjAgohxSdxvTDVaK+ufqJ5t1PY9oZ0Iv316caXT25vp2wy0/4GD2L3/1pTNe/8Sq+ZVdXdc+nMQkoIwLKIYUn0m8+UvOL1VPh61dxtp8Hevn2nvsDunr+/MfNH//n5f8KEnb+b6svGP1DoHc/zfPmovXngV5+SGl4y7ZXtesaBJSWgDKdbUChKgGlt5uzK6NPHIFCBJTe1i9tr58S//bD9WfDQU0CSm/jd6B7AEppAkp3vxzrJ0+DgNLfb+t/1/L6hXUoS0ABkgQUIElAAZIEFCBJQAGSBBQgSUABkgQUIElAAZIEFCBJQAGSBBQgSUABkgQUIElAAZIEFCBJQAGSBBQgSUABkgQUIElAAZIEFCBJQAGSBBQgSUABkgQUIElAAZIEFCBJQAGSBBQgSUABkgQUIElAAZIEFCBJQAGSBBQgSUABkgQUIElAAZIEFCBJQAGSBBQgSUABkv4Ts7akVvVHjzQAAAAASUVORK5CYII=" width="672" /></p>
<p>Now we can make a matrix telling if some fragments do start or end at
exactely the same position.</p>
<pre class="r"><code>countSameStartEnd(frag1)</code></pre>
<pre><code>##   beg end beg.n beg.rat end.n end.rat
## a   2   6    NA      NA    NA      NA
## b   3  12     3  0.2500     3  0.2500
## c   7   8     3  0.2500    NA      NA
## d  13  18     2  0.1667    NA      NA
## e  13  20     2  0.1667     2  0.1667
## f  15  20    NA      NA     2  0.1667
## g   7  19     3  0.2500    NA      NA
## h   9  12    NA      NA     3  0.2500
## i   7  12     3  0.2500     3  0.2500
## j   3   4     3  0.2500    NA      NA
## k   3   5     3  0.2500    NA      NA
## l   5   7    NA      NA    NA      NA</code></pre>
</div>
</div>
<div id="SupportForGraphicalOutput" class="section level2">
<h2>Support for Graphical Output</h2>
<div id="convenient-paste-collapse" class="section level3">
<h3>Convenient Paste-Collapse</h3>
<p>The function <code>pasteC()</code> allows adding quotes and
separating the last element by specific text (eg ‘and’).</p>
<pre class="r"><code>pasteC(1:4)</code></pre>
<pre><code>## [1] &quot;1, 2, 3 and 4&quot;</code></pre>
<pre class="r"><code>pasteC(letters[1:4],quoteC=&quot;&#39;&quot;)</code></pre>
<pre><code>## [1] &quot;&#39;a&#39;, &#39;b&#39;, &#39;c&#39; and &#39;d&#39;&quot;</code></pre>
</div>
<div id="transform-numeric-values-to-color-gradient" class="section level3">
<h3>Transform Numeric Values to Color-Gradient</h3>
<p>By default most color-gradients end with a color very close to the
beginning.</p>
<pre class="r"><code>set.seed(2015); dat1 &lt;- round(runif(15),2)
plot(1:15, dat1, pch=16, cex=2, las=1, col=colorAccording2(dat1),
  main=&quot;Color gradient according to value in y&quot;)</code></pre>
<p><img src="data:image/png;base64,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szbeC1g/ZiiJZVxA87M8ySaBhatFUsvWj+vv9EjizMm76iuXQtHrbfgxqe9ESmYZF9D8VN/ICOguP3/78Wz+fPJi7HFsvPrd4qsvkxhRow0JfCvnZkTJLOMCCoCAAoQJKECQgAIECShAkIACBAkoQJCAAgQJKECQgAIECShAkIACBAkoQJCAAgQJKECQgAIECShAkIACBAkoQJCAAgQJKECQgAIECShAkIACBAkoQJCAAgQJKECQgAIECShAkIACBAkoQJCAAgQJKECQgAIECShAkIACBAkoQJCAAgQJKECQgAIECShAkIACBAkoQJCAAgQJKECQgAIECShAkIACBAkoQJCAAgQJKECQgAIECShAkIACBAko5+Td4w9+OOCm2y+L0rMTDY0pElDOyCyMXQGt3fTusYByCgLK+bi9KroCWr/pphBQTkFAORuLDfP2gDZuutZNTkJAORc/XRZdAW3edNW5pQ9DElDOw9sns0Q+fNJWxq2bZu9HP3p92uExTQLKeZhtlV88re4peve4uPi686b7owySqRFQzsP1xaev7zoC2rzppiievf3d7G3pJ1+NMlYmQ0A5Dz/Pt8nbA7p103Vx8fvVPviHNuU5IgHljBx4HOhV5SgmH4ZyRALKGTksoPNjmi4+n4Xz7fNZQR+dbnhMjoByRg4L6Gbjfr5/yQFNHI+AckYOPZWz+lOH1HM8AsoZ6R3Q+VtQ2/AcjYByRvoH9EZAOSIB5YwIKGkRUM5IaBPeZ6AcjYByRg4LaOVzz8oOeRiegHJGDgvom8v1P+dXCXVWPMcjoJyRHgfSP319d/fqSeENKMckoJyR9nPht256c7k5ldMuJI5IQDkjBwb07s2TVT4vvjjxCJkWAeWMHBrQu9uf5lez+/Dzv512fEyNgAIECShAkIACBAkoQJCAAgQJKECQgAIECShAkIACBAkoQJCAAgQJKECQgAIECShAkIACBAkoQJCAAgQJKECQgAIECShAkIACBAkoQJCAAgQJKECQgAIECShAkIACBAkoQJCAAgQJKECQgAIECShAkIACBAkoQJCAAgQJKECQgAIECShAkIACBAkoQJCAAgQJKECQgAIECShAkIACBAkoQJCAAgQJKECQgAIE/X/cLafOyCSoCwAAAABJRU5ErkJggg==" width="672" /></p>
<pre class="r"><code># Here we modify the span of the color gradient
plot(1:15, dat1, pch=16, cex=2, las=1, 
  col=colorAccording2(dat1, nStartO=0, nEndO=4, revCol=TRUE), main=&quot;blue to red&quot;)</code></pre>
<p><img src="data:image/png;base64,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" width="672" /></p>
<pre class="r"><code># It is also possible to work with scales of transparency
plot(1:9, pch=3, las=1)
points(1:9, 1:9, col=transpGraySca(st=0, en=0.8, nSt=9,trans=0.3), cex=42, pch=16)</code></pre>
<p><img src="data:image/png;base64,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" width="672" /></p>
</div>
<div id="assign-new-transparency-to-given-colors" class="section level3">
<h3>Assign New Transparency To Given Colors</h3>
<p>For this purpose you may use <code>convColorToTransp</code>.</p>
<pre class="r"><code>col0 &lt;- c(&quot;#998FCC&quot;,&quot;#5AC3BA&quot;,&quot;#CBD34E&quot;,&quot;#FF7D73&quot;)
col1 &lt;- convColorToTransp(col0,alph=0.7)
layout(1:2)
pie(rep(1,length(col0)), col=col0, main=&quot;no transparency&quot;)
pie(rep(1,length(col1)), col=col1, main=&quot;new transparency&quot;)</code></pre>
<p><img src="data:image/png;base64,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srPXT5dJcl8/iykBtfq5SQjIg/QAdPQq/yo9ZZRfKQUJAbX6yU5gBORAeqV6Wn45a3bY+ILGB9TqJ+363l8IyJereoflF0TbDai4CKvHksU8IyBX0pPGvR/yr7I9ObagkQEl5TLLsaTHxYsFAXkyf30WHIAWo89i4wIq06kCSk9g6fU8AflxlT8HetZ6bVxBowLqvn9xlV/OE5AfeUDHz65bL44qaExA3X7SO/iLBQE5Mv/j+eP0DFY9B6qMuZZeP6Ck2096MZYPhIB8ub1M6jv60oiC1g6o1096OCwu5gnImeBJYmPdgtYNqP/xjbobAvJmVlx7tK15EFovoP7hJ3iySUDe3MQCWrOgtQKK9JNl0xIZ0Z4ioHhA653G1gko+ulDAvIlPG1dDZ0z1jgIrRxQ+62L1oAIyJH0kqO6ck53XfleRk+y8v3YigElQ/0EuAbyIPs82VH2BPH2q6V/7qsWtFpAd9ezICAnbh81p4vTpVOuVNBKAa2SDwF5kT1ALDy8Xj7lKkehuwNa4eRVICAvin+V8eDtnROucCl0V0CrXPyUCOgQ3ZXQ0oDWqMehg10xY9UJb72A6uusXQ9/cw541YwlSxqKB3T49SwIaE0DFfUCmkQ7uQmsorH2I+NOQO0f7nqo2zCJlbSX3GXXA9ya6azpRkw3nMr01himCAgSAoKEgCAhIEgICBICgoSAICEgSAgIEgKChIAgISBICAgSAoKEgCAhIEgICBICgoSAICEgSAgIEgKChIAgISBICAgSAoKEgCAhIEgICBICgoSAICEgSAgIEgKChIAgISBICAgSAoKEgCAhIEgICBICgoSAICEgSAgIEgKChIAgISBICAgSAoKEgCAhIEgICBICgoSAICEgSAgIEgKChIAgISBICAgSAoKEgCAhIEgICBICgoSAICEgSAgIEgKChIAgISBICAgSAoKEgCAhIEgICBICgoSAICEgSAgIEgKChIAgISBICAgSAoKEgCAhIEgICBICgoSAICEgSAgIEgKChIAgISBICAgSAoKEgCAhIEgICBICgoSAICEgSAgIEgKChIAgISBICAgSAoKEgCAhIEgICBICgoSAICEgSAgIEgKChIAgISBICAgSAoKEgCAhIEgICBICgoSAICEgSAgIEgKChIAgISBICAgSAoKEgCAhIEgICBICgoSAICEgSAgIEgKC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l1SQFFDrAugqISAPZumhJzt7/XSZJPf1s5gSUKufm4SAPEgPQEev8q/SU0b5lVKQEFCrn+wERkAOpFeqp+WXs2aHjS9ofECtftKu7/2FgHy5qndYfkG03YCKi7B6LFnMMwJyJT1p3Psh/yrbk2MLGhlQUi6zHEt6XLxYEJAn89dnwQFoMfosNi6gMp0qoPQEll7PE5AfV/lzoGet18YVNCqg7vsXV/nlPAH5kQd0/Oy69eKogsYE1O0nvYO/WBCQI/M/nj9Oz2DVc6DKmGvp9QNKuv2kF2P5QAjIl9vLpL6jL40oaO2Aev2kh8PiYp6AnAmeJDbWLWjdgPof36i7ISBvZsW1R9uaB6H1AuoffoInmwTkzU0soDULWiugSD9ZNi2REe0pAooHtN5pbJ2Aop8+JCBfwtPW1dA5Y42D0MoBtd+6aA2IgBxJLzmqK+d015XvZfQkK9+PrRhQMtRPgGsgD7LPkx1lTxBvv1r6575qQasFdHc9CwJy4vZRc7o4XTrlSgWtFDL+9QwAAALySURBVNAq+RCQF9kDxMLD6+VTrnIUujugFU5eBQLyovhXGQ/e3jnhCpdCdwW0ysVPiYAO0V0JLQ1ojXocOtgVM1ad8NYLqL7O2vXwN+eAV81YsqSheECHX8+CgNY0UFEvoEm0k5vAKhprPzLuBNT+4a6Hug2TWEl7yV12PcCtmc6absR0w6lMb41hioAgISBICAgSAoKEgCAhIEgICBICgoSAICEgSAgIEgKChIAgISBICAgSAoKEgCAhIEgICBICgoSAICEgSAgIEgKChIAgISBICAgSAoKEgCAhIEgICBICgoSAICEgSAgIEgKChIAgISBICAgSAoKEgCAhIEgICBICgoSAICEgSAgIEgKChIAgISBICAgSAoKEgCAhIEgICBICgoSAICEgSAgIEgKChIAgISBICAgSAoKEgCAhIEgICBICgoSAICEgSAgIEgKChIAgISBICAgSAoKEgCAhIEgICBICgoSAICEgSAgIEgKChIAgISBICAgSAoKEgCAhIEgICBICgoSAICEgSAgIEgKChIAgISBICAgSAoKEgCAhIEgICBICgoSAICEgSAgIEgKChIAgISBICAgSAoKEgCAhIEgICBICgoSAICEgSAgIEgKChIAgISBICAgSAoKEgCAhIEgICBICgoSAICEgSAgIEgKChIAgISBICAgSAoKEgCAhIEgICBICgoSAICEgSAgIEgKChIAgISBICAgSAoKEgCAhIEgICBICgoSAICEgSAgIEgKChIAgISBICAgSAoKEgCAhIEgICBICgoSAICEgSAgIEgKChIAgISBICAgSAoKEgCAhIEgICBICgoSAICEgSAgIEgKChIAgISBICAgSAoKEgCAhIEgICBICgoSAICEgSAgIEgKChIAgISBICAgSAoKEgCAhIEgICBICgoSAICEgSAgIEgKChIAgISBICAgSAoKEgCAhIEgICBICgoSAICEgSAgIEgKChIAgISBICAgSAoKEgCAhIEgICJL/B02GFl0mSznFAAAAAElFTkSuQmCC" width="288" /></p>
</div>
<div id="print-matrix-content-as-plot" class="section level3">
<h3>Print Matrix-Content As Plot</h3>
<p>There are many ways of creating reports. If you want simply to
combine a few plots into a pdf, the function <code>tableToPlot()</code>
may be helpful to add a small table (eg overview of points/samples/files
used in other plots of the same pdf). This function prints tables in the
current graphical output/window (which may by a pdf-device).</p>
</div>
</div>
<div id="OtherConvenienceFunctions" class="section level2">
<h2>Other Convenience Functions</h2>
<div id="writing-compact-dates-more-options" class="section level3">
<h3>Writing Compact Dates (more options …)</h3>
<p>Many times it may be useful to add the date to filenames when saving
data or plots as files. The built-in functions <em>date()</em>,
<em>Sys.Date()</em> and <em>Sys.Time()</em> are a good way to start.</p>
<p>Generally I like to use abbreviated month-names since the order of
writing the month is different in Europe compared to the USA. So, this
may help avoiding mis-interpreting dates instead of writing the number
of the Month. For example, 2021-03-05 means in Europe March 5th while in
other places it means May 3rd.</p>
<p>You may also look at the standardized format for <em>numeric
dates</em> <a href="https://en.wikipedia.org/wiki/ISO_8601">norm ISO
8601</a>, which matches to <em>Sys.Date()</em> (from package
<em>base</em>) and <em>sysDate(style=“univ5”)</em> (package
<em>wrMisc</em>) .</p>
<p>The R-functions mentioned above (<em>date()</em>,
<em>Sys.Date()</em>, from the <em>base</em> package) use local language
settings. For using English languange names you may use the function
<code>sysDate</code> from this package (ie wrProteo). It allows
producing compact versions of current the date, <strong>independent to
local language settings</strong> (or not -if you prefer), ie
locale-specific, (yes, in some languages - like French - the first 3
letters of the month may give ambiguous results !) and to avoid white
space ’ ’ (which I prefer to avoid in file-names). Please look at the
function’s help-page for all available options.</p>
<pre class="r"><code>## To get started
Sys.Date()</code></pre>
<pre><code>## [1] &quot;2025-06-17&quot;</code></pre>
<pre class="r"><code>## Compact English names (in European order), no matter what your local settings are :
sysDate() </code></pre>
<pre><code>## [1] &quot;17jun25&quot;</code></pre>
<p>The table below shows a number of options to write the date in
English or using local month-names :</p>
<pre class="r"><code>tabD &lt;- cbind(paste0(&quot;univ&quot;,1:6), c(sysDate(style=&quot;univ1&quot;), sysDate(style=&quot;univ2&quot;), 
    sysDate(style=&quot;univ3&quot;), sysDate(style=&quot;univ4&quot;), as.character(sysDate(style=&quot;univ5&quot;)), 
    sysDate(style=&quot;univ6&quot;)), paste0(&quot;   local&quot;,1:6), 
  c(sysDate(style=&quot;local1&quot;), sysDate(style=&quot;local2&quot;), sysDate(style=&quot;local3&quot;), 
    sysDate(style=&quot;local4&quot;), sysDate(style=&quot;local5&quot;), sysDate(style=&quot;local6&quot;)))   
knitr::kable(tabD, caption=&quot;Various ways of writing current date&quot;)</code></pre>
<table>
<caption>Various ways of writing current date</caption>
<tbody>
<tr class="odd">
<td align="left">univ1</td>
<td align="left">17jun25</td>
<td align="left">local1</td>
<td align="left">17jui25</td>
</tr>
<tr class="even">
<td align="left">univ2</td>
<td align="left">17Jun25</td>
<td align="left">local2</td>
<td align="left">17Jui25</td>
</tr>
<tr class="odd">
<td align="left">univ3</td>
<td align="left">17June2025</td>
<td align="left">local3</td>
<td align="left">17Juin2025</td>
</tr>
<tr class="even">
<td align="left">univ4</td>
<td align="left">17june2025</td>
<td align="left">local4</td>
<td align="left">17juin2025</td>
</tr>
<tr class="odd">
<td align="left">univ5</td>
<td align="left">2025-06-17</td>
<td align="left">local5</td>
<td align="left">17-juin-2025</td>
</tr>
<tr class="even">
<td align="left">univ6</td>
<td align="left">2025-168</td>
<td align="left">local6</td>
<td align="left">2025juin17</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="session-info" class="section level2">
<h2>Session-Info</h2>
<pre><code>## R version 4.5.0 (2025-04-11 ucrt)
## Platform: x86_64-w64-mingw32/x64
## Running under: Windows 11 x64 (build 26100)
## 
## Matrix products: default
##   LAPACK version 3.12.1
## 
## locale:
## [1] LC_COLLATE=C                   LC_CTYPE=French_France.utf8   
## [3] LC_MONETARY=French_France.utf8 LC_NUMERIC=C                  
## [5] LC_TIME=French_France.utf8    
## 
## time zone: Europe/Paris
## tzcode source: internal
## 
## attached base packages:
## [1] stats     graphics  grDevices utils     datasets  methods   base     
## 
## other attached packages:
## [1] limma_3.64.0  knitr_1.50    wrMisc_1.15.4
## 
## loaded via a namespace (and not attached):
##  [1] gtable_0.3.6       jsonlite_2.0.0     dplyr_1.1.4        compiler_4.5.0    
##  [5] Rcpp_1.0.14        tidyselect_1.2.1   stringr_1.5.1      dichromat_2.0-0.1 
##  [9] jquerylib_0.1.4    splines_4.5.0      scales_1.4.0       yaml_2.3.10       
## [13] fastmap_1.2.0      statmod_1.5.0      plyr_1.8.9         ggplot2_3.5.2     
## [17] R6_2.6.1           BBmisc_1.13        generics_0.1.3     fdrtool_1.2.18    
## [21] backports_1.5.0    checkmate_2.3.2    tibble_3.2.1       bslib_0.9.0       
## [25] pillar_1.10.2      RColorBrewer_1.1-3 rlang_1.1.6        stringi_1.8.7     
## [29] cachem_1.1.0       xfun_0.52          sass_0.4.10        wrGraph_1.3.10    
## [33] cli_3.6.5          magrittr_2.0.3     digest_0.6.37      grid_4.5.0        
## [37] lifecycle_1.0.4    vctrs_0.6.5        qvalue_2.40.0      evaluate_1.0.3    
## [41] glue_1.8.0         data.table_1.17.0  farver_2.1.2       reshape2_1.4.4    
## [45] rmarkdown_2.29     tools_4.5.0        pkgconfig_2.0.3    htmltools_0.5.8.1</code></pre>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
